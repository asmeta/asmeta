package asmeta.evotest.experiments;

import java.io.File;
import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.asmeta.parser.ASMParser;
import org.asmeta.simulator.RuleEvaluator;
import org.asmeta.simulator.main.Simulator;
import org.asmeta.xt.validator.AsmetaV;
import org.asmeta.xt.validator.RuleEvalWCov;
import org.asmeta.xt.validator.SimulatorWCov;

import asmeta.AsmCollection;
import asmeta.evotest.experiments.model.ModelDataCollector;
import asmeta.evotest.experiments.scenario.ScenarioDataCollector;
import asmeta.evotest.experiments.scenario.validator.ScenarioValidator;
import asmeta.evotest.experiments.scenario.validator.ValidationDataCollector;
import asmeta.evotest.experiments.utils.CsvManager;
import asmeta.evotest.experiments.utils.YamlManager;

public class CoverageAnalysisRunner {
	private static final String DATA_CSV = "data.csv";

	private static final Logger LOG = Logger.getLogger(CoverageAnalysisRunner.class);

	/**
	 * Entry point for aggregating scenario-generation and validation results into a
	 * CSV. Given a base directory (containing subfolders {@code randomtests/},
	 * {@code atgttests/}, {@code evoavallatests/}), walks each directory, then each
	 * generated scenario suite directory, and for each suite run validation and
	 * write model, scenarios, and validation data to csv.
	 *
	 * @param args command-line arguments
	 *             <ul>
	 *             <li>{@code args[0]} – the base directory to scan</li>
	 *             <li>{@code args[0]} – {@code --shuffle}: optional flag that
	 *             enables shuffled, non-deterministic execution of choose rules
	 *             when present; if omitted, execution is deterministic</li>
	 *             </ul>
	 */
	public static void main(String[] args) {
		// Set logging and silence stdout
		LOG.setLevel(Level.INFO);
		Logger.getLogger(RuleEvaluator.class).setLevel(Level.ERROR);
		Logger.getLogger(Simulator.class).setLevel(Level.ERROR);
		Logger.getLogger(RuleEvalWCov.class).setLevel(Level.ERROR);
		Logger.getLogger(SimulatorWCov.class).setLevel(Level.ERROR);
		Logger.getLogger(AsmetaV.class).setLevel(Level.ERROR);
		ASMParser.getResultLogger().setLevel(Level.ERROR);
		System.setOut(new PrintStream(OutputStream.nullOutputStream()));
		
		// Validate input directory argument
		if (args.length < 1)
			LOG.error("Missing argument: directory to search for scenarios.");
		String baseDir = args[0];
		boolean shuffle;
		if (args.length == 1) {
			shuffle = false;
		} else {
			if (args[1].equals("--shuffle")) {
				shuffle = true;
			} else {
				LOG.error("Error in second argument: it must be --shuffle or not be present.");
				return;
			}
		}

		// Prepare the output CSV (clean sibling temp if present CSVs and write header)
		String csvPath = baseDir + File.separator + DATA_CSV;
		CsvManager csvManager;
		try {
			csvManager = new CsvManager(csvPath);
			csvManager.clean();
			csvManager.setup();
		} catch (Throwable t) {
			LOG.error("Error while deleting temp files or writing header to " + csvPath + "\n"
					+ t.getClass().getSimpleName() + ": " + t.getMessage());
			t.printStackTrace();
			return;
		}

		// Iterate over approach directories (randomtests/, atgttests/, evoavallatests/)
		File[] approachDirs = new File(baseDir).listFiles();
		for (File approachDir : approachDirs) {
			if (approachDir.isDirectory() && approachDir.listFiles().length > 0) {
				String approach = approachDir.getName().replace("tests", "");
				LOG.info("Running analysis on scenarios generated by " + approach + ".");
				// Iterate over individual scenario-suite directories
				File[] scenarioDirs = approachDir.listFiles();
				for (File scenarioDir : scenarioDirs) {
					if (scenarioDir.isDirectory() && scenarioDir.listFiles().length > 0) {
						LOG.info("\nAnalysing " + scenarioDir);
						
						// Find and read the metadata YAML
						String asmName;
						String asmPath;
						float execTime;
						try {
							LOG.info("Reading metadata YAML file.");
						    File[] yamlFiles = scenarioDir.listFiles(file ->
						        file.isFile() && file.getName().toLowerCase().endsWith(".yaml")
						    );
						    File metadataFile = yamlFiles[0];						    		
							Map<String, Object> metadata = YamlManager.load(metadataFile);
							asmName = (String) metadata.get(YamlManager.ASM_NAME);
							asmPath = (String) metadata.get(YamlManager.ASM_PATH);
							execTime = ((Number) metadata.get(YamlManager.EXEC_TIME)).floatValue();
						} catch (Throwable t) {
							LOG.error("Error while trying to access metadata YAML file.\n" + t.getClass().getSimpleName() + ": "
									+ t.getMessage());
							continue;
						}
						
						// Resolve ASM absolute path and parse the model
						AsmCollection asm;
						try {
							LOG.info("Parsing " + asmName + ".");
							Path basePath = Path.of(scenarioDir.getCanonicalPath());
							String asmAbsolutePath = basePath.resolve(Paths.get(asmPath)).normalize().toAbsolutePath()
									.toString();
							asm = ASMParser.setUpReadAsm(new File(asmAbsolutePath));
						} catch (Throwable t) {
							LOG.error("Error while parsing " + asmName + ".\n" + t.getClass().getSimpleName() + ": "
									+ t.getMessage());
							continue;
						}
						
						// Collect model data
						Map<String, String> modelData;
						try {
							LOG.info("Collecting model data.");
							modelData = ModelDataCollector.collectModelData(asm);
						} catch (Throwable t) {
							LOG.error("Error while collecting model data.\n" + t.getClass().getSimpleName() + ": "
									+ t.getMessage());
							continue;
						}
						
						// Collect scenario data
						int nScenario;
						Map<String, Integer> avallaData;
						try {
							LOG.info("Collecting test suite data.");
							String dir = scenarioDir.toString();
							avallaData = ScenarioDataCollector.collectAvallaData(dir);
							nScenario = ScenarioDataCollector.getNumberOfScenario(dir);
						} catch (Throwable t) {
							LOG.error("Error while collecting test suite data.\n" + t.getClass().getSimpleName() + ": "
									+ t.getMessage());
							continue;
						}
						
						// Run validation to compute coverage, data is stored in a temporary CSV
						int valErrors;
						String tempCsvPath;
						try {
							LOG.info("Running validation, saving temporary results in temp.csv.");
							tempCsvPath = csvManager.getParentDir() + File.separator + "temp.csv";
							valErrors = ScenarioValidator.computeCoverageFromAvalla(scenarioDir.getPath(), tempCsvPath,
									shuffle);
						} catch (Throwable t) {
							LOG.error("Error while running validation.\n" + t.getClass().getSimpleName() + ": "
									+ t.getMessage());
							continue;
						} finally {
							// Reset rule evaluation state before processing the next suite
							RuleEvalWCov.reset();
						}
						
						// Aggregate coverage metrics from the temporary CSV
						Map<String, String> covData;
						try {
							LOG.info("Aggregating validation data.");
							covData = ValidationDataCollector.collectCoverageData(tempCsvPath, asmName, modelData);
						} catch (Throwable t) {
							LOG.error("Error aggregating validation data.\n" + t.getClass().getSimpleName() + ": "
									+ t.getMessage());
							continue;
						}
						
						// Append a consolidated row to data.csv
						try {
							LOG.info("Writing to " + DATA_CSV + ".");
							csvManager.writeData(modelData, avallaData, covData, asmName, approach, execTime, nScenario,
									valErrors);
						} catch (Throwable t) {
							LOG.error("Error while writing to" + DATA_CSV + ".\n" + t.getClass().getSimpleName() + ": "
									+ t.getMessage());
							continue;
						}
						
						// Clean the temporary CSV
						try {
							LOG.info("Deleting temporary csv.");
							csvManager.clean();
						} catch (Throwable t) {
							LOG.error("Error while deleting temporary csv.\n" + t.getClass().getSimpleName() + ": "
									+ t.getMessage());
						}
					}
				}
			}
		}
		LOG.info("\nAnalysis completed.");
	}

}
