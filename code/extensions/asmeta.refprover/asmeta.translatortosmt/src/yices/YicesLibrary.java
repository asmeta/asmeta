package yices;

import java.nio.DoubleBuffer;
import java.nio.IntBuffer;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.DoubleByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.NativeLongByReference;
import com.sun.jna.ptr.PointerByReference;
/**
 * JNA Wrapper for library <b>yices</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface YicesLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "yices";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(YicesLibrary.JNA_LIBRARY_NAME);
	public static final YicesLibrary INSTANCE = (YicesLibrary)Native.loadLibrary(YicesLibrary.JNA_LIBRARY_NAME, YicesLibrary.class);
	/**
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:45</i><br>
	 * enum values
	 */
	/**
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:45</i><br>
	 * enum values
	 */
	public static interface lbool {
		/// <i>native declaration : yices-1.0.34/include/yices_c.h:42</i>
		public static final int l_false = -1;
		/// <i>native declaration : yices-1.0.34/include/yices_c.h:43</i>
		public static final int l_undef = 0;
		/// <i>native declaration : yices-1.0.34/include/yices_c.h:44</i>
		public static final int l_true = 1;
	};
	/**
	 * \brief Return the yices version number.<br>
	 * Original signature : <code>char* yices_version()</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:50</i>
	 */
	String yices_version();
	/**
	 * \brief Set the verbosity level.<br>
	 * Original signature : <code>void yices_set_verbosity(int)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:55</i>
	 */
	void yices_set_verbosity(int l);
	/**
	 * \brief Force Yices to type check expressions when they are asserted (default = false).<br>
	 * Original signature : <code>void yices_enable_type_checker(int)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:60</i>
	 */
	void yices_enable_type_checker(int flag);
	/**
	 * \brief Enable a log file that will store the assertions, checks, decls, etc.<br>
	 * If the log file is already open, then nothing happens.<br>
	 * return code: <br>
	 * 1 if the operation succeeded<br>
	 * 0 if there's already a log file<br>
	 * -1 if 'file_name' can't be opened for write (or some other file error)<br>
	 * Original signature : <code>int yices_enable_log_file(const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:70</i><br>
	 * @deprecated use the safer methods {@link #yices_enable_log_file(java.lang.String)} and {@link #yices_enable_log_file(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int yices_enable_log_file(Pointer file_name);
	/**
	 * \brief Enable a log file that will store the assertions, checks, decls, etc.<br>
	 * If the log file is already open, then nothing happens.<br>
	 * return code: <br>
	 * 1 if the operation succeeded<br>
	 * 0 if there's already a log file<br>
	 * -1 if 'file_name' can't be opened for write (or some other file error)<br>
	 * Original signature : <code>int yices_enable_log_file(const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:70</i>
	 */
	int yices_enable_log_file(String file_name);
	/**
	 * \brief Inform yices that only arithmetic theory is going to be used.<br>
	 * This flag usually improves performance (default = false).<br>
	 * Original signature : <code>void yices_set_arith_only(int)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:76</i>
	 */
	void yices_set_arith_only(int flag);
	/**
	 * \brief Set the maximum number of conflicts that are allowed in a maxsat iteration.<br>
	 * If the maximum is reached, then "unknown" (i.e., l_undef) is returned by maxsat.<br>
	 * Original signature : <code>void yices_set_max_num_conflicts_in_maxsat_iteration(unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:82</i>
	 */
	void yices_set_max_num_conflicts_in_maxsat_iteration(int n);
	/**
	 * \brief Set the maximum number of iterations in the MaxSAT algorithm.<br>
	 * If the maximum is reached, then "unknown" (i.e., l_undef) is returned by maxsat.<br>
	 * Original signature : <code>void yices_set_max_num_iterations_in_maxsat(unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:88</i>
	 */
	void yices_set_max_num_iterations_in_maxsat(int n);
	/**
	 * \brief Set the initial cost for a maxsat problem.<br>
	 * Original signature : <code>void yices_set_maxsat_initial_cost(long long)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:93</i>
	 */
	void yices_set_maxsat_initial_cost(long c);
	/**
	 * \brief Create a logical context.<br>
	 * Original signature : <code>yices_context yices_mk_context()</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:98</i>
	 */
	Pointer yices_mk_context();
	/**
	 * \brief Delete the given logical context.<br>
	 * \sa yices_mk_context<br>
	 * Original signature : <code>void yices_del_context(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:104</i>
	 */
	void yices_del_context(Pointer ctx);
	/**
	 * \brief Reset the given logical context.<br>
	 * Original signature : <code>void yices_reset(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:109</i>
	 */
	void yices_reset(Pointer ctx);
	/**
	 * \brief Display the internal representation of the given logical context on <tt>stderr</tt>. <br>
	 * This function is mostly for debugging.<br>
	 * Original signature : <code>void yices_dump_context(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:115</i>
	 */
	void yices_dump_context(Pointer ctx);
	/**
	 * \brief Create a backtracking point in the given logical context.<br>
	 * The logical context can be viewed as a stack of contexts.<br>
	 * The scope level is the number of elements on this stack. The stack<br>
	 * of contexts is simulated using trail (undo) stacks.<br>
	 * Original signature : <code>void yices_push(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:123</i>
	 */
	void yices_push(Pointer ctx);
	/**
	 * \brief Backtrack.<br>
	 * Restores the context from the top of the stack, and pops it off the<br>
	 * stack.  Any changes to the logical context (by #yices_assert or<br>
	 * other functions) between the matching #yices_push and \c yices_pop<br>
	 * operators are flushed, and the context is completely restored to<br>
	 * what it was right before the #yices_push.<br>
	 * \sa yices_push<br>
	 * Original signature : <code>void yices_pop(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:134</i>
	 */
	void yices_pop(Pointer ctx);
	/**
	 * \brief Assert a constraint in the logical context.<br>
	 * After an assertion, the logical context may become inconsistent.<br>
	 * The method #yices_inconsistent may be used to check that.<br>
	 * Original signature : <code>void yices_assert(yices_context, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:141</i>
	 */
	void yices_assert(Pointer ctx, Pointer expr);
	/**
	 * \brief Assert a constraint in the logical context with weight \c w.<br>
	 * \returns An id that can be used to retract the constraint.<br>
	 * \sa yices_retract<br>
	 * Original signature : <code>assertion_id yices_assert_weighted(yices_context, yices_expr, long long)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:148</i>
	 */
	int yices_assert_weighted(Pointer ctx, Pointer expr, long w);
	/**
	 * \brief Assert a constraint that can be later retracted.<br>
	 * \returns An id that can be used to retract the constraint.<br>
	 * This is similar to #yices_assert_weighted, but the weight is considered to be infinite.<br>
	 * \sa yices_retract<br>
	 * Original signature : <code>assertion_id yices_assert_retractable(yices_context, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:156</i>
	 */
	int yices_assert_retractable(Pointer ctx, Pointer expr);
	/**
	 * \brief Retract a retractable or weighted constraint.<br>
	 * \sa yices_assert_weighted<br>
	 * \sa yices_assert_retractable<br>
	 * Original signature : <code>void yices_retract(yices_context, assertion_id)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:163</i>
	 */
	void yices_retract(Pointer ctx, int id);
	/**
	 * \brief Check whether the logical context is known to be inconsistent.<br>
	 * If the function returns true (i.e., a non-zero value) then the context <br>
	 * is inconsistent. If it returns false (i.e., 0) then the context's status<br>
	 * is unknown. To determine the status in this case, call #yices_check.<br>
	 * Original signature : <code>int yices_inconsistent(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:171</i>
	 */
	int yices_inconsistent(Pointer ctx);
	/**
	 * \brief Check if the logical context is satisfiable. <br>
	 * - \c l_true means the context is satisfiable<br>
	 * - \c l_false means it is unsatisfiable<br>
	 * - \c l_undef means it was not possible to decide due to an incompleteness.<br>
	 * If the context is satisfiable, then #yices_get_model can be used to obtain a model.<br>
	 * \warning This method ignore the weights associated with the constraints.<br>
	 * Original signature : <code>lbool yices_check(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:181</i>
	 */
	int yices_check(Pointer ctx);
	/**
	 * \brief Compute the maximal satisfying assignment for the asserted<br>
	 * weighted constraints.<br>
	 * - \c l_true means the maximal satisfying assignment was found<br>
	 * - \c l_false means it is unsatisfiable (this may happen if the context has <br>
	 * unweighted constraints)<br>
	 * - \c l_undef means it was not possible to decide due to an incompleteness.<br>
	 * If the result is \c l_true, then #yices_get_model can be used to obtain a model.<br>
	 * \sa yices_assert_weighted<br>
	 * Original signature : <code>lbool yices_max_sat(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:193</i>
	 */
	int yices_max_sat(Pointer ctx);
	/**
	 * \brief Similar to yices_max_sat, but start looking for models with cost<br>
	 * less than of equal to \c max_cost.<br>
	 * \return l_false if such a model doesn't exist.<br>
	 * Original signature : <code>lbool yices_max_sat_cost_leq(yices_context, long long)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:200</i>
	 */
	int yices_max_sat_cost_leq(Pointer c, long max_cost);
	/**
	 * \brief Search for a model of the constraints asserted in \c ctx<br>
	 * and compute its cost. <br>
	 * If \c random is non-zero, then random search is used,<br>
	 * otherwise, the default decision heuristic is used.<br>
	 * If there are no weighted constaints in \c ctx, then this function is the same as #yices_check.<br>
	 * Otherwise, it searches for a model that satisfies all the<br>
	 * non-weighted constraints but not necessarily the weighted<br>
	 * constraints. The function returns \c l_true if such a model is<br>
	 * found, and the model can be obtained using #yices_get_model.  The<br>
	 * cost of this model is the sum of the weights of the unsatisfied<br>
	 * weighted constraints.<br>
	 * The function returns \c l_false if it cannot find such a model.<br>
	 * The function may also return \c l_undef, if the context contains<br>
	 * formulas for which yices is incomplete (e.g., quantifiers). Do not<br>
	 * use the model in this case.<br>
	 * Original signature : <code>lbool yices_find_weighted_model(yices_context, int)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:219</i>
	 */
	int yices_find_weighted_model(Pointer ctx, int random);
	/**
	 * \brief Get the size of the unsat core<br>
	 * The unsat core is constructed after a call to #yices_check <br>
	 * if the context is found unsatisfiable. It's an unsatisfiable <br>
	 * subset of the retractable assertions (represented as an array<br>
	 * of \c assertion_ids). This function returns the size of that <br>
	 * set.<br>
	 * Return 0 if there's no unsat core.<br>
	 * \sa yices_get_unsat_core<br>
	 * Original signature : <code>int yices_get_unsat_core_size(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:231</i>
	 */
	int yices_get_unsat_core_size(Pointer ctx);
	/**
	 * \brief Copy the unsat core into array a<br>
	 * \warning a must be large enough to store the core <br>
	 * (check the size first using #yices_get_unsat_core_size)<br>
	 * Each element in a is the id of a retractable assertion <br>
	 * Return the number of elements copied into a (which is <br>
	 * equal to the unsat core size as returned by <br>
	 * #yices_get_unsat_core_size)<br>
	 * \sa yices_assert_retractable<br>
	 * \sa yices_get_unsat_core_size<br>
	 * Original signature : <code>int yices_get_unsat_core(yices_context, assertion_id[])</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:244</i><br>
	 * @deprecated use the safer methods {@link #yices_get_unsat_core(com.sun.jna.Pointer, java.nio.IntBuffer)} and {@link #yices_get_unsat_core(com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int yices_get_unsat_core(Pointer ctx, IntByReference a);
	/**
	 * \brief Copy the unsat core into array a<br>
	 * \warning a must be large enough to store the core <br>
	 * (check the size first using #yices_get_unsat_core_size)<br>
	 * Each element in a is the id of a retractable assertion <br>
	 * Return the number of elements copied into a (which is <br>
	 * equal to the unsat core size as returned by <br>
	 * #yices_get_unsat_core_size)<br>
	 * \sa yices_assert_retractable<br>
	 * \sa yices_get_unsat_core_size<br>
	 * Original signature : <code>int yices_get_unsat_core(yices_context, assertion_id[])</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:244</i>
	 */
	int yices_get_unsat_core(Pointer ctx, IntBuffer a);
	/**
	 * \brief Return a model for a satisfiable logical context.<br>
	 * \warning The should be only called if #yices_check or #yices_max_sat <br>
	 * returned \c l_true or \c l_undef.<br>
	 * Return 0 if a model is not available.<br>
	 * Calls to functions which modify the context invalidate the model.<br>
	 * Original signature : <code>yices_model yices_get_model(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:253</i>
	 */
	Pointer yices_get_model(Pointer ctx);
	/**
	 * \brief Return the assignment for the variable \c v. <br>
	 * The result is \c l_undef if the value of \c v is a "don't care".<br>
	 * \warning \c v must be the declaration of a boolean variable<br>
	 * \sa yices_get_int_value<br>
	 * \sa yices_get_arith_value<br>
	 * \sa yices_get_double_value<br>
	 * Original signature : <code>lbool yices_get_value(yices_model, yices_var_decl)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:263</i>
	 */
	int yices_get_value(Pointer m, Pointer v);
	/**
	 * \brief Get the integer value assigned to variable \c v in model \c m<br>
	 * The value is stored in <tt>* value<tt>. Returns 1 on success.<br>
	 * A return code of 0 indicates one of the following errors:<br>
	 * - \c v is not a proper declaration or not the declaration of a numerical variable<br>
	 * - \c v has no value assigned in model m (typically, this means that v does not <br>
	 * occur in the asserted constraints)<br>
	 * - \c v has a value that cannot be converted to <tt>long</tt>, because<br>
	 * it is rational or too big <br>
	 * \sa yices_get_value<br>
	 * \sa yices_get_arith_value<br>
	 * \sa yices_get_double_value<br>
	 * Original signature : <code>int yices_get_int_value(yices_model, yices_var_decl, long*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:278</i>
	 */
	int yices_get_int_value(Pointer m, Pointer d, NativeLongByReference value);
	/**
	 * \brief Get the rational value assigned to variable \c v in model \c m<br>
	 * The numerator is stored in <tt>* num</tt> and the denominator <br>
	 * in <tt>* den</tt>. Returns 1 on success.<br>
	 * A return code of 0 indicates one of the following errors:<br>
	 * - \c v is not a proper declaration or not the declaration of a numerical variable<br>
	 * - \c v has no value assigned in model m (typically, this means that v does not <br>
	 * occur in the asserted constraints)<br>
	 * - \c v has a value that cannot be converted to <tt>long/long</tt>, <br>
	 * because the numerator or the denominator is too big<br>
	 * \sa yices_get_value<br>
	 * \sa yices_get_int_value<br>
	 * \sa yices_get_double_value<br>
	 * Original signature : <code>int yices_get_arith_value(yices_model, yices_var_decl, long*, long*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:294</i>
	 */
	int yices_get_arith_value(Pointer m, Pointer d, NativeLongByReference num, NativeLongByReference den);
	/**
	 * \brief Convert the value assigned to variable \c v in model \c m to a floating <br>
	 * point number. <br>
	 * The value is stored in <tt>* value<tt>. Returns 1 on success.<br>
	 * A return code of 0 indicates one of the following errors:<br>
	 * - \c v is not a proper declaration or not the declaration of a numerical variable<br>
	 * - \c v has no value assigned in model m (typically, this means that v does not <br>
	 * occur in the asserted constraints)<br>
	 * \sa yices_get_value<br>
	 * \sa yices_get_int_value<br>
	 * \sa yices_get_arith_value<br>
	 * Original signature : <code>int yices_get_double_value(yices_model, yices_var_decl, double*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:308</i><br>
	 * @deprecated use the safer methods {@link #yices_get_double_value(com.sun.jna.Pointer, com.sun.jna.Pointer, java.nio.DoubleBuffer)} and {@link #yices_get_double_value(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.DoubleByReference)} instead
	 */
	@Deprecated 
	int yices_get_double_value(Pointer m, Pointer d, DoubleByReference value);
	/**
	 * \brief Convert the value assigned to variable \c v in model \c m to a floating <br>
	 * point number. <br>
	 * The value is stored in <tt>* value<tt>. Returns 1 on success.<br>
	 * A return code of 0 indicates one of the following errors:<br>
	 * - \c v is not a proper declaration or not the declaration of a numerical variable<br>
	 * - \c v has no value assigned in model m (typically, this means that v does not <br>
	 * occur in the asserted constraints)<br>
	 * \sa yices_get_value<br>
	 * \sa yices_get_int_value<br>
	 * \sa yices_get_arith_value<br>
	 * Original signature : <code>int yices_get_double_value(yices_model, yices_var_decl, double*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:308</i>
	 */
	int yices_get_double_value(Pointer m, Pointer d, DoubleBuffer value);
	/**
	 * \brief Convert the value assigned to a  variable \c v in model \c m to a <br>
	 * character string. The string is returned into a record of the previous type.<br>
	 * If the value of v can't be returned, then <br>
	 * r->flag is set to 0<br>
	 * r->str is set to NULL<br>
	 * otherwise<br>
	 * r->flag is set to 1<br>
	 * r->str = v's value converted to a string (decimal format).<br>
	 * The string r->str is allocated internally by yices. To free it <br>
	 * when it's no longer needed, call yices_free_string(r).<br>
	 * Original signature : <code>void yices_get_arith_value_as_string(yices_model, yices_var_decl, srec_t*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:322</i>
	 */
	void yices_get_arith_value_as_string(Pointer m, Pointer d, srec_t r);
	/**
	 * \brief Free the string returned by the preceding function in r.<br>
	 * This also resets r->flag to 0 and r->str to NULL.<br>
	 * Original signature : <code>void yices_free_string(srec_t*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:328</i>
	 */
	void yices_free_string(srec_t r);
	/**
	 * \brief Get the bitvector constant assigned to a variable v in model m.   <br>
	 * The value stored in array \c bv: <tt>bv[0]</tt> is the low-order<br>
	 * bit and <tt>bv[n - 1]</tt> is the high-order bit. <br>
	 * - \c n should be the size of the bitvector variable v.  Otherwise, if<br>
	 * - \c n is smaller than \c v's size, the n lower-order bits of v<br>
	 * are returned. If \c n is larger than \c v's size then the extra<br>
	 * high-order bits are set to 0.<br>
	 * The return code is 0 if an error occurs, 1 otherwise. Possible errors are:<br>
	 * - \c d is not the declaration of a bitvector variable.<br>
	 * - \c d is not assigned a value in model m<br>
	 * Original signature : <code>int yices_get_bitvector_value(yices_model, yices_var_decl, unsigned, int[])</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:342</i><br>
	 * @deprecated use the safer methods {@link #yices_get_bitvector_value(com.sun.jna.Pointer, com.sun.jna.Pointer, int, java.nio.IntBuffer)} and {@link #yices_get_bitvector_value(com.sun.jna.Pointer, com.sun.jna.Pointer, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	int yices_get_bitvector_value(Pointer m, Pointer d, int n, IntByReference bv);
	/**
	 * \brief Get the bitvector constant assigned to a variable v in model m.   <br>
	 * The value stored in array \c bv: <tt>bv[0]</tt> is the low-order<br>
	 * bit and <tt>bv[n - 1]</tt> is the high-order bit. <br>
	 * - \c n should be the size of the bitvector variable v.  Otherwise, if<br>
	 * - \c n is smaller than \c v's size, the n lower-order bits of v<br>
	 * are returned. If \c n is larger than \c v's size then the extra<br>
	 * high-order bits are set to 0.<br>
	 * The return code is 0 if an error occurs, 1 otherwise. Possible errors are:<br>
	 * - \c d is not the declaration of a bitvector variable.<br>
	 * - \c d is not assigned a value in model m<br>
	 * Original signature : <code>int yices_get_bitvector_value(yices_model, yices_var_decl, unsigned, int[])</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:342</i>
	 */
	int yices_get_bitvector_value(Pointer m, Pointer d, int n, IntBuffer bv);
	/**
	 * \brief Get the value assigned to a variable of scalar type in model m as an<br>
	 * integer index<br>
	 * If <tt>d</tt> is a variable declaration of a scalar type <tt>tau</tt>, then <br>
	 * <tt>tau</tt> must have been defined as (define-type tau (scalar e_0 ... e_{n-1}))<br>
	 * for some <tt>n>0</tt>. <br>
	 * This function returns the value of variable d in model m as an index<br>
	 * between 0 and {n-1}. (i.e., if the function returns i then the <br>
	 * value of d is e_{i}).<br>
	 * The function returns -1 if an error occurs.<br>
	 * Possible errors are:<br>
	 * - \c d is not the declaration of a scalar variable<br>
	 * - \c d is not assigned a value in model m<br>
	 * Original signature : <code>int yices_get_scalar_value(yices_model, yices_var_decl)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:358</i>
	 */
	int yices_get_scalar_value(Pointer m, Pointer d);
	/**
	 * \brief Get the value assigned to a variable of scalar type in model m as a string<br>
	 * If <tt>d</tt> is a variable declaration of a scalar type <tt>tau</tt>, then <br>
	 * <tt>tau</tt> must have been defined as (define-type tau (scalar e_0 ... e_{n-1}))<br>
	 * for some <tt>n>0</tt>. <br>
	 * This function returns the value of variable d in model m as one of the strings "e_{i}"<br>
	 * The function returns NULL if an error occurs.<br>
	 * Possible errors are:<br>
	 * - \c d is not the declaration of a scalar variable<br>
	 * - \c d is not assigned a value in model m<br>
	 * Original signature : <code>char* yices_get_scalar_value_name(yices_model, yices_var_decl)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:371</i>
	 */
	String yices_get_scalar_value_name(Pointer m, Pointer d);
	/**
	 * \brief Return 1 (0) if the assertion of the given \c id is satisfied (not<br>
	 * satisfied) in the model \c m.<br>
	 * This function is only useful for assertion ids obtained using #yices_assert_weighted,<br>
	 * and #yices_max_sat was used to build the model. That is the only scenario where an<br>
	 * assertion may not be satisfied in a model produced by yices.<br>
	 * Original signature : <code>int yices_get_assertion_value(yices_model, assertion_id)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:380</i>
	 */
	int yices_get_assertion_value(Pointer m, int id);
	/**
	 * \brief Evaluate a formula in a model.<br>
	 * Model \c m can be obtained via #yices_get_model, after a call to #yices_check,<br>
	 * #yices_max_sat, or #yices_find_weighted_model<br>
	 * - \c l_true means the formula is true in the model<br>
	 * - \c l_false means the formula is false in the model<br>
	 * - \c l_undef means the model does not have enough information.<br>
	 * typically this is due to a function application, e.g., <br>
	 * the model defines (f 1) and (f 2), but the formula references (f 3)<br>
	 * Original signature : <code>lbool yices_evaluate_in_model(yices_model, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:392</i>
	 */
	int yices_evaluate_in_model(Pointer m, Pointer e);
	/**
	 * \brief Display the given model in the standard output.<br>
	 * Original signature : <code>void yices_display_model(yices_model)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:397</i>
	 */
	void yices_display_model(Pointer m);
	/**
	 * \brief Return the cost of model \c m. <br>
	 * The cost is the sum of the weights of unsatisfied constraints.<br>
	 * \warning The model cost is computed automatically by #yices_max_sat but <br>
	 * not by #yices_check. If #yices_check returns \c l_true (or \c l_undef),<br>
	 * you can call #yices_compute_model_cost to compute the cost explicitly.<br>
	 * Original signature : <code>long long yices_get_cost(yices_model)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:406</i>
	 */
	long yices_get_cost(Pointer m);
	/**
	 * \brief Return the cost of the model m, converted to a double-precision <br>
	 * floating point number.<br>
	 * Original signature : <code>double yices_get_cost_as_double(yices_model)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:412</i>
	 */
	double yices_get_cost_as_double(Pointer m);
	/**
	 * \brief Create an iterator that can be used to traverse the boolean variables (var_decl objects) in the <br>
	 * given logical context. <br>
	 * An iterator is particulary useful when we want to extract the assignment<br>
	 * (model) produced by the #yices_check command.<br>
	 * Example:<br>
	 * \code<br>
	 * yices_context ctx = yices_mk_context();<br>
	 * ...<br>
	 * if (yices_check(ctx) == l_true) {<br>
	 * yices_var_decl_iterator it = yices_create_var_decl_iterator(ctx);<br>
	 * yices_model m              = yices_get_model(ctx);<br>
	 * while (yices_iterator_has_next(it)) {<br>
	 * yices_var_decl d         = yices_iterator_next(it);<br>
	 * char *         val;<br>
	 * switch(yices_get_value(m, d)) {<br>
	 * case l_true: <br>
	 * val = "true"; <br>
	 * break;<br>
	 * case l_false: <br>
	 * val = "false";<br>
	 * break;<br>
	 * case l_undef: <br>
	 * val = "unknown"; <br>
	 * break;<br>
	 * }<br>
	 * printf("%s = %s\n", yices_get_var_decl_name(d), val);<br>
	 * }<br>
	 * yices_del_iterator(it);<br>
	 * }<br>
	 * \endcode<br>
	 * \sa yices_iterator_has_next<br>
	 * \sa yices_iterator_next<br>
	 * \sa yices_iterator_reset<br>
	 * Original signature : <code>yices_var_decl_iterator yices_create_var_decl_iterator(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:449</i>
	 */
	Pointer yices_create_var_decl_iterator(Pointer c);
	/**
	 * \brief Return 1 if the iterator \c it still has elements to be iterated.<br>
	 * Return 0 otherwise.<br>
	 * \sa yices_iterator_next<br>
	 * \sa yices_create_var_decl_iterator<br>
	 * Original signature : <code>int yices_iterator_has_next(yices_var_decl_iterator)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:457</i>
	 */
	int yices_iterator_has_next(Pointer it);
	/**
	 * \brief Return the next variable, and move the iterator.<br>
	 * \sa yices_iterator_has_next<br>
	 * \sa yices_create_var_decl_iterator<br>
	 * Original signature : <code>yices_var_decl yices_iterator_next(yices_var_decl_iterator)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:464</i>
	 */
	Pointer yices_iterator_next(Pointer it);
	/**
	 * \brief Reset the given iterator, that is, move it back to the first element.<br>
	 * Original signature : <code>void yices_iterator_reset(yices_var_decl_iterator)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:469</i>
	 */
	void yices_iterator_reset(Pointer it);
	/**
	 * \brief Delete an iterator created with #yices_create_var_decl_iterator.<br>
	 * Original signature : <code>void yices_del_iterator(yices_var_decl_iterator)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:474</i>
	 */
	void yices_del_iterator(Pointer it);
	/**
	 * \brief Parse string s as a Yices expression and return the expression.<br>
	 * The string must use the Yices input language (not SMT-LIB).<br>
	 * \return NULL if there's an error in parsing or typechecking.<br>
	 * \return the expression otherwise.<br>
	 * If there's an error, function yices_get_last_error_message can be used<br>
	 * to retrieve the error message.<br>
	 * Original signature : <code>yices_expr yices_parse_expression(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:484</i><br>
	 * @deprecated use the safer methods {@link #yices_parse_expression(com.sun.jna.Pointer, java.lang.String)} and {@link #yices_parse_expression(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer yices_parse_expression(Pointer ctx, Pointer s);
	/**
	 * \brief Parse string s as a Yices expression and return the expression.<br>
	 * The string must use the Yices input language (not SMT-LIB).<br>
	 * \return NULL if there's an error in parsing or typechecking.<br>
	 * \return the expression otherwise.<br>
	 * If there's an error, function yices_get_last_error_message can be used<br>
	 * to retrieve the error message.<br>
	 * Original signature : <code>yices_expr yices_parse_expression(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:484</i>
	 */
	Pointer yices_parse_expression(Pointer ctx, String s);
	/**
	 * \brief Parse string s as a Yices type and return the type.<br>
	 * The string must uses the Yices input language (not SMT-LIB).<br>
	 * \return NULL if there's an error in parsing or typechecking.<br>
	 * \return the type otherwise.<br>
	 * If there's an error, function yices_get_last_error_message can be used<br>
	 * to retrieve the error message.<br>
	 * Original signature : <code>yices_type yices_parse_type(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:494</i><br>
	 * @deprecated use the safer methods {@link #yices_parse_type(com.sun.jna.Pointer, java.lang.String)} and {@link #yices_parse_type(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer yices_parse_type(Pointer ctx, Pointer s);
	/**
	 * \brief Parse string s as a Yices type and return the type.<br>
	 * The string must uses the Yices input language (not SMT-LIB).<br>
	 * \return NULL if there's an error in parsing or typechecking.<br>
	 * \return the type otherwise.<br>
	 * If there's an error, function yices_get_last_error_message can be used<br>
	 * to retrieve the error message.<br>
	 * Original signature : <code>yices_type yices_parse_type(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:494</i>
	 */
	Pointer yices_parse_type(Pointer ctx, String s);
	/**
	 * \brief Parse and execute the command in string s. <br>
	 * s must use the Yices input language.<br>
	 * \return 1 if the command executes without error.<br>
	 * \return 0 otherwise.<br>
	 * If there's an error, function yices_get_last_error_message can be used<br>
	 * to retrieve the error message.<br>
	 * Original signature : <code>int yices_parse_command(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:504</i><br>
	 * @deprecated use the safer methods {@link #yices_parse_command(com.sun.jna.Pointer, java.lang.String)} and {@link #yices_parse_command(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int yices_parse_command(Pointer ctx, Pointer s);
	/**
	 * \brief Parse and execute the command in string s. <br>
	 * s must use the Yices input language.<br>
	 * \return 1 if the command executes without error.<br>
	 * \return 0 otherwise.<br>
	 * If there's an error, function yices_get_last_error_message can be used<br>
	 * to retrieve the error message.<br>
	 * Original signature : <code>int yices_parse_command(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:504</i>
	 */
	int yices_parse_command(Pointer ctx, String s);
	/**
	 * \brief Return the last error message.<br>
	 * Original signature : <code>char* yices_get_last_error_message()</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:509</i>
	 */
	String yices_get_last_error_message();
	/**
	 * \brief Return the type associated with the given name. If the type<br>
	 * does not exist, a new uninterpreted type is created.<br>
	 * \remark number, real, int, nat, bool, any are builtin types.<br>
	 * Original signature : <code>yices_type yices_mk_type(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:516</i><br>
	 * @deprecated use the safer methods {@link #yices_mk_type(com.sun.jna.Pointer, java.lang.String)} and {@link #yices_mk_type(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer yices_mk_type(Pointer ctx, Pointer name);
	/**
	 * \brief Return the type associated with the given name. If the type<br>
	 * does not exist, a new uninterpreted type is created.<br>
	 * \remark number, real, int, nat, bool, any are builtin types.<br>
	 * Original signature : <code>yices_type yices_mk_type(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:516</i>
	 */
	Pointer yices_mk_type(Pointer ctx, String name);
	/**
	 * \brief Returns the bitvector type (bv[size]).<br>
	 * Size must be positive.<br>
	 * Original signature : <code>yices_type yices_mk_bitvector_type(yices_context, unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:522</i>
	 */
	Pointer yices_mk_bitvector_type(Pointer ctx, int size);
	/**
	 * \brief Return a function type <tt>(-> d1 ... dn r)</tt>.<br>
	 * Original signature : <code>yices_type yices_mk_function_type(yices_context, yices_type[], unsigned, yices_type)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:527</i>
	 */
	Pointer yices_mk_function_type(Pointer ctx, Pointer domain, int domain_size, Pointer range);
	/**
	 * \brief Constructs the tuple type (arg[0], ..., arg[size-1]).<br>
	 * Original signature : <code>yices_type yices_mk_tuple_type(yices_context, yices_type*[], unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:532</i>
	 */
	Pointer yices_mk_tuple_type(Pointer ctx, PointerByReference args, int size);
	/**
	 * \brief Return a new boolean variable declaration. <br>
	 * It is an error to create two variables with the same name.<br>
	 * Original signature : <code>yices_var_decl yices_mk_bool_var_decl(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:538</i><br>
	 * @deprecated use the safer methods {@link #yices_mk_bool_var_decl(com.sun.jna.Pointer, java.lang.String)} and {@link #yices_mk_bool_var_decl(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer yices_mk_bool_var_decl(Pointer ctx, Pointer name);
	/**
	 * \brief Return a new boolean variable declaration. <br>
	 * It is an error to create two variables with the same name.<br>
	 * Original signature : <code>yices_var_decl yices_mk_bool_var_decl(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:538</i>
	 */
	Pointer yices_mk_bool_var_decl(Pointer ctx, String name);
	/**
	 * \brief Return a new (global) variable declaration. It is an error to create two variables<br>
	 * with the same name.<br>
	 * Original signature : <code>yices_var_decl yices_mk_var_decl(yices_context, const char*, yices_type)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:544</i><br>
	 * @deprecated use the safer methods {@link #yices_mk_var_decl(com.sun.jna.Pointer, java.lang.String, com.sun.jna.Pointer)} and {@link #yices_mk_var_decl(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer yices_mk_var_decl(Pointer ctx, Pointer name, Pointer ty);
	/**
	 * \brief Return a new (global) variable declaration. It is an error to create two variables<br>
	 * with the same name.<br>
	 * Original signature : <code>yices_var_decl yices_mk_var_decl(yices_context, const char*, yices_type)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:544</i>
	 */
	Pointer yices_mk_var_decl(Pointer ctx, String name, Pointer ty);
	/**
	 * \brief Return a variable declaration associated with the given name. <br>
	 * Return 0 if there is no variable declaration associated with the given name.<br>
	 * Original signature : <code>yices_var_decl yices_get_var_decl_from_name(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:550</i><br>
	 * @deprecated use the safer methods {@link #yices_get_var_decl_from_name(com.sun.jna.Pointer, java.lang.String)} and {@link #yices_get_var_decl_from_name(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer yices_get_var_decl_from_name(Pointer ctx, Pointer name);
	/**
	 * \brief Return a variable declaration associated with the given name. <br>
	 * Return 0 if there is no variable declaration associated with the given name.<br>
	 * Original signature : <code>yices_var_decl yices_get_var_decl_from_name(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:550</i>
	 */
	Pointer yices_get_var_decl_from_name(Pointer ctx, String name);
	/**
	 * \brief Return the variable declaration object associated with the given name expression.<br>
	 * \warning \c e must be a name expression created using methods such<br>
	 * as: #yices_mk_bool_var, #yices_mk_fresh_bool_var, or #yices_mk_bool_var_from_decl.<br>
	 * Original signature : <code>yices_var_decl yices_get_var_decl(yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:557</i>
	 */
	Pointer yices_get_var_decl(Pointer e);
	/**
	 * \brief Return a name of a variable declaration.<br>
	 * Original signature : <code>char* yices_get_var_decl_name(yices_var_decl)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:562</i>
	 */
	String yices_get_var_decl_name(Pointer d);
	/**
	 * \brief Return a name expression (instance) using the given variable declaration.<br>
	 * Original signature : <code>yices_expr yices_mk_var_from_decl(yices_context, yices_var_decl)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:567</i>
	 */
	Pointer yices_mk_var_from_decl(Pointer ctx, Pointer d);
	/**
	 * \brief Return a name expression (instance) using the given variable declaration.<br>
	 * Original signature : <code>yices_expr yices_mk_bool_var_from_decl(yices_context, yices_var_decl)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:572</i>
	 */
	Pointer yices_mk_bool_var_from_decl(Pointer ctx, Pointer d);
	/**
	 * \brief Return a name expression for the given variable name. <br>
	 * <tt>yices_mk_bool_var(c, n1) == yices_mk_bool_var(c, n2)</tt> when <tt>strcmp(n1, n2) == 0</tt>.<br>
	 * \sa yices_mk_bool_var_decl<br>
	 * \sa yices_mk_fresh_bool_var<br>
	 * \sa yices_mk_bool_var_from_decl<br>
	 * Original signature : <code>yices_expr yices_mk_bool_var(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:581</i><br>
	 * @deprecated use the safer methods {@link #yices_mk_bool_var(com.sun.jna.Pointer, java.lang.String)} and {@link #yices_mk_bool_var(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer yices_mk_bool_var(Pointer ctx, Pointer name);
	/**
	 * \brief Return a name expression for the given variable name. <br>
	 * <tt>yices_mk_bool_var(c, n1) == yices_mk_bool_var(c, n2)</tt> when <tt>strcmp(n1, n2) == 0</tt>.<br>
	 * \sa yices_mk_bool_var_decl<br>
	 * \sa yices_mk_fresh_bool_var<br>
	 * \sa yices_mk_bool_var_from_decl<br>
	 * Original signature : <code>yices_expr yices_mk_bool_var(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:581</i>
	 */
	Pointer yices_mk_bool_var(Pointer ctx, String name);
	/**
	 * \brief Return a fresh boolean variable.<br>
	 * Original signature : <code>yices_expr yices_mk_fresh_bool_var(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:586</i>
	 */
	Pointer yices_mk_fresh_bool_var(Pointer ctx);
	/**
	 * \brief Return an expression representing \c true.<br>
	 * Original signature : <code>yices_expr yices_mk_true(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:591</i>
	 */
	Pointer yices_mk_true(Pointer ctx);
	/**
	 * \brief Return an expression representing \c false.<br>
	 * Original signature : <code>yices_expr yices_mk_false(yices_context)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:596</i>
	 */
	Pointer yices_mk_false(Pointer ctx);
	/**
	 * \brief Return an expression representing the \c or of the given arguments.<br>
	 * \c n is the number of elements in the array \c args.<br>
	 * \warning \c n must be greater than zero.<br>
	 * Original signature : <code>yices_expr yices_mk_or(yices_context, yices_expr[], unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:603</i>
	 */
	Pointer yices_mk_or(Pointer ctx, PointerByReference args, int n);
	// added AG
	Pointer yices_mk_or(Pointer ctx, Pointer[] args, int n);
	/**
	 * \brief Return an expression representing the \c and of the given arguments.<br>
	 * \c n is the number of elements in the array \c args.<br>
	 * \warning \c n must be greater than zero.<br>
	 * Original signature : <code>yices_expr yices_mk_and(yices_context, yices_expr[], unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:610</i>
	 */
	Pointer yices_mk_and(Pointer ctx, PointerByReference args, int n);
	// ADDED BY AG (24/01/12)
	Pointer yices_mk_and(Pointer ctx, Pointer[] args, int n);
	/**
	 * \brief Return an expression representing <tt>(not a)</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_not(yices_context, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:615</i>
	 */
	Pointer yices_mk_not(Pointer ctx, Pointer a);
	/**
	 * \brief Return an expression representing <tt>a1 = a2</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_eq(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:620</i>
	 */
	Pointer yices_mk_eq(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Return an expression representing <tt>a1 /= a2</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_diseq(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:625</i>
	 */
	Pointer yices_mk_diseq(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Return an expression representing <tt>(if c t e)</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_ite(yices_context, yices_expr, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:630</i>
	 */
	Pointer yices_mk_ite(Pointer ctx, Pointer c, Pointer t, Pointer e);
	/**
	 * \brief Return a function application term <tt>(f t1 ... tn)</tt>.<br>
	 * The type of \c f must be a function-type, and its arity must<br>
	 * be equal to the number of arguments.<br>
	 * Original signature : <code>yices_expr yices_mk_app(yices_context, yices_expr, yices_expr[], unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:637</i>
	 */
	Pointer yices_mk_app(Pointer ctx, Pointer f, Pointer args, int n);
	/**
	 * \brief Build a function update term <tt>(update f (t1 ... tn) v)</tt>.<br>
	 * The type of \c f must be a function-type, and its arity must<br>
	 * be equal to the number of arguments.<br>
	 * Original signature : <code>yices_expr yices_mk_function_update(yices_context, yices_expr, yices_expr[], unsigned, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:644</i>
	 */
	Pointer yices_mk_function_update(Pointer ctx, Pointer f, Pointer args, int n, Pointer v);
	/**
	 * \brief Build the tuple term <tt>(tuple t1 ... tn)</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_tuple_literal(yices_context, yices_expr[], unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:649</i>
	 */
	Pointer yices_mk_tuple_literal(Pointer ctx, Pointer arg, int n);
	/**
	 * \brief Return an expression representing the given integer.<br>
	 * Original signature : <code>yices_expr yices_mk_num(yices_context, int)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:654</i>
	 */
	Pointer yices_mk_num(Pointer ctx, int n);
	/**
	 * \brief Return an expression representing the number provided in ASCII format.<br>
	 * Original signature : <code>yices_expr yices_mk_num_from_string(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:659</i><br>
	 * @deprecated use the safer methods {@link #yices_mk_num_from_string(com.sun.jna.Pointer, java.lang.String)} and {@link #yices_mk_num_from_string(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer yices_mk_num_from_string(Pointer ctx, Pointer n);
	/**
	 * \brief Return an expression representing the number provided in ASCII format.<br>
	 * Original signature : <code>yices_expr yices_mk_num_from_string(yices_context, const char*)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:659</i>
	 */
	Pointer yices_mk_num_from_string(Pointer ctx, String n);
	/**
	 * \brief Return an expression representing <tt>args[0] + ... + args[n-1]</tt>.<br>
	 * \c n is the number of elements in the array \c args.<br>
	 * \warning \c n must be greater than zero.<br>
	 * Original signature : <code>yices_expr yices_mk_sum(yices_context, yices_expr[], unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:666</i>
	 */
	Pointer yices_mk_sum(Pointer ctx, Pointer args, int n);
	/**
	 * \brief Return an expression representing <tt>args[0] - ... - args[n-1]</tt>.<br>
	 * \c n is the number of elements in the array \c args.<br>
	 * \warning \c n must be greater than zero.<br>
	 * Original signature : <code>yices_expr yices_mk_sub(yices_context, yices_expr[], unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:673</i>
	 */
	Pointer yices_mk_sub(Pointer ctx, Pointer args, int n);
	/**
	 * \brief Return an expression representing <tt>args[0] * ... * args[n-1]</tt>.<br>
	 * \c n is the number of elements in the array \c args.<br>
	 * \warning \c n must be greater than zero.<br>
	 * Original signature : <code>yices_expr yices_mk_mul(yices_context, yices_expr[], unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:680</i>
	 */
	Pointer yices_mk_mul(Pointer ctx, Pointer args, int n);
	/**
	 * \brief Return an expression representing <tt>a1 < a2</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_lt(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:685</i>
	 */
	Pointer yices_mk_lt(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Return an expression representing <tt>a1 <= a2</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_le(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:690</i>
	 */
	Pointer yices_mk_le(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Return an expression representing <tt>a1 > a2</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_gt(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:695</i>
	 */
	Pointer yices_mk_gt(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Return an expression representing <tt>a1 >= a2</tt>.<br>
	 * Original signature : <code>yices_expr yices_mk_ge(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:700</i>
	 */
	Pointer yices_mk_ge(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Create a bit vector constant of \c size bits and of the given \c value<br>
	 * \c size must be positive<br>
	 * Original signature : <code>yices_expr yices_mk_bv_constant(yices_context, unsigned, unsigned long)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:706</i>
	 */
	Pointer yices_mk_bv_constant(Pointer ctx, int size, NativeLong value);
	/**
	 * \brief Create a bit vector constant from an array<br>
	 * \c size must be positive<br>
	 * \c bv must be an array of \c size elements<br>
	 * bit \c i of the bitvector is set to 0 if <tt>bv[i] = 0</tt> and to 1 if <tt>bv[i] != 0</tt><br>
	 * Original signature : <code>yices_expr yices_mk_bv_constant_from_array(yices_context, unsigned, int[])</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:714</i><br>
	 * @deprecated use the safer methods {@link #yices_mk_bv_constant_from_array(com.sun.jna.Pointer, int, java.nio.IntBuffer)} and {@link #yices_mk_bv_constant_from_array(com.sun.jna.Pointer, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated 
	Pointer yices_mk_bv_constant_from_array(Pointer ctx, int size, IntByReference bv);
	/**
	 * \brief Create a bit vector constant from an array<br>
	 * \c size must be positive<br>
	 * \c bv must be an array of \c size elements<br>
	 * bit \c i of the bitvector is set to 0 if <tt>bv[i] = 0</tt> and to 1 if <tt>bv[i] != 0</tt><br>
	 * Original signature : <code>yices_expr yices_mk_bv_constant_from_array(yices_context, unsigned, int[])</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:714</i>
	 */
	Pointer yices_mk_bv_constant_from_array(Pointer ctx, int size, IntBuffer bv);
	/**
	 * \brief Bitvector addition<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_add(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:720</i>
	 */
	Pointer yices_mk_bv_add(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Bitvector subtraction<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_sub(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:726</i>
	 */
	Pointer yices_mk_bv_sub(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Bitvector multiplication<br>
	 * \c a1 and \c a2 must be bitvector expression of same size. The result is<br>
	 * truncated to that size too. E.g., multiplication of two 8-bit vectors<br>
	 * gives an 8-bit result.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_mul(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:734</i>
	 */
	Pointer yices_mk_bv_mul(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Bitvector opposite<br>
	 * \c a1 must be bitvector expression. The result is (- \c a1).<br>
	 * Original signature : <code>yices_expr yices_mk_bv_minus(yices_context, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:740</i>
	 */
	Pointer yices_mk_bv_minus(Pointer ctx, Pointer a1);
	/**
	 * \brief Bitvector concatenation <br>
	 * \c a1 and \c a2 must be two bitvector expressions. \c a1 is the left <br>
	 * part of the result and \c a2 the right part. <br>
	 * Assuming \c a1 and \c a2 have \c n1 and \c n2 bits, respectively,<br>
	 * then the result is a bitvector \c concat of size \c n1 + \c n2.  Bit<br>
	 * 0 of \c concat is bit 0 of \c a2 and bit \c n2 of \c concat is bit 0<br>
	 * of \c a1.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_concat(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:751</i>
	 */
	Pointer yices_mk_bv_concat(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Bitwise and<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_and(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:757</i>
	 */
	Pointer yices_mk_bv_and(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Bitwise or<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_or(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:763</i>
	 */
	Pointer yices_mk_bv_or(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Bitwise exclusive or<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_xor(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:769</i>
	 */
	Pointer yices_mk_bv_xor(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Bitwise negation<br>
	 * Original signature : <code>yices_expr yices_mk_bv_not(yices_context, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:774</i>
	 */
	Pointer yices_mk_bv_not(Pointer ctx, Pointer a1);
	/**
	 * \brief Bitvector extraction<br>
	 * \c a must a bitvector expression of size \c n with \c begin < \c end < \c n.<br>
	 * The result is the subvector \c a[begin .. end]<br>
	 * Original signature : <code>yices_expr yices_mk_bv_extract(yices_context, unsigned, unsigned, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:781</i>
	 */
	Pointer yices_mk_bv_extract(Pointer ctx, int end, int begin, Pointer a);
	/**
	 * \brief Sign extension<br>
	 * Append \c n times the most-significant bit of \a to the left of \c a<br>
	 * Original signature : <code>yices_expr yices_mk_bv_sign_extend(yices_context, yices_expr, unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:787</i>
	 */
	Pointer yices_mk_bv_sign_extend(Pointer ctx, Pointer a, int n);
	/**
	 * \brief Left shift by \c n bits, padding with zeros<br>
	 * Original signature : <code>yices_expr yices_mk_bv_shift_left0(yices_context, yices_expr, unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:792</i>
	 */
	Pointer yices_mk_bv_shift_left0(Pointer ctx, Pointer a, int n);
	/**
	 * \brief Left shift by \c n bits, padding with ones<br>
	 * Original signature : <code>yices_expr yices_mk_bv_shift_left1(yices_context, yices_expr, unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:797</i>
	 */
	Pointer yices_mk_bv_shift_left1(Pointer ctx, Pointer a, int n);
	/**
	 * \brief Right shift by \c n bits, padding with zeros<br>
	 * Original signature : <code>yices_expr yices_mk_bv_shift_right0(yices_context, yices_expr, unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:802</i>
	 */
	Pointer yices_mk_bv_shift_right0(Pointer ctx, Pointer a, int n);
	/**
	 * \brief Right shift by \c n bits, padding with ones<br>
	 * Original signature : <code>yices_expr yices_mk_bv_shift_right1(yices_context, yices_expr, unsigned)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:807</i>
	 */
	Pointer yices_mk_bv_shift_right1(Pointer ctx, Pointer a, int n);
	/**
	 * \brief Unsigned comparison: (\c a1 < \c a2)<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_lt(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:813</i>
	 */
	Pointer yices_mk_bv_lt(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Unsigned comparison: (\c a1 <= \c a2)<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_le(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:819</i>
	 */
	Pointer yices_mk_bv_le(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Unsigned comparison: (\c a1 > \c a2)<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_gt(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:825</i>
	 */
	Pointer yices_mk_bv_gt(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Unsigned comparison: (\c a1 >= \c a2)<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_ge(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:831</i>
	 */
	Pointer yices_mk_bv_ge(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Signed comparison: (\c a1 < \c a2)<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_slt(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:837</i>
	 */
	Pointer yices_mk_bv_slt(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Signed comparison: (\c a1 <= \c a2)<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_sle(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:843</i>
	 */
	Pointer yices_mk_bv_sle(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Signed comparison: (\c a1 > \c a2)<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_sgt(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:849</i>
	 */
	Pointer yices_mk_bv_sgt(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Signed comparison: (\c a1 >= \c a2)<br>
	 * \c a1 and \c a2 must be bitvector expression of same size.<br>
	 * Original signature : <code>yices_expr yices_mk_bv_sge(yices_context, yices_expr, yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:855</i>
	 */
	Pointer yices_mk_bv_sge(Pointer ctx, Pointer a1, Pointer a2);
	/**
	 * \brief Pretty print the given expression in the standard output.<br>
	 * Original signature : <code>void yices_pp_expr(yices_expr)</code><br>
	 * <i>native declaration : yices-1.0.34/include/yices_c.h:860</i>
	 */
	void yices_pp_expr(Pointer e);
}
