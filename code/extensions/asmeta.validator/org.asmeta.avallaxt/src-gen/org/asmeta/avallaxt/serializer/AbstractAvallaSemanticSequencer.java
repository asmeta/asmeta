/*
 * generated by Xtext 2.36.0
 */
package org.asmeta.avallaxt.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.asmeta.avallaxt.avalla.AvallaPackage;
import org.asmeta.avallaxt.avalla.Block;
import org.asmeta.avallaxt.avalla.Check;
import org.asmeta.avallaxt.avalla.Choose;
import org.asmeta.avallaxt.avalla.Exec;
import org.asmeta.avallaxt.avalla.ExecBlock;
import org.asmeta.avallaxt.avalla.Invariant;
import org.asmeta.avallaxt.avalla.Scenario;
import org.asmeta.avallaxt.avalla.Step;
import org.asmeta.avallaxt.avalla.StepUntil;
import org.asmeta.avallaxt.services.AvallaGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractAvallaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AvallaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AvallaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AvallaPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case AvallaPackage.CHECK:
				sequence_Check(context, (Check) semanticObject); 
				return; 
			case AvallaPackage.CHOOSE:
				sequence_Choose(context, (Choose) semanticObject); 
				return; 
			case AvallaPackage.EXEC:
				sequence_Exec(context, (Exec) semanticObject); 
				return; 
			case AvallaPackage.EXEC_BLOCK:
				sequence_ExecBlock(context, (ExecBlock) semanticObject); 
				return; 
			case AvallaPackage.INVARIANT:
				sequence_Invariant(context, (Invariant) semanticObject); 
				return; 
			case AvallaPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case AvallaPackage.SET:
				sequence_Set(context, (org.asmeta.avallaxt.avalla.Set) semanticObject); 
				return; 
			case AvallaPackage.STEP:
				sequence_Command(context, (Step) semanticObject); 
				return; 
			case AvallaPackage.STEP_UNTIL:
				sequence_StepUntil(context, (StepUntil) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (name=GOOD_CHARS_NO_COLON elements+=Element*)
	 * </pre>
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Check
	 *     Command returns Check
	 *     Check returns Check
	 *
	 * Constraint:
	 *     expression=sentence
	 * </pre>
	 */
	protected void sequence_Check(ISerializationContext context, Check semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.CHECK__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.CHECK__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckAccess().getExpressionSentenceParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Choose
	 *     Command returns Choose
	 *     Choose returns Choose
	 *
	 * Constraint:
	 *     (var=LOCAL_VARIABLE value=sentence)
	 * </pre>
	 */
	protected void sequence_Choose(ISerializationContext context, Choose semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.CHOOSE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.CHOOSE__VAR));
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.CHOOSE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.CHOOSE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChooseAccess().getVarLOCAL_VARIABLETerminalRuleCall_1_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getChooseAccess().getValueSentenceParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Step
	 *     Command returns Step
	 *
	 * Constraint:
	 *     {Step}
	 * </pre>
	 */
	protected void sequence_Command(ISerializationContext context, Step semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns ExecBlock
	 *     Command returns ExecBlock
	 *     ExecBlock returns ExecBlock
	 *
	 * Constraint:
	 *     (scenario=GOOD_CHARS_NO_COLON? block=GOOD_CHARS_NO_COLON)
	 * </pre>
	 */
	protected void sequence_ExecBlock(ISerializationContext context, ExecBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Exec
	 *     Command returns Exec
	 *     Exec returns Exec
	 *
	 * Constraint:
	 *     rule=sentencePlusAssignAndColon
	 * </pre>
	 */
	protected void sequence_Exec(ISerializationContext context, Exec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.EXEC__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.EXEC__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExecAccess().getRuleSentencePlusAssignAndColonParserRuleCall_1_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Invariant returns Invariant
	 *
	 * Constraint:
	 *     (name=GOOD_CHARS_NO_COLON expression=sentence)
	 * </pre>
	 */
	protected void sequence_Invariant(ISerializationContext context, Invariant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.INVARIANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.INVARIANT__NAME));
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.INVARIANT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.INVARIANT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantAccess().getNameGOOD_CHARS_NO_COLONTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInvariantAccess().getExpressionSentenceParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     (name=GOOD_CHARS_NO_COLON spec=Path invariants+=Invariant* elements+=Element*)
	 * </pre>
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Set
	 *     Command returns Set
	 *     Set returns Set
	 *
	 * Constraint:
	 *     (location=sentence value=sentence)
	 * </pre>
	 */
	protected void sequence_Set(ISerializationContext context, org.asmeta.avallaxt.avalla.Set semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.SET__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.SET__LOCATION));
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.SET__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.SET__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetAccess().getLocationSentenceParserRuleCall_1_0(), semanticObject.getLocation());
		feeder.accept(grammarAccess.getSetAccess().getValueSentenceParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns StepUntil
	 *     Command returns StepUntil
	 *     StepUntil returns StepUntil
	 *
	 * Constraint:
	 *     expression=sentence
	 * </pre>
	 */
	protected void sequence_StepUntil(ISerializationContext context, StepUntil semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AvallaPackage.Literals.STEP_UNTIL__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AvallaPackage.Literals.STEP_UNTIL__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStepUntilAccess().getExpressionSentenceParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
}
