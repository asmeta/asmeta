/*
 * generated by Xtext 2.16.0
 */
package org.asmeta.avallaxt.validation

import asmeta.AsmCollection
import org.asmeta.avallaxt.AvallaStandaloneSetup
import org.asmeta.avallaxt.avalla.AvallaPackage
import org.asmeta.avallaxt.avalla.Block
import org.asmeta.avallaxt.avalla.Pick
import org.asmeta.avallaxt.avalla.Element
import org.asmeta.avallaxt.avalla.ExecBlock
import org.asmeta.avallaxt.avalla.Scenario
import org.asmeta.avallaxt.avalla.Set
import asmeta.definitions.ControlledFunction
import asmeta.definitions.Function
import asmeta.definitions.MonitoredFunction
import asmeta.definitions.SharedFunction
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import java.util.ArrayList
import java.util.HashSet
import java.util.List
import org.asmeta.parser.ASMParser
import org.asmeta.parser.ParseException
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.ResourceSet

import static java.util.stream.Collectors.toList
import java.util.Map
import asmeta.transitionrules.basictransitionrules.ChooseRule

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AvallaValidator extends AbstractAvallaValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					AvallaPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	
	AsmCollection asmCollection
	List<String> monFunNames
	List<String> controlledFunNames
	List<String> sharedFunNames
	Map<ChooseRule, String> chooseRules

	@org.eclipse.xtext.validation.Check
	def checkLoadASMexists(Scenario scenario) {
		//
		var specName = scenario.spec
		if (specName.startsWith("\"")) {
			if (!specName.endsWith("\"")){
				error('should end with the quote as well',AvallaPackage.Literals.SCENARIO__SPEC)
				return;				
			}  
			specName = specName.substring(1,specName.length() - 1)			
		}
		if (! specName.endsWith(ASMParser.ASM_EXTENSION)) {
			error('Asm spec should end with asm', AvallaPackage.Literals.SCENARIO__SPEC)
			return;
		}
		// get the path for the 
		val asmPath = ScenarioUtility.getAsmPath(scenario)
		if (! (Files.exists(asmPath) && Files.isRegularFile(asmPath))) {
			error('File ' + scenario.spec + " does not exist as " + asmPath, AvallaPackage.Literals.SCENARIO__SPEC)
			return;
		}
		// parse the ASM if requested ? - now it pareses every time - one could check if only it has been modified
		try {
			setAsmCollection(ASMParser.setUpReadAsm(asmPath.toFile))
		} catch (ParseException pe) {
			warning('Error in parsing asm in ' + asmPath, AvallaPackage.Literals.SCENARIO__SPEC)
		} catch (org.asmeta.parser.ImportNotFoundException infe) {
			warning('Error in parsing asm in ' + asmPath + " cause:" + infe.message,
				AvallaPackage.Literals.SCENARIO__SPEC)
		} catch (Throwable t) {
			error('error ' + t.message, AvallaPackage.Literals.SCENARIO__SPEC)
		}
	}

	// read the asm and imports all the functions for validation
	def setAsmCollection(AsmCollection collection) {
		asmCollection = collection
		// get all the functions not only from the main - also those imported
		// TODO recursive????		
		val HashSet<Function> functions = new HashSet<Function>
		asmCollection.forEach[asm | functions.addAll(asm.headerSection.signature.function)];
		// get monitored 
		monFunNames = functions.stream().filter(x|x instanceof MonitoredFunction).map(y|y.name).collect(toList())
		// get controlled locations
		controlledFunNames = functions.stream().filter(x|x instanceof ControlledFunction).map(y|y.name).collect(toList())
		// get shared
		sharedFunNames = functions.stream().filter(x|x instanceof SharedFunction).map(y|y.name).collect(toList())
		// get choose rules
		//TODO for now it takes the choose rules only in the main ASM, in the future it can be also in an imported
		chooseRules = AsmCollectionUtility.getChooseRules(asmCollection)
	}

	@org.eclipse.xtext.validation.Check
	def checkSetLocation(Set set) {
		// if load has been unsuccessful
		if(asmCollection === null) return
		// check that the location exists
		// search in the main
		val locationName = if (set.location.contains("("))
				set.location.substring(0, set.location.indexOf("("))
			else
				set.location;
		if (! monFunNames.contains(locationName) && ! sharedFunNames.contains(locationName)) {
			if (! controlledFunNames.contains(locationName)) {
				error('location ' + locationName + " does not exist", AvallaPackage.Literals.SET__LOCATION)
			} else {
				error('location ' + locationName + " is controlled cannot be set", AvallaPackage.Literals.SET__LOCATION)
			}
		}
	}

	@org.eclipse.xtext.validation.Check
	def checkBlock(Block b) {
		val s = getScenario(b)
		val List<String> names = new ArrayList
		val List<String> duplicated = new ArrayList
		ScenarioUtility.addBlockNames(names, duplicated, s.elements)
		if (duplicated.contains(b.name))
			error('block ' + b.name + " declared multiple times", AvallaPackage.Literals.BLOCK__NAME)
	}
	
	@org.eclipse.xtext.validation.Check
	def checkPick(Pick pick) {
		var String errorMessage = ScenarioUtility.checkPickRule(pick, asmCollection.main)
		if (errorMessage !== null)
			error(errorMessage, AvallaPackage.Literals.PICK__RULE)
		else
			errorMessage = ScenarioUtility.checkPickVariable(pick, chooseRules)
			if (errorMessage !== null)
				error(errorMessage, AvallaPackage.Literals.PICK__VAR)
	}
	

	// get the scenario of the block or command in general
	def Scenario getScenario(Element b) {
		if (b.eContainer instanceof Scenario)
			return b.eContainer as Scenario
		else
			return getScenario(b.eContainer as Element)
	}

	@org.eclipse.xtext.validation.Check
	def checkExecBlock(ExecBlock eb) {
		val scenario = eb.scenario
		// if null, search in this scenario
		if (scenario === null) {
			// check the current block names
			// get the parent of this exec block
			val s = getScenario(eb)
			val blockNames = ScenarioUtility.getBlockNames(s)
			if (!blockNames.contains(eb.block))
				error('block ' + eb.block + " does not exist in this scenario",
					AvallaPackage.Literals.EXEC_BLOCK__BLOCK)
		} else {
			// check in another scenario
			// check that the file exists
			// get the current path
			val scenarioPath = ScenarioUtility.getBaseDir(getScenario(eb)) +  File.separator + scenario + ".avalla"
			//println(scenarioPath)
			if (!Files.exists(Paths.get(scenarioPath)))
				error('scenario ' + scenario + " does not exist", AvallaPackage.Literals.EXEC_BLOCK__SCENARIO)
			else {
				// open and parse the file
				val injector = new AvallaStandaloneSetup().createInjectorAndDoEMFRegistration();
				val rs = injector.getInstance(typeof(ResourceSet));
				println(scenarioPath)
				val resource = rs.getResource(URI.createFileURI(scenarioPath), true);
				resource.load(null);
				val sc = resource.getContents().get(0) as Scenario;
				// get the blocks in it
				if (!ScenarioUtility.getBlockNames(sc).contains(eb.block))
					error('scenario ' + scenario + " does not contain block " + eb.block,
						AvallaPackage.Literals.EXEC_BLOCK__BLOCK)
			}
		}
	}
}

