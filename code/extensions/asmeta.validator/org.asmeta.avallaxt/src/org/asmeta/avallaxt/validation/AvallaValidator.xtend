/*
 * generated by Xtext 2.16.0
 */
package org.asmeta.avallaxt.validation

import asmeta.AsmCollection
import asmeta.definitions.Function;
import java.util.List
import org.asmeta.avallaxt.avalla.Scenario
import org.asmeta.avallaxt.avalla.Check
import org.asmeta.avallaxt.avalla.AvallaPackage
import org.asmeta.avallaxt.avalla.ExecBlock
import org.asmeta.avallaxt.avalla.Element
import org.asmeta.avallaxt.avalla.Set
import java.nio.file.Paths
import java.nio.file.Files
import org.asmeta.parser.ASMParser
import org.asmeta.parser.ParseException
import asmeta.definitions.MonitoredFunction
import asmeta.definitions.SharedFunction
import java.io.File
import asmeta.definitions.ControlledFunction
import org.asmeta.avallaxt.avalla.Block
import java.util.ArrayList
import org.eclipse.emf.ecore.resource.ResourceSet
import org.asmeta.avallaxt.AvallaStandaloneSetup
import org.eclipse.emf.common.util.URI
import static java.util.stream.Collectors.toList
import org.eclipse.emf.common.util.EList
import java.util.HashSet

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AvallaValidator extends AbstractAvallaValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					AvallaPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	
	AsmCollection asmCollection
	List<String> monFunNames
	List<String> controlledFunNames
	List<String> sharedFunNames

	@org.eclipse.xtext.validation.Check
	def checkLoadASMexists(Scenario scenario) {
		//
		if (scenario.spec.startsWith("\"")) {
			// TODO
			return
		}
		if (! scenario.spec.endsWith(ASMParser.ASM_EXTENSION)) {
			error('Asm spec should end with asm', AvallaPackage.Literals.SCENARIO__SPEC)
			return;
		}
		// get the path for the 
		val asmPath = ScenarioUtility.getAsmPath(scenario)
		if (! (Files.exists(asmPath) && Files.isRegularFile(asmPath))) {
			error('File ' + scenario.spec + " does not exist as " + asmPath, AvallaPackage.Literals.SCENARIO__SPEC)
			return;
		}
		// parse the ASM if requested ? - now it pareses every time - one could check if only it has been modified
		try {
			setAsmCollection(ASMParser.setUpReadAsm(asmPath.toFile))
		} catch (ParseException pe) {
			warning('Error in parsing asm in ' + asmPath, AvallaPackage.Literals.SCENARIO__SPEC)
		} catch (org.asmeta.parser.ImportNotFoundException infe) {
			warning('Error in parsing asm in ' + asmPath + " cause:" + infe.message,
				AvallaPackage.Literals.SCENARIO__SPEC)
		} catch (Throwable t) {
			error('error ' + t.message, AvallaPackage.Literals.SCENARIO__SPEC)
		}
	}

	// read the asm and imports all the functions for validation
	def setAsmCollection(AsmCollection collection) {
		asmCollection = collection
		// get all the functions not only from the main - also those imported
		// TODO recursive????		
		val HashSet<Function> functions = new HashSet<Function>
		asmCollection.forEach[asm | functions.addAll(asm.headerSection.signature.function)];
		// get monitored 
		monFunNames = functions.stream().filter(x|x instanceof MonitoredFunction).map(y|y.name).collect(toList())
		// get controlled locations
		controlledFunNames = functions.stream().filter(x|x instanceof ControlledFunction).map(y|y.name).collect(toList())
		// get shared
		sharedFunNames = functions.stream().filter(x|x instanceof SharedFunction).map(y|y.name).collect(toList())
	}

	@org.eclipse.xtext.validation.Check
	def checkSetLocation(Set set) {
		// if load has been unsuccessful
		if(asmCollection === null) return
		// check that the location exists
		// search in the main
		val locationName = if (set.location.contains("("))
				set.location.substring(0, set.location.indexOf("("))
			else
				set.location;
		if (! monFunNames.contains(locationName) && ! sharedFunNames.contains(locationName)) {
			if (! controlledFunNames.contains(locationName)) {
				error('location ' + locationName + " does not exist", AvallaPackage.Literals.SET__LOCATION)
			} else {
				error('location ' + locationName + " is controlled cannot be set", AvallaPackage.Literals.SET__LOCATION)
			}
		}
	}

	@org.eclipse.xtext.validation.Check
	def checkBlock(Block b) {
		val s = getScenario(b)
		val List<String> names = new ArrayList
		val List<String> duplicated = new ArrayList
		ScenarioUtility.addBlockNames(names, duplicated, s.elements)
		if (duplicated.contains(b.name))
			error('block ' + b.name + " declared multiple times", AvallaPackage.Literals.BLOCK__NAME)
	}

	// get the scenario of the block or command in general
	def Scenario getScenario(Element b) {
		if (b.eContainer instanceof Scenario)
			return b.eContainer as Scenario
		else
			return getScenario(b.eContainer as Element)
	}

	@org.eclipse.xtext.validation.Check
	def checkExecBlock(ExecBlock eb) {
		val scenario = eb.scenario
		// if null, search in this scenario
		if (scenario === null) {
			// check the current block names
			// get the parent of this exec block
			val s = getScenario(eb)
			val blockNames = ScenarioUtility.getBlockNames(s)
			if (!blockNames.contains(eb.block))
				error('block ' + eb.block + " does not exist in this scenario",
					AvallaPackage.Literals.EXEC_BLOCK__BLOCK)
		} else {
			// check in another scenario
			// check that the file exists
			// get the current path
			val scenarioPath = ScenarioUtility.getBaseDir(getScenario(eb)) +  File.separator + scenario + ".avalla"
			//println(scenarioPath)
			if (!Files.exists(Paths.get(scenarioPath)))
				error('scenario ' + scenario + " does not exist", AvallaPackage.Literals.EXEC_BLOCK__SCENARIO)
			else {
				// open and parse the file
				val injector = new AvallaStandaloneSetup().createInjectorAndDoEMFRegistration();
				val rs = injector.getInstance(typeof(ResourceSet));
				println(scenarioPath)
				val resource = rs.getResource(URI.createFileURI(scenarioPath), true);
				resource.load(null);
				val sc = resource.getContents().get(0) as Scenario;
				// get the blocks in it
				if (!ScenarioUtility.getBlockNames(sc).contains(eb.block))
					error('scenario ' + scenario + " does not contain block " + eb.block,
						AvallaPackage.Literals.EXEC_BLOCK__BLOCK)
			}
		}
	}
}

