/*
* version 08/09/2022
*  08/09/2022 - added in problems some explanation 
*  05/27/2023 - added other explainstions AG
*/
options
{
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false; // "false" istanzia un nuovo parser
}

PARSER_BEGIN(ASMParser)
package org.asmeta.parser;
//import org.apache.log4j.PropertyConfigurator;
//Import JMIs
import asmeta.*;
import asmeta.definitions.*;
import asmeta.structure.*;
import asmeta.terms.*;
import asmeta.transitionrules.*;
import asmeta.definitions.domains.*;
import asmeta.terms.basicterms.*;
import asmeta.terms.furtherterms.*;
import asmeta.transitionrules.basictransitionrules.*;
import asmeta.transitionrules.derivedtransitionrules.*;
import asmeta.transitionrules.turbotransitionrules.*;
import java.io.FileOutputStream;
import java.io.File;
import java.util.*;
import java.nio.charset.Charset;

public class ASMParser
{

  // asm extension including the . 
  public static final String ASM_EXTENSION = ".asm";

  private String filename; // file name without extension, needed to check that the name of the machine is the same

  private String asmDirLib; // where to find libraries

  private Header header; //the header section of the Asm

  //the declared domains. It associates domain names to the corresponding object.Its tuples are of kind(String,Domain)
  private HashMap < String, Domain > declared_Dom = new HashMap < String, Domain > ();

  // the declared functions: those in the signature and those imported
  private HashMap < String, List < Function > > declared_Func = new HashMap < String, List < Function > > (); //the declared functions of the ASM. It associates function names to the list of functions with that name (a function can be overloaded).Its tuples are of kind(String,List<Function>)

  //the ruleDeclarations of the ASM. It associates rule names to the corresponding object.Its tuples are of kind(String,RuleDeclaration)
  private HashMap < String, List < RuleDeclaration > > declared_Rules = new HashMap < String, List < RuleDeclaration > > ();

  // it keeps memory of the already imported ASMs, to avoid importing of already imported ASM
  // keep static since it is shared among parser instances
  private static HashMap < String, Asm > alreadyImported;

  // real Any Domain
  private static final String anyDomainAnyName = "Any";

  //the structured domains created during parsing. It associates domain names to the corresponding object. Its tuples are of kind(String,StructuredTD)
  // NO LONGER USED
  //private static HashMap<String,Domain> predefined_Dom = new HashMap<String,Domain>();    //the domains created during parsing. It associates domain names to the corresponding object. Its tuples are of kind(String,TypeDomain)
  private Map < String, EnumTd > enumElem = new HashMap<>(); //It associates enumeration element names to their enumeration domain. Its tuples are of kind(String,EnumTD)

  //These hashMap associate the hashcode of the element name to the element name itself. Its tuples are of kind (Integer,String)
 
  private HashMap<Integer, String> exported_Rules;

  private HashMap<Integer, String> exported_Func;

  private HashMap<Integer, String> exported_Dom;

  private boolean exportAll; //the value "true" indicates all functions and rule are exported

  // forse si puo' eliminare - non serve piu' AG
  // private HashMap programs = new HashMap(); //the hashmap associating names of rule declarations (programs for agents) to the corresponding agent. Its tuples are of kind (Sting,AgentInitialization)

  // these are no longer static because if it reads another (imported ASM)
  // this information must be shared. are shared by passing the argument to the new parser
  // are friendly: must be set before parsing ???
  private AsmetaFactory asmPk;

  private DefinitionsFactory defPack;

  private TermsFactory termsPack;

  private TransitionRulesFactory rulesPack;

  private StructureFactory structurePack;

  private asmeta.definitions.domains.DomainsFactory domainsFactory;

  /** this is set by the setUpReadExport to the parser used to read the first spec*/
  public static ASMParser asmParser;

  // only one logger: DANGER information is mixed
  // errors in imported lib appears errors in pmain file
  // TO BE FIXED
  private static ParserResultLogger Logger = new ParserResultLogger();

  public static ParserResultLogger getResultLogger()
  {
    return Logger;
  }

  /**
	 * It returns the collection of ASM
	 * create the EMF instances
	 * IT IS STATIC BECAUSE may use several parsers (included files and so on).
	 */
  public static AsmCollection setUpReadAsm(File f) throws Exception
  {
    Logger.resetForParsing(f);
    assert (f.exists() && f.isFile());
    assert (f.getName().endsWith(ASM_EXTENSION));
    Logger.logInfo("parsing file " + f.getCanonicalPath());
    // reset the domains
    DomainsFactory.eINSTANCE.resetDomains();
    Utility.reset();
    // BUILD THE MODEL
    // init all imported so far
    alreadyImported = new HashMap<String,Asm>();
    // get the asmetafactory instance
    AsmetaFactory mainpackage = AsmetaFactory.eINSTANCE;
    // builds the parser
    try{
    	asmParser = new ASMParser(f, mainpackage);
    	// parses  the main Asm
    	Optional<asmeta.structure.Asm> asm = asmParser.Asm();
    	// build the collection of ASM
    	AsmCollection allAsms = new AsmCollection(alreadyImported.values());
    	// add this one as first one
    	if (asm.isPresent()) {
      		allAsms.addMain(asm.get());
      		Logger.logInfo("file successfully parsed for asm " + asm.get().getName());
    	} else {
      		Logger.logInfo("file successfully parsed but empty");
    	}
    	return allAsms;
    } catch(org.asmeta.parser.ParseException pe) {
        String message = pe.getMessage();
        // get the token
        Token tk = asmParser.token;
        // add token message and re throw
        message = message +  (tk !=null? " Line: " + tk.beginLine + " column: " + tk.beginColumn : "");
        // there is also        
      	throw new ParseException(message);   	
    } finally{
    	asmParser.jj_input_stream.inputStream.close();
    }    
  }

  /* The input file must have the same name of the ASM spec.
     * A file is needed because we need o set the path where to search
     * for libraries.
     * asmPack is the topmost level package of the metamodel.
     */
  private ASMParser(File f, AsmetaFactory asmPack) throws Exception
  {
    // ho un problema con la nuova implementazione di javacc e JavaCharStream
    // usando la versione vecchia e il plugin di eclipse funziona
    // versione per ph-javacc-maven-plugin
    // this (new java.io.FileInputStream(f),Charset.forName("UTF-8"));
    // versione per javacc-maven-plugin
    this (new java.io.FileInputStream(f),"UTF-8");
    //Check the file name
    if (!f.exists() || !f.isFile())
    {
      Logger.fatal("Error:  " + f.toString() + " is not a file.");
      throw new java.io.FileNotFoundException();
    }
    //DUPLICATED CODE (see main() in MainParser)
    //if (!f.getName().endsWith(asmExtension)) {
    //	Logger.fatal("Error:  " + f.toString() + " is not an asm file.");
    //
    //	throw new Exception("Asm files must have "+ asmExtension +" extension");
    //}
    // get the filename without ".asm" extension
    filename = f.getName().substring(0, f.getName().length() - 4);
    // the library is relative to this file
    asmDirLib = f.getParent();
    // initialize other packages
    // Get references to package
    asmPk = asmPack;
    defPack = asmPk.getDefinitions();
    termsPack = asmPk.getTerms();
    rulesPack = asmPk.getTransitionRules();
    structurePack = asmPk.getStructure();
    domainsFactory = defPack.getDomains();
  }
  /*************
    Attenzione il parser continua ad avere metodi come
    public ASMParser(java.io.InputStream stream) {}
    ...
    che non inizializzano correttamente il parser (ad esempio fileSpec)
    **************/
}

PARSER_END(ASMParser)

/***************************************************************
-------------------------   TOKENS   ---------------------------
***************************************************************/
< DEFAULT, GENERIC_ID, MODULE_ID >
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) > // skip line-comments
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )*
    "/" > // skip  block-comments
}

/* RESERVED WORDS */
TOKEN :
{
  //for Asm structure
  < ASM : "asm" > : GENERIC_ID
| < MODULE : "module" > : GENERIC_ID
| < ASYNCR : "asyncr" >
| < IMPORT : "import" > : MODULE_ID
| < EXPORT : "export" >
| < SIGNATURE : "signature" >
| < INIT : "init" > : GENERIC_ID
| < Default : "default" >
| < AGENT : "agent" >
| < INVARIANT : "invariant" >
  //PA 19/05/2014 in order to add the CTLSPEC, LTLSPEC, FAIRNESS, JUSTICE, COMPASSION, and INVAR keywords: START
  //AG 13/06/24 also lowercase TODO: add a test case
  // AG also those below
| < CTLSPEC : "CTLSPEC" | "ctlspec">
//  AG 13/06/24 non viene usato 
//| < NAME : "NAME" > 
| < LTLSPEC : "LTLSPEC" | "ltlspec">
| < JUSTICE : "JUSTICE" | "justice" > //A justice constraint consists of a formula f, which is assumed to be true infinitely often in all the fair paths
| < FAIRNESS : "FAIRNESS"| "fairness" > //It indicates a justice constraint as well (in NuSMV it has been kept for backward compatibility)
| < COMPASSION : "COMPASSION"| "compassion"> //. A compassion constraint consists of a pair of formulas (p,q); if property p is true infinitely often in a fair path, then also formula q has to be true infinitely often in the fair path
| < INVAR : "INVAR" | "invar">
  //PA 19/05/2014 in order to add the CTLSPEC, LTLSPEC, FAIRNESS, JUSTICE, COMPASSION, and INVAR keywords: END
| < OVER : "over" >
| < DEFINITIONS : "definitions" >
  //for functions
| < FUNCTION : "function" >
| < STATIC : "static" >
| < DYNAMIC : "dynamic" >
| < DERIVED : "derived" >
| < MONITORED : "monitored" >
| < CONTROLLED : "controlled" >
| < SHARED : "shared" >
| < OUT : "out" >
  //for domains
| < DOMAIN : "domain" >
| < ANYDOMAIN : "anydomain" >
| < BASIC : "basic" >
| < ABSTRACT : "abstract" >
| < ENUM : "enum" >
| < SUBSETOF : "subsetof" >
  //for Structured Type Domain
| < PROD : "Prod" >
| < SEQ : "Seq" >
| < POWERSET : "Powerset" >
| < BAG : "Bag" >
| < MAP : "Map" >
| < RULEDOM : "Rule" >
  //for constant term
| < TRUE : "true" >
| < FALSE : "false" >
| < UNDEF : "undef" >
| < IM_PART : "i" >
  //for extended term
| < IF : "if" >
| < THEN : "then" >
| < ELSE : "else" >
| < ENDIF : "endif" >
| < SWITCH : "switch" >
| < END_SWITCH : "endswitch" >
| < CASE : "case" >
| < OTHERWISE : "otherwise" >
| < ENDCASE : "endcase" >
| < LET : "let" >
| < ENDLET : "endlet" >
| < EXIST : "exist" >
| < UNIQUE : "unique" >
| < WITH : "with" >
| < FORALL : "forall" >
  //for rules
| < Skip : "skip" >
| < RULE : "rule" >
| < MACRO : "macro" >
| < TURBO : "turbo" >
| < MAIN : "main" >
| < PAR : "par" >
| < ENDPAR : "endpar" >
| < CHOOSE : "choose" >
| < DO : "do" >
| < IFNONE : "ifnone" >
| < EXTEND : "extend" >
| < seq : "seq" > //SEQ already defined for the sequence domain
| < ENDSEQ : "endseq" >
| < ITERATE : "iterate" >
| < ENDITERATE : "enditerate" >
| < LOCAL : "local" >
| < TRY : "try" >
| < CATCH : "catch" >
| < WHILE : "while" >
| < WHILEREC : "whilerec" >
| < IN : "in" > //IN for terms and rules
  /* INFIX OPERATORS */
| < EQ : "=" >
| < LT : "<" >
| < LE : "<=" >
| < GT : ">" >
| < GE : ">=" >
| < NEQ : "!=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULT : "*" >
| < DIV : "/" >
| < PWR : "^" >
  // non posso introdurre questi token altrimenti non posso dichiararli come
  // ID_FUNCTION
  //     |  <MOD    : "mod"   >
  //     |  <OR    : "or"   >
  //     |  <XOR    : "xor"   >
  //     |  <AND    : "and"   >
  //     |  <NOT    : "not"   >
}

/* IDENTIFIERS AND NUMBERS */
TOKEN :
{
  < NUMBER : (< DIGIT >)+ > // attenzione in this way cannot write negative numbers (minus will be read as a function). idem below| < NATNUMBER : (< DIGIT >)+ "n" >
| < REAL_NUMBER : (< DIGIT >)+ "." (< DIGIT >)+ >
| < COMPLEX_NUMBER :
    (
      ([ "+", "-" ])? (< DIGIT >)+
      (
        "." (< DIGIT >)+
      )?
    )?
    ([ "+", "-" ])? "i"
    (
      (< DIGIT >)+
      (
        "." (< DIGIT >)+
      )?
    )? >
| < ID_VARIABLE :
    "$" < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < ID_ENUM :
    [ "A"-"Z" ] [ "A"-"Z" ]
    (
      "_"
    | [ "A"-"Z" ]
    | < DIGIT >
    )* >
| < ID_DOMAIN :
    [ "A"-"Z" ]
    (
      "_"
    | [ "a"-"z" ]
    | [ "A"-"Z" ]
    | < DIGIT >
    )* >
| < ID_RULE :
    "r_"
    (
      < LETTER >
    | < DIGIT >
    )+ >
| < ID_AXIOM :
    "inv_"
    (
      < LETTER >
    | < DIGIT >
    )+ >
| < ID_CTL :
    "ctlSpec_"
    (
      < LETTER >
    | < DIGIT >
    )+ >
| < ID_LTL :
    "ltlSpec_"
    (
      < LETTER >
    | < DIGIT >
    )+ >
| < ID_FUNCTION :
    ([ "a"-"z" ])
    (
      < LETTER >
    | < DIGIT >
    | "!"  // to allow locations with ! like in extend - example person!1
    )* >
| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >
| < #DIGIT : [ "0"-"9" ] >
| < CHAR_LITERAL : // from Java1.5 grammar
    "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        )
      )
    )*
    "'" >
  /*<   CHAR_LITERAL    :"'" (<LETTER>|<DIGIT>|
                         " "|"_"|"!"|"#"|"?"|"$"|"%"|"&"|"/"|"("|")"|"*"|"+"|","|"-"|"."|":"|";"|
                         "<"|">"|"="|"?"|"@"|"["|"]"|"^"|"{"|"}"|"|") "'" > */ //dovremo utilizzare i caratteri unicode
| < STRING_LITERAL : // from Java1.5 grammar
    "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        )
      )
    )*
    "\"" >
  /* <   STRING_LITERAL  :"\"" (<LETTER>|<DIGIT>|
                        " "|"_"|"!"|"#"|"?"|"$"|"%"|"&"|"'"|"/"|"("|")"|"*"|"+"|","|"-"|"."|":"|";"|
                        "<"|">"|"="|"?"|"@"|"["|"]"|"^"|"{"|"}"|"|")* "\"" > */
}

< GENERIC_ID >
TOKEN :
{
  < ID :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
  : DEFAULT
}

< MODULE_ID >
TOKEN :
{
  < MOD_ID :
    (
      // any string quoted with also double quotes in it (it is allowed) AG 10 May 2018
      // or any string in double quotes to allow spaces
      "\""
      (
        "\\" ~[ ] //any escaped character
      | //or
        ~[ "\"" ] //any non-quote character
      )*
      "\""
    | 
      // any string
      ([ "a"-"z", "A"-"Z" ] ":")? ([ "\\", "/", "a"-"z", "A"-"Z", "0"-"9", ".", "_", "-" ])+
    ) 
  >
  /*   it was : (      < LETTER >    | "."    | "/"    | "\\"    )    (      < LETTER >    | < DIGIT >    | "."    | "/"    | "\\"    | ":"    )* */
  : DEFAULT
}

/***************************************************************/
/*                         GRAMMAR START                       */
/***************************************************************/
/***** MAIN OK!
se il file � vuoto non restituisce nulla
*****/
Optional<Asm > Asm() :
{
  boolean isAsm = true; // true states an ASM, false states a module
  String name;
  boolean isAsyncr = false;
  Header h;
  Initialization i;
  Body b;
  MacroDeclaration r;
  Asm asmMachine = null;
}
{
  // il tutto � opzionale
  [
    [
      < ASYNCR >
      {
        isAsyncr = true;
      }
    ]
    (
      < ASM >
    | < MODULE >
      {
        isAsm = false;
      }
    )
    name = ID()
    {
      asmMachine = structurePack.createAsm(name, isAsyncr);
      Logger.logDebug("ASM " + name);
      if ((filename != null) && !filename.equals(name)) throw new ParseException("Error: The file name \"" + filename + "\" is not equal to the asm name \"" + name + "\".\n");
    }
    h = Header(asmMachine)
    { //set the reference
      asmMachine.setHeaderSection(h);
    }
    b = Body(asmMachine)
    { //set the reference
      asmMachine.setBodySection(b);
    }
    [
      < MAIN > r = MacroDeclaration()
      { //set the reference
        asmMachine.setMainrule(r);
        // add also the main rule to the body (to avoid dangling resources) 
        b.getRuleDeclaration().add(r);
        if (!isAsm)
        {
          Logger.logWarning("Warning: " + filename + " is a module. It cannot have a Main Rule.\n");
        }
      }
    ]
    [
      {
        Collection < Initialization > initialStateColl = asmMachine.getInitialState();
      }
      (
        i = Initialization()
        { //add it to the collection of initial states
          initialStateColl.add(i);
        }
      )*
      < Default > i = Initialization()
      { //add it to the collection of initial states
        initialStateColl.add(i);
        //set the reference to the default initial state
        asmMachine.setDefaultInitialState(i);
      }
      (
        i = Initialization()
        { //set the reference
          asmMachine.getInitialState().add(i);
        }
      )*
      {
        if (!isAsm)
        {
          Logger.logWarning("Warning: " + filename + " is a module. It cannot have any initial state.\n");
        }
      }
    ]
    { //Check OCL constraints
      if (!OCL_Checker.checkAsm(asmMachine))
      {
        Logger.logErr(OCL_Checker.getMsgErr());
        Logger.logErr("       At the Asm " + name + ".\n");
      }
      
    }
  ]  
  < EOF >
  {
    if (asmMachine== null) return Optional.empty();
    else return Optional.of(asmMachine);
  }
}

//---------------------------HEADER OK! ---------------------------//
Header Header(Asm m) :
{
  ImportClause i;
  ExportClause e;
  Signature s;
}
{
  {
    header = structurePack.createHeader();
    s = structurePack.createSignature();
    header.setSignature(s);
  }
  (
    i = ImportClause()
    {
      header.getImportClause().add(i);
    }
  )*
  [
    e = ExportClause()
    {
      header.setExportClause(e);
    }
  ]
  s = Signature(s)
  /* //Too late!
      {  header.setSignature(s);
      }*/
  {
    return header;
  }
}

/*-----------------------*/
ImportClause ImportClause() :
{
  String moduleName;
  String importedID;
  Function f;
  Domain d;
  RuleDeclaration r;
  boolean importAll = true; //the value true indicates to import all the exportClause of the other module
}
{
  < IMPORT > moduleName = MOD_ID()
  {
    // if it is escaped by double quotes, remove them
    if (moduleName.startsWith("\""))
    {
      moduleName = moduleName.substring(1, moduleName.length() - 1);
    }
    //
    ImportClause impClause = structurePack.createImportClause();
    impClause.setModuleName(moduleName);
    // it should compute again asmLibPath relatively the import ...??
    // if (asmDirLib == null) asmDirLib = ".";    Asm module_asm = null;
    String moduleFileName = null;
    try
    {
      // find the imported module file
      File moduleFile = Utility.importFile(asmDirLib, moduleName);
      moduleFileName = moduleFile.getCanonicalPath();
      Logger.logDebug("importing  " + moduleFileName);
      // take the module from the already imported modules
      module_asm = alreadyImported.get(moduleFileName);
      // check if already imported
      if (module_asm == null)
      {
        ASMParser nestedParser = new ASMParser(moduleFile, asmPk);
        Logger.logDebug("---------------------------- Beginning of " + moduleName + " parsing----------------------------");
        // to check if already imported
        if (alreadyImported.keySet().contains(moduleFileName)) {
        	Logger.logErr("circular import found in " + moduleFileName);
        	// it cannot use subclasses since the parser captures the exception and modify it (add number of line and so on)
        	throw new ParseException("circular import found in " + moduleFileName);
        }        	
        // parser started, add null for now
        alreadyImported.put(moduleFileName, null);
        module_asm = nestedParser.Asm().get();
        Logger.logDebug("---------------------------- End of " + moduleName + " parsing----------------------------\n");
        alreadyImported.put(moduleFileName, module_asm);
      }
      else
      {
        // non faccio il parsing ma prendo comunque l'export del modulo e lo metto nell'import
        Logger.logDebug("--------- " + moduleFileName + "  already imported ");
      }
    }
    catch (Exception e)
    {
      e.printStackTrace(System.err);
      throw new ParseException("Error: File " + filename + " has errors when importing " + moduleFileName + ":" + e.getMessage());
    }
    ExportClause module_expCl = module_asm.getHeaderSection().getExportClause();
    Collection < Function > impFunctions = impClause.getImportedFunction();
    Collection < Domain > impDomains = impClause.getImportedDomain();
    Collection < RuleDeclaration > impRules = impClause.getImportedRule();
    Collection < Function > module_func = null;
    Collection < Domain > module_dom = null;
    Collection < RuleDeclaration > module_rules = null;
    if (module_expCl != null)
    {
      module_func = module_expCl.getExportedFunction();
      module_dom = module_expCl.getExportedDomain();
      module_rules = module_expCl.getExportedRule();
    }
    else
    {
      Logger.logWarning("Warning: The ASM " + moduleName + " does not export any function or rule. It cannot be imported by this ASM.\n");
    }
  }
  [
    "("
    {
      Logger.logDebug("imported elements: ");
    }
    (
      importedID = ID_DOMAIN()
      {
        if (module_expCl != null)
        {
          d = Utility.search_domName(module_dom, importedID);
          if (d != null)
          {
            impDomains.add(d);
            Logger.logDebug(importedID);
          }
          else
          {
            Logger.logWarning("Warning: The domain " + importedID + " is not exported by the ASM " + moduleName + ". It cannot be imported by this ASM.\n");
          }
        }
      }
    | importedID = ID_FUNCTION()
      {
        if (module_expCl != null)
        {
          f = Utility.search_funcName(module_func, importedID);
          if (f != null)
          {
            impFunctions.add(f);
            Logger.logDebug(importedID);
            //if it is a Dynamic Function delete all function initializations
            if (f instanceof DynamicFunction) ((DynamicFunction) f).getInitialization().clear();
          }
          else
          {
            Logger.logWarning("Warning: The function " + importedID + " is not exported by the ASM " + moduleName + ". It cannot be imported by this ASM.\n");
          }
        }
      }
    | importedID = ID_RULE()
      {
        if (module_expCl != null)
        {
          r = Utility.search_ruleName(module_rules, importedID);
          if (r != null)
          {
            impRules.add(r);
            Logger.logDebug(importedID);
          }
          else
          {
            Logger.logWarning("Warning: The rule " + importedID + " is not exported by the ASM " + moduleName + ". It cannot be imported by this ASM.\n");
          }
        }
      }
    )
    (
      ","
      (
        importedID = ID_DOMAIN()
        {
          if (module_expCl != null)
          {
            d = Utility.search_domName(module_dom, importedID);
            if (d != null)
            {
              impDomains.add(d);
              Logger.logDebug("," + importedID);
            }
            else
            {
              Logger.logWarning("Warning: The domain " + importedID + " is not exported by the ASM " + moduleName + ". It cannot be imported by this ASM.\n");
            }
          }
        }
      | importedID = ID_FUNCTION()
        {
          if (module_expCl != null)
          {
            f = Utility.search_funcName(module_func, importedID);
            if (f != null)
            {
              impFunctions.add(f);
              Logger.logDebug("," + importedID);
              //if it is a Dynamic Function delete all function initializations
              if (f instanceof DynamicFunction) ((DynamicFunction) f).getInitialization().clear();
            }
            else
            {
              Logger.logWarning("Warning: The function " + importedID + " is not exported by the ASM " + moduleName + ". It cannot be imported by this ASM.\n");
            }
          }
        }
      | importedID = ID_RULE()
        {
          if (module_expCl != null)
          {
            r = Utility.search_ruleName(module_rules, importedID);
            if (r != null)
            {
              impRules.add(r);
              Logger.logDebug("," + importedID);
            }
            else
            {
              Logger.logWarning("Warning: The rule " + importedID + " is not exported by the ASM " + moduleName + ". It cannot be imported by this ASM.\n");
            }
          }
        }
      )
    )*
    ")"
    {
      Logger.logDebug("");
      importAll = false;
    }
  ]
  {
    if (importAll && module_expCl != null)
    { //all domains of the export clause are imported
      impDomains.addAll(module_dom);
      //all functions of the export clause are imported
      for (Function fi : module_func)
      {
        //add the function to the import clause
        impFunctions.add(fi);
        //if it is a Dynamic Function delete all function initializations
        if (fi instanceof DynamicFunction) ((DynamicFunction) fi).getInitialization().clear();
      }
      //all rules of the export clause are imported
      Iterator iter_rules = module_rules.iterator();
      while (iter_rules.hasNext())
      {
        r = (RuleDeclaration) iter_rules.next();
        Logger.logDebug("import rule " + r.getName());
        //add the rule to the import clause
        impRules.add(r);
      }
      Logger.logDebug("imported elements: all");
    }
    return impClause;
  }
}

/*-----------------------*/
ExportClause ExportClause() :
{
  String exportedID;
}
{
  < EXPORT >
  {
    Logger.logDebug("export: ");
    ExportClause expClause = structurePack.createExportClause();
  }
  (
    (
      {
        //Some functions, domains and rules are exported, but not all. Their names are stored in the global variables "exported_Func", "exported_Dom" and "exported_Rules"
        exportAll = false;
        exported_Func = new HashMap();
        exported_Dom = new HashMap();
        exported_Rules = new HashMap();
        String oldValue;
      }
      (
        exportedID = ID_DOMAIN()
        {
          oldValue = (String) exported_Dom.put(new Integer(exportedID.hashCode()), exportedID);
          if (oldValue == null) Logger.logDebug(exportedID);
        }
      | exportedID = ID_FUNCTION()
        {
          oldValue = (String) exported_Func.put(new Integer(exportedID.hashCode()), exportedID);
          if (oldValue == null) Logger.logDebug(exportedID);
        }
      | exportedID = ID_RULE()
        {
          oldValue = (String) exported_Rules.put(new Integer(exportedID.hashCode()), exportedID);
          if (oldValue == null) Logger.logDebug(exportedID);
        }
      )
      (
        ","
        (
          exportedID = ID_DOMAIN()
          {
            oldValue = (String) exported_Dom.put(new Integer(exportedID.hashCode()), exportedID);
            if (oldValue == null) Logger.logDebug("," + exportedID);
          }
        | exportedID = ID_FUNCTION()
          {
            oldValue = (String) exported_Func.put(new Integer(exportedID.hashCode()), exportedID);
            if (oldValue == null) Logger.logDebug("," + exportedID);
          }
        | exportedID = ID_RULE()
          {
            oldValue = (String) exported_Rules.put(new Integer(exportedID.hashCode()), exportedID);
            if (oldValue == null) Logger.logDebug("," + exportedID);
          }
        )
      )*
    )
  | "*"
    { //All functions, domains and rules declared in this machine are exported
      exportAll = true;
      Logger.logDebug("all");
    }
  )
  {
    return expClause;
  }
}

/*-----------------------*/
Signature Signature(Signature signature) :
{
  Domain d, c;
  Function f;
}
{
  < SIGNATURE > ":"
  {
    Logger.logDebug("signature:");
    //create the object
    //Signature signature = structurePack.createSignature();
    Collection < Domain > domains = signature.getDomain();
    Collection < Function > functions = signature.getFunction();
    ExportClause expClause = header.getExportClause();
    Collection < Function > expFunc = null;
    Collection < Domain > expDom = null;
    if (expClause != null)
    {
      expFunc = expClause.getExportedFunction();
      expDom = expClause.getExportedDomain();
    }
    String d_name, c_name;
    boolean inserted;
    // the declarations of imported functions and domains are added to
    // the visible name
    for (ImportClause impClause : header.getImportClause())
    {
      //insert the imported domains
      for (Domain dom : impClause.getImportedDomain())
      {
        d_name = dom.getName();
        if (!declared_Dom.containsKey(d_name))
        {
          //add the domain to the signature
          //domains.add(dom);
          if (!(dom instanceof StructuredTd || dom instanceof BasicTd || dom instanceof AgentDomain || dom instanceof ReserveDomain || dom instanceof AnyDomain))  //insert the domain in the table of declared domains
          declared_Dom.put(d_name, dom);
          //If the imported domain is an enumeration, its enum literals are
          // added to the hash table "enumElem"
          if (dom instanceof EnumTd)
          {
            Iterator iter_enum = ((EnumTd) dom).getElement().iterator();
            EnumElement enumEl;
            while (iter_enum.hasNext())
            {
              enumEl = (EnumElement) iter_enum.next();
              enumElem.put(enumEl.getSymbol(), (EnumTd) dom);
            }
          }
          //check if the domain can be exported
          //Remark: the HashMap exported_Dom is initialized within the ExportClause method so if exported_Dom!=null => expClause!=null
          if (((exported_Dom != null) && exported_Dom.containsKey(new Integer(d_name.hashCode()))) || (exportAll == true))
          { //add the domain to the exportClause
            expDom.add(dom);
            //create the association
            //X AExpClDom.add(expClause,d);
          }
        }
      }
      //insert the imported functions
      for (Function fi : impClause.getImportedFunction())
      {
        inserted = Utility.insert(fi, declared_Func);
        if (inserted)
        { // DO NOT add the function to the signature
          //insert domain and codomain of the function in the declared Domains
          Utility.insert(fi.getDomain(), declared_Dom);
          Utility.insert(fi.getCodomain(), declared_Dom);
          //check if the function can be exported
          //Remark: the HashMap exported_Func is initialized within the ExportClause method so if exported_Func!=null => expClause!=null
          if (((exported_Func != null) && exported_Func.containsKey(new Integer(fi.getName().hashCode()))) || (exportAll == true))
          { //add the function to the exportClause
            expFunc.add(fi);
          }
        }
      }
    }
    //         Logger.logDebug("");
  }
  (
    LOOKAHEAD(2)
    d = Domain()
    {
      d_name = d.getName();
      //check if the domain has already been declared
      if (!declared_Dom.containsKey(d_name))
      { //add the domain to the signature
        domains.add(d);
        if (!(d instanceof StructuredTd || d instanceof BasicTd || d instanceof AgentDomain || d instanceof ReserveDomain || d instanceof AnyDomain))  //insert the domain in the table of declared domains
        declared_Dom.put(d_name, d);
        if (d instanceof StructuredTd) Logger.logDebug(d_name);
      }
      else throw new ParseException("Error: The domain " + d_name + " has been declared twice.");
      //check if the domain can be exported
      //Remark: the HashMap exported_Dom is initialized within the ExportClause method so if exported_Dom!=null => expClause!=null
      if (((exported_Dom != null) && exported_Dom.containsKey(new Integer(d_name.hashCode()))) || (exportAll == true))
      { //add the domain to the exportClause
        expDom.add(d);
        //create the association
        //X AExpClDom.add(expClause,d);
      }
    }
  )*
  {
    Logger.logDebug("");
  }
  (
    LOOKAHEAD(2)
    f = Function()
    {
      inserted = Utility.insert(f, declared_Func);
      if (inserted)
      { //add the function to the signature
        functions.add(f);
        //X ASignFunc.add(signature,f);
      }
      else throw new ParseException("Error: The function " + f.getName() + ":" + ((f.getDomain() == null) ? "" : (f.getDomain().getName() + "->")) + f.getCodomain().getName() + " has been declared twice.");
      //check if the function can be exported
      //Remark: the HashMap exported_Func is initialized within the ExportClause method so if exported_Func!=null => expClause!=null
      if (((exported_Func != null) && exported_Func.containsKey(new Integer(f.getName().hashCode()))) || (exportAll == true))
      { //add the function to the exportClause
        expFunc.add(f);
        //create the association
        //X AExpClFunc.add(expClause,f);
      }
      //check OCL constraint U7: function->forAll(f:Function | not f.oclIsTypeOf(LocalFunction))
      if (OCL_Checker.isLocal(f)) throw new ParseException("Error: A local dynamic function cannot be declared in the signature.\n" + "       At the declaration of the function " + f.getName() + ".");
    }
  )*
  {
    return signature;
  }
}

//-----------------------INITIALIZATION  -----------------------//
Initialization Initialization() :
{
  String nameState;
  DomainInitialization d_init;
  FunctionInitialization f_init;
  AgentInitialization a_init;
}
{
  < INIT > nameState = ID() ":"
  {
    Logger.logDebug("Init " + nameState + ":");
    Initialization initState = structurePack.createInitialization();
    initState.setName(nameState);
  }
  (
    LOOKAHEAD(2)
    d_init = DomainInitialization(initState)
    {
      initState.getDomainInitialization().add(d_init);
    }
  )*
  (
    f_init = FunctionInitialization(initState)
    {
      initState.getFunctionInitialization().add(f_init);
    }
  )*
  (
    a_init = AgentInitialization(initState)
    {
      initState.getAgentInitialization().add(a_init);
    }
  )*
  { //check OCL constraints
    if (!OCL_Checker.checkInitialization(initState))
    {
      Logger.logErr(OCL_Checker.getMsgErr() + "\n       At the initial state " + nameState + ".\n");
    }
    return initState;
  }
}

DomainInitialization DomainInitialization(Initialization initState) :
{
  String name;
  Term body;
  HashMap localVar = new HashMap();
}
{
  < DOMAIN > name = ID_DOMAIN() "="
  {
    Logger.logDebug("\ndomain " + name + "\nbody:");
  }
  body = Term(localVar, false, null)
  {
    Domain dom = (Domain) declared_Dom.get(name);
    //check if the domain has been declared
    if (dom == null) throw new ParseException("Error: The domain " + name + " has not been declared. It cannot be initialized.");
    //check if the domain is a concrete-domain
    if (!(dom instanceof ConcreteDomain)) throw new ParseException("Error: The domain " + name + " is not a concrete-domain. It cannot be initialized.");
    //create the object
    DomainInitialization dom_init = structurePack.createDomainInitialization();
    dom_init.setInitialState(initState);
    //set the reference to the initialized domain
    dom_init.setInitializedDomain(((ConcreteDomain) dom));
    ((ConcreteDomain) dom).getInitialization().add(dom_init);
    //set the reference to the body
    dom_init.setBody(body);
    //check ocl constraints
    if (!OCL_Checker.checkDomainInitialization(dom_init)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the initialization of the domain " + dom.getName() + ".");
    return dom_init;
  }
}

FunctionInitialization FunctionInitialization(Initialization initState) :
{
  Term body;
  String func_name;
  VariableTerm v;
  Domain inDom;
  HashMap localVar = new HashMap();
}
{
  < FUNCTION > func_name = ID_FUNCTION()
  {
    Logger.logDebug("initialization of function " + func_name);
    //create the object
    FunctionInitialization func_init = structurePack.createFunctionInitialization();
    //set the reference in the function initialization
    func_init.setInitialState(initState);
    Collection func_initVariables = func_init.getVariable();
    //the name of the function domain
    String dom_name = "";
  }
  [
    {
      Logger.logDebug("variables: ");
    }
    "(" v = VariableTerm(localVar, true) < IN > inDom = getDomainByID()
    { //set the reference
      func_initVariables.add(v);
      //update variable features
      Utility.updateVariable(v, inDom);
      //if the variables are more then one the associated domains must be type-domains
      //this constraint seems silly, so it is commented
      /*
         if( getToken(1).image.equals(",") && (inDom instanceof ConcreteDomain))
               throw new ParseException("Error: When the function arity is greater than 1, the domains associated to the function variables must be type-domains."+
                                         "       At the initialization of the function "+ func_name +".\n");
		 */
      //update the name of the function domain
      dom_name = inDom.getName();
      Logger.logDebug("\t\t\t" + v.getName() + " updated: D=" + v.getDomain().getName() + ", kind=" + v.getKind().toString());
    }
    (
      ","
      { //check if the next variable is already used (look for it in the localVar HashMap)
        String nextVar = getToken(1).image;
        if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be used as parameter of the initialization of function " + func_name + ". It is already used.");
      }
      v = VariableTerm(localVar, true) < IN > inDom = getDomainByID()
      { //set the reference
        func_initVariables.add(v);
        //set the association
        //Xa_FuncInit_Var.add(v,func_init);
        //update variable features
        Utility.updateVariable(v, inDom);
        //if the variables are more then one the associated domains must be type-domains
        //this constraint seems silly, so it is commented
        /*
         if( inDom instanceof ConcreteDomain)
               throw new ParseException("Error: When the function arity is greter than 1, the domains related to the variables of a function initialization or definition  must be type-domains."+
                                         "       At the initialization of the function "+ func_name +".\n");
		 */
        //update the name of the function domain
        dom_name = dom_name.concat(",").concat(inDom.getName());
        Logger.logDebug("\t\t\t" + v.getName() + " updated: D=" + v.getDomain().getName() + ", kind=" + v.getKind().toString());
      }
    )*
    ")"
  ]
  "="
  {
    Logger.logDebug("body:");
  }
  body = Term(localVar, false, null)
  { //set the reference
    func_init.setBody(body);
    Domain func_dom;
    if (func_initVariables.size() == 0) func_dom = null;
    else if (func_initVariables.size() == 1)
    {
      func_dom = (Domain) declared_Dom.get(dom_name);
      if (func_dom == null) func_dom = Utility.getBasicDomain(domainsFactory, dom_name);
      if (func_dom == null) func_dom = Utility.getPredefinedAbstractDomain(domainsFactory, dom_name);
      if (func_dom == null) func_dom = Utility.getStructuredDomain(domainsFactory, dom_name, header.getSignature());
      if (func_dom == null) throw new ParseException("Error: The domain" + dom_name + " has not been declared. There not exists a function with this domain.");
    }
    else
    {
      dom_name = "Prod(".concat(dom_name).concat(")");
      func_dom = (Domain) Utility.getStructuredDomain(domainsFactory, dom_name, header.getSignature());
      if (func_dom == null) throw new ParseException("Error: The domain" + dom_name + " has not been declared. There not exists a function with this domain.");
    }
    //check if the function has been declared
    /// attenzione non trova le funzioni importate !!!!
    Function f = Utility.getFunction(func_name, func_dom, false, new HashMap(), declared_Func);
    if (f == null) throw new ParseException("Error: The function " + func_name + "(" + dom_name + ")" + " has not been declared. It cannot be initialized");
    if (!(f instanceof DynamicFunction)) throw new ParseException("Error: The function " + func_name + "(" + dom_name + ")" + " is not a dynamic function. It cannot be initialized");
    //set the reference to the function to initialize
    func_init.setInitializedFunction((DynamicFunction) f);
    ((DynamicFunction) f).getInitialization().add(func_init);
    //create the association
    //XX AInitializationInitializedFunction a_FuncInit_Func = structurePack.getAInitializationInitializedFunction();
    //XX a_FuncInit_Func.add(func_init,((DynamicFunction)f));
    // ocl constraint 1 and 2 are granted for construction
    // check ocl constraint 3
    //if(!OCL_Checker.body_ok(f,body))
    //      throw new ParseException(OCL_Checker.getMsgErr()+"\n       At the initialization of the function "+ func_name +"("+dom_name+")"+".");
    //
    if (!OCL_Checker.checkFunctionInitialization(func_init)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the initialization of the function " + func_name + "(" + dom_name + ")" + ".");
    return func_init;
  }
}

AgentInitialization AgentInitialization(Initialization initState) :
{
  Domain dom;
  String id_dom;
  MacroCallRule r;
  HashMap localVar = new HashMap();
}
{
  < AGENT >
  {
    Logger.logDebug("\tAgent initialization begins");
  }
  id_dom = ID_DOMAIN() ":"
  {
    Logger.logDebug("\tagent domain: " + id_dom);
    dom = (Domain) declared_Dom.get(id_dom);
    if (dom == null) dom = Utility.getPredefinedAbstractDomain(domainsFactory, id_dom);
    if (dom == null) throw new ParseException("Error: The domain " + id_dom + " has not been declared. Invariant declaration failed.");
    AgentInitialization agent_init = structurePack.createAgentInitialization();
    agent_init.setInitialState(initState);
    agent_init.setDomain(dom);
  }
  r = MacroCallRule(localVar, null)
  { //set the reference
    agent_init.setProgram(r);
    //check OCL constraints
    if (!OCL_Checker.checkAgentInitialization(agent_init)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the initialization of the agent set " + id_dom + ".");
  }
  {
    Logger.logDebug("\tagent initialization ends");
    return agent_init;
  }
}

//----------------------------BODY----------------------------//
Body Body(Asm m) :
{
  DomainDefinition d_def;
  FunctionDefinition f_def;
  RuleDeclaration r_decl;
  Property p;
  FairnessConstraint fc;
  InvarConstraint ic;
  /*Invariant a;
   //PA 30/12/2010 in order to add the CTLSPEC and LTLSPEC keywords: START 
   CtlSpec ctlSpec;
   LtlSpec ltlSpec;
   //PA 30/12/2010 in order to add the CTLSPEC and LTLSPEC keywords: END
   */
}
{
  < DEFINITIONS > ":"
  {
    Logger.logDebug("definitions:");
    Body body = structurePack.createBody();
    Collection < DomainDefinition > dom_definitions = body.getDomainDefinition();
    Collection < FunctionDefinition > func_definitions = body.getFunctionDefinition();
    Collection < RuleDeclaration > rule_declarations = body.getRuleDeclaration();
    //Collection invariants = body.getInvariant();
    //Collection ctlSpecs = body.getCtlSpec();
    //Collection ltlSpecs = body.getLtlSpec();
    Collection < Property > properties = body.getProperty();
    Collection < FairnessConstraint > fairnessConstraints = body.getFairnessConstraint();
    Collection < InvarConstraint > invarConstraints = body.getInvariantConstraint();
    ExportClause expClause = header.getExportClause();
    Collection < RuleDeclaration > expRules = null;
    if (expClause != null) 
    expRules = expClause.getExportedRule();
  }
  (
    LOOKAHEAD(2)
    d_def = DomainDefinition()
    {
      dom_definitions.add(d_def);
      //set the association
      //XX a_Body_DomDef.add(body,d_def);
    }
  )*
  (
    f_def = FunctionDefinition(m)
    {
      func_definitions.add(f_def);
      //set the association
      //XX a_Body_FuncDef.add(f_def,body);
    }
  )*
  { //the rule declarations imported are added to declared rules
    for (ImportClause impClause : header.getImportClause())
    {
      for (RuleDeclaration r_d : impClause.getImportedRule())
      {
        String rule_name = rule_name = r_d.getName();
        //check if the rule has already been declared
        List < RuleDeclaration > r_list = declared_Rules.get(rule_name);
        if (r_list == null)
        {
          List < RuleDeclaration > newList = new ArrayList < RuleDeclaration > (Collections.singletonList(r_d));
          declared_Rules.put(rule_name, newList);
        }
        else
        {
          // add this rule in any case
          r_list.add(r_d);
        }
        //check if the rule can be exported
        //Remark: the HashMap exported_Rules is initialized within the ExportClause method so if exported_Rules!=null => expClause!=null
        if (((exported_Rules != null) && exported_Rules.containsKey(new Integer(rule_name.hashCode()))) || exportAll)
        {
          expRules.add(r_d);
        }
        //check if the rule is the program associated to an agent in an AgentInitialization
        /*for (AgentInitialization a_init: programs.get(rule_name)){
                     //set the reference
                     // TODO
                     // MODIFICARE !!!! setNamedProgram --> a_init.setProgram((MacroDeclaration)r_decl);
                     //create the association
                     //X AAgentNamedProg.add(a_init,r_decl);
               }*/
      }
    }
  }
  ( /*LOOKAHEAD(2)*/
    r_decl = RuleDeclaration()
    {
      String rule_name = r_decl.getName();
      //check if the rule has already been declared
      if (Utility.searchRuleByName(declared_Rules, rule_name, r_decl.getVariable()) == null)
      {
        rule_declarations.add(r_decl);
        //create the association
        //XX a_Body_Rule.add(body,r_decl);
        //insert the rule in the table of declared rules
        // create a new list of rules
        if (!declared_Rules.containsKey(rule_name))
        {
          List < RuleDeclaration > newList = new ArrayList < RuleDeclaration > (Collections.singletonList(r_decl));
          declared_Rules.put(rule_name, newList);
        }
        else
        {
          declared_Rules.get(rule_name).add(r_decl);
        }
      }
      else
      {
        Logger.logDebug("\trule alredy declared");
        throw new ParseException("Error: The rule " + rule_name + " has been declared twice with the same parameters.");
      }
      //check if the rule can be exported
      //Remark: the HashMap exported_Rules is initialized within the ExportClause method so if exported_Rules!=null => expClause!=null
      if (((exported_Rules != null) && exported_Rules.containsKey(new Integer(rule_name.hashCode()))) || exportAll)
      {
        expRules.add(r_decl);
        //create the association
        //XX AExpClRule.add(expClause,r_decl);
      }
      //check if the rule is the program associated to an agent in an AgentInitialization
      /* r_list = (LinkedList)programs.get(rule_name);
            if(r_list!=null)
            {  iter_r_list = r_list.listIterator(r_list.size());
               while(iter_r_list.hasNext())
               {  a_init = (AgentInitialization)iter_r_list.next();
                  //set the reference
                  // MODIFICARE AG TODO a_init.setNamedProgram((MacroDeclaration)r_decl);
               }
            }*/
    }
  )*
  (
    ic = InvarConstraint(m)
    {
      invarConstraints.add(ic);
    }
  )*
  (
    fc = FairnessConstraint(m)
    {
      fairnessConstraints.add(fc);
    }
  )*
  (
    p = Property(m)
    {
      String name = p.getName();
      if (name != null)
      {
        if (p instanceof CtlSpec)
        {
          for (Property p2 : properties)
          {
            if (p2 instanceof CtlSpec && p2.getName() != null && p2.getName().equals(name))
            {
              throw new ParseException("Two CTL specifications can not have the same name.");
            }
          }
        }
        if (p instanceof LtlSpec)
        {
          for (Property p2 : properties)
          {
            if (p2 instanceof LtlSpec && p2.getName() != null && p2.getName().equals(name))
            {
              throw new ParseException("Two LTL specifications can not have the same name.");
            }
          }
        }
      }
      properties.add(p);
    }
  )*
  /*
    (a=Invariant(m)

        {   //invariants.add(a);
        	properties.add(a);
            //set the association
            //XX a_Body_Axiom.add(a,body);
        }

    )*
    //PA 30/12/2010 in order to add the CTLSPEC and LTLSPEC keywords: START
    (ctlSpec=CtlSpec(m)

        {   //ctlSpecs.add(ctlSpec);
        	properties.add(ctlSpec);
        }

    )*
    (ltlSpec=LtlSpec(m)

        {
          //ltlSpecs.add(ltlSpec);
          properties.add(ltlSpec);
        }

    )*
    //PA 30/12/2010 in order to add the CTLSPEC and LTLSPEC keywords: END
    */
  {
    return body;
  }
}

DomainDefinition DomainDefinition() :
{
  String name;
  Term body;
  HashMap localVar = new HashMap();
}
{
  < DOMAIN > name = ID_DOMAIN() "="
  {
    Logger.logDebug("domain " + name);
    Logger.logDebug("body:");
  }
  body = Term(localVar, false, null)
  {
    Domain dom = declared_Dom.get(name);
    //check if the domain has been declared
    if (dom == null) throw new ParseException("Error: The domain " + name + " has not been declared. It cannot be defined.");
    //check if the domain is a concrete-domain
    if (!(dom instanceof ConcreteDomain)) throw new ParseException("Error: The domain " + name + " is not a concrete-domain. It cannot be defined.");
    //check if the domain has already been defined
    if (((ConcreteDomain) dom).getDefinition() != null) throw new ParseException("Error: The domain " + name + " has been defined twice.");
    //create the object
    DomainDefinition dom_def = structurePack.createDomainDefinition();
    //set the reference to the defined domain
    dom_def.setDefinedDomain(((ConcreteDomain) dom));
    ((ConcreteDomain) dom).setDefinition(dom_def);
    //create the association
    //X ADefinitionDefinedDomain ADefDom = structurePack.getADefinitionDefinedDomain();
    //X ADefDom.add(dom_def,((ConcreteDomain)dom));
    //set the reference to the body
    dom_def.setBody(body);
    //create the association
    //X ADomainDefinitionBody ADefbody = structurePack.getADomainDefinitionBody();
    //X ADefbody.add(dom_def,body);
    //check ocl constraints
    if (!OCL_Checker.checkDomainDefinition(dom_def)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the definition of the " + (((ConcreteDomain) dom).getIsDynamic() ? "dynamic" : "static") + " domain " + dom.getName() + ".");
    return dom_def;
  }
}

FunctionDefinition FunctionDefinition(Asm m) :
{
  Term body;
  String func_name;
  VariableTerm v;
  Domain inDom;
  HashMap < String, VariableTerm > localVar = new HashMap < String, VariableTerm > ();
}
{
  < FUNCTION > func_name = ID_FUNCTION()
  {
    Logger.logDebug("function " + func_name);
    //create the object
    FunctionDefinition func_def = structurePack.createFunctionDefinition();
    List < VariableTerm > variables = func_def.getVariable();
    //the name of the function domain
    String dom_name = "";
  }
  [
    {
      Logger.logDebug("variables: ");
    }
    "(" v = VariableTerm(localVar, true) < IN > inDom = getDomainByID()
    { //set the reference
      variables.add(v);
      //update variable features
      Utility.updateVariable(v, inDom);
      //update the name of the function domain
      dom_name = inDom.getName();
      Logger.logDebug("\t\t\t" + v.getName() + " updated: TD=" + v.getDomain().getName() + ", kind=" + v.getKind().toString());
    }
    (
      ","
      { //check if the next variable is already used (look for it in the localVar HashMap)
        String nextVar = getToken(1).image;
        if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be used as parameter of the definition of function " + func_name + ". It is already used.");
      }
      v = VariableTerm(localVar, true) < IN > inDom = getDomainByID()
      { //set the reference
        variables.add(v);
        //update variable features
        Utility.updateVariable(v, inDom);
        //update the name of the function domain
        dom_name = dom_name.concat(",").concat(inDom.getName());
        Logger.logDebug("\t\t\t" + v.getName() + " updated: TD=" + v.getDomain().getName() + ", kind=" + v.getKind().toString());
      }
    )*
    ")"
  ]
  "="
  {
    Logger.logDebug("body:");
  }
  body = Term(localVar, false, null)
  { //set the reference
    func_def.setBody(body);
    Domain func_dom;
    if (variables.size() == 0) func_dom = null;
    else if (variables.size() == 1)
    {
      func_dom = (Domain) declared_Dom.get(dom_name);
      if (func_dom == null) func_dom = Utility.getBasicDomain(domainsFactory, dom_name);
      if (func_dom == null) func_dom = Utility.getPredefinedAbstractDomain(domainsFactory, dom_name);
      if (func_dom == null) func_dom = Utility.getStructuredDomain(domainsFactory, dom_name, header.getSignature());
      if (func_dom == null) throw new ParseException("Error: The domain" + dom_name + " has not been declared. There not exists a function with this domain.");
    }
    else
    {
      dom_name = "Prod(".concat(dom_name).concat(")");
      func_dom = Utility.getStructuredDomain(domainsFactory, dom_name, header.getSignature());
      if (func_dom == null) throw new ParseException("Error: The domain" + dom_name + " has not been declared. There not exists a function with this domain.");
    }
    //check if the function has been declared
    Function f = Utility.getFunction(func_name, func_dom, false, new HashMap < String, Domain > (), declared_Func);
    if (f == null) throw new ParseException("Error: The function " + func_name + "(" + dom_name + ")" + " has not been declared. It cannot be defined!");
    //check if the function has already been defined
    if (f.getDefinition() != null) throw new ParseException("Error: The function " + func_name + "(" + dom_name + ")" + " has been defined twice.");
    //set the reference to the function to define
    func_def.setDefinedFunction(f);
    f.setDefinition(func_def);
    //create the association
    //X ADefinitionDefinedFunction a_FuncDef_Func = structurePack.getADefinitionDefinedFunction();
    //X a_FuncDef_Func.add(f,func_def);
    //check ocl constraint 1
    if (!((f instanceof StaticFunction) || (f instanceof DerivedFunction))) throw new ParseException("Error: Only static and derived functions can be defined.\n" + "       At the definition of the function " + func_name + "(" + dom_name + ")" + ".");
    if (!OCL_Checker.checkFunctionDefinition(func_def)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the definition of the function " + func_name + "(" + dom_name + ")" + ".");
    return func_def;
  }
}

RuleDeclaration RuleDeclaration() :
{
  RuleDeclaration result;
}
{
  (
    result = MacroDeclaration()
  | result = TurboDeclaration()
  )
  {
    return result;
  }
}

MacroDeclaration MacroDeclaration() :
{
  Logger.logDebug("macro rule");
  MacroDeclaration ruleDecl = rulesPack.getBasicTransitionRules().createMacroDeclaration();
  String ruleName;
  List < VariableTerm > vars;
  Rule body;
  int arity = 0;
  HashMap < String, VariableTerm > localVar = new HashMap < String, VariableTerm > ();
}
{
  [ < MACRO > ] < RULE > ruleName = ID_RULE()
  {
    Logger.logDebug("\t" + ruleName);
    ruleDecl.setName(ruleName);
    List < VariableTerm > variables = ruleDecl.getVariable();
  }
  //NEW by Patrizia  It works! Don't touch! The same apply for TurboDeclaration
  //*************************
  [
    {
      Logger.logDebug("variables: ");
      VariableTerm v;
      Domain inDom;
    }
    "(" v = VariableTerm(localVar, true)  //LOOKAHEAD( {getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("in")})<ID_FUNCTION>
    < IN > inDom = getDomainByID()
    { //add it to the list
      variables.add(v);
      //create the association
      //X ARuleDeclarationVariable ARuleDeclVar = defPack.getARuleDeclarationVariable();
      //X ARuleDeclVar.add(v,ruleDecl);
      //update variable features
      Utility.updateVariable(v, inDom);
      //update the arity value
      arity++;
      Logger.logDebug("\t\t\t" + v.getName() + " updated: TD=" + v.getDomain().getName() + ", kind=" + v.getKind().toString());
    }
    (
      ","
      { //check if the next variable is already used (look for it in the localVar HashMap)
        String nextVar = getToken(1).image;
        if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be used because it is already used.");
      }
      v = VariableTerm(localVar, true)  //LOOKAHEAD( {getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("in")})<ID_FUNCTION>
      < IN > inDom = getDomainByID()
      { //add it to the list
        variables.add(v);
        //create the association
        //X ARuleDeclVar.add(v,ruleDecl);
        //set the variable type-domain
        Utility.updateVariable(v, inDom);
        //(OCL constraint 2) set variable kind
        //if(inDom instanceof RuleDomain)
        //   v.setKind(VariableKind.forName("ruleVar"));
        //update the arity value
        arity++;
        Logger.logDebug("\t\t\t" + v.getName() + " updated: TD=" + v.getDomain().getName() + ", kind=" + v.getKind().toString());
      }
    )*
    ")"
  ]
  //*************
  "="
  {
    // add this rule to the declared rules
    Logger.logDebug("body:");
  }
  body = Rule(localVar, ruleDecl) //NEW by Patrizia Added ruleDecl
  { //set the reference
    ruleDecl.setRuleBody(body);
    ruleDecl.setArity(arity);
    //constraint 1 is granted for construction
    return ruleDecl;
  }
}

TurboDeclaration TurboDeclaration() :
{
  Logger.logDebug("turbo rule \n");
  TurboDeclaration ruleDecl = rulesPack.getTurboTransitionRules().createTurboDeclaration();
  String ruleName;
  List < VariableTerm > vars;
  Rule body;
  int arity = 0;
  Domain inDom;
  HashMap < String, VariableTerm > localVar = new HashMap < String, VariableTerm > ();
}
{
  < TURBO > < RULE > ruleName = ID_RULE()
  {
    ruleDecl.setName(ruleName);
    Logger.logDebug("\t" + ruleName);
    List variables = ruleDecl.getVariable();
  }
  //OLD by Angelo
  //*******************
  //[ vars = variableListInDomains() {
  // set association
  // build local variables
  //	   List variables = ruleDecl.getVariable();
  //	   for (VariableTerm v : vars) {
  //	   	 localVar.put(v.getName(),v);
  //	   	 variables.add(v);
  //	   }
  //	   arity = vars.size();
  //	 }]
  //********************
  //NEW by Patrizia  FUNZIONA! NON TOCCARE! STESSA COSA FATTA SU TurboDeclaration
  //*************************
  [
    {
      Logger.logDebug("variables: ");
      VariableTerm v;
    }
    "(" v = VariableTerm(localVar, true)  //LOOKAHEAD( {getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("in")})<ID_FUNCTION>
    < IN > inDom = getDomainByID()
    { //add it to the list
      variables.add(v);
      //create the association
      //X ARuleDeclarationVariable ARuleDeclVar = defPack.getARuleDeclarationVariable();
      //X ARuleDeclVar.add(v,ruleDecl);
      //update variable features
      Utility.updateVariable(v, inDom);
      //update the arity value
      arity++;
      Logger.logDebug("\t\t\t" + v.getName() + " updated: TD=" + v.getDomain().getName() + ", kind=" + v.getKind().toString());
    }
    (
      ","
      { //check if the next variable is already used (look for it in the localVar HashMap)
        String nextVar = getToken(1).image;
        if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be used because it is already used.");
      }
      v = VariableTerm(localVar, true)  //LOOKAHEAD( {getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("in")})<ID_FUNCTION>
      < IN > inDom = getDomainByID()
      { //add it to the list
        variables.add(v);
        //create the association
        //X ARuleDeclVar.add(v,ruleDecl);
        //set the variable type-domain
        Utility.updateVariable(v, inDom);
        //(OCL constraint 2) set variable kind
        //if(inDom instanceof RuleDomain)
        //v.setKind(VariableKind.forName("ruleVar"));
        //update the arity value
        arity++;
        Logger.logDebug("\t\t\t" + v.getName() + " updated: TD=" + v.getDomain().getName() + ", kind=" + v.getKind().toString());
      }
    )*
    ")"
  ]
  //*************
  // return type
  [
    < IN > inDom = getDomainByID()
    {
      Logger.logDebug("\t\t\tReturn type: " + inDom.getName());
      ruleDecl.setResultType(inDom);
      Logger.logDebug("=");
    }
  ]
  "="
  {
    Logger.logDebug("body:");
  }
  body = Rule(localVar, ruleDecl) //****** NEW by Patrizia Added ruleDecl to manage recursion
  { //set the reference
    ruleDecl.setRuleBody(body);
    ruleDecl.setArity(arity);
    //constraint 1 is granted for construction
    return ruleDecl;
  }
}

Property Property(Asm m) :
{
  Property p;
}
{
  (
    p = Invariant(m)
  | p = TemporalProperty(m)
  )
  {
    return p;
  }
}

TemporalProperty TemporalProperty(Asm m) :
{
  TemporalProperty tp;
}
{
  (
    tp = CtlSpec(m)
  | tp = LtlSpec(m)
  )
  {
    return tp;
  }
}

Invariant Invariant(Asm m) :
{
  String idElement;
  Term exp;
  HashMap localVar = new HashMap();
  boolean funHasArg = false;
  String name = "";
}
{
  < INVARIANT > [ name = ID_AXIOM() ] < OVER >
  {
    Logger.logDebug("invariant " + name + "over ");
    Invariant invariant = defPack.createInvariant();
    invariant.setName(name);
    //XX AConstraintConstrainedDomain AAxiomDom = defPack.getAConstraintConstrainedDomain();
    //XX AConstraintConstrainedFunction AAxiomFunc = defPack.getAConstraintConstrainedFunction();
    //XX AConstraintConstrainedRule AAxiomRule = defPack.getAConstraintConstrainedRule();
    Collection domains = invariant.getConstrainedDomain();
    Collection functions = invariant.getConstrainedFunction();
    Collection rules = invariant.getConstrainedRule();
    Domain dom = null;
    Function func = null;
    RuleDeclaration rule;
  }
  (
    idElement = ID_DOMAIN()
    {
      dom = (Domain) declared_Dom.get(idElement);
      if (dom == null) dom = Utility.getBasicDomain(domainsFactory, idElement);
      if (dom == null) dom = Utility.getPredefinedAbstractDomain(domainsFactory, idElement);
      if (dom == null) dom = Utility.getStructuredDomain(domainsFactory, idElement, header.getSignature());
      if (dom == null) throw new ParseException("Error: The domain " + idElement + " has not been declared. Invariant declaration failed ");
      domains.add(dom);
      dom.getConstraint().add(invariant);
      //create the association
      //XX AAxiomDom.add(dom,invariant);
      dom = null;
      Logger.logDebug(idElement);
    }
  | idElement = ID_FUNCTION()
    [
      "(" [ dom = getDomainByID() ] ")"
      {
        funHasArg = true;
      }
    ]
    {
      if (!funHasArg)
      {
        LinkedList f_list = (LinkedList) declared_Func.get(idElement);
        if (f_list == null) throw new ParseException("Error: The function " + idElement + " has not been declared. Invariant declaration failed.");
        else if (f_list.size() == 1) func = (Function) f_list.getFirst();
        else throw new ParseException("Error: The function " + idElement + " is overloaded. Specify its domain in the invariant declaration.");
      }
      else
      {
        func = Utility.getFunction(idElement, dom, false, new HashMap(), declared_Func);
        if (func == null) throw new ParseException("Error: The function " + idElement + "(" + dom.getName() + ") has not been declared. Invariant declaration failed ");
      }
      functions.add(func);
      func.getConstraint().add(invariant);
      //create the association
      //XX AAxiomFunc.add(func,invariant);
      Logger.logDebug(idElement);
      if (func.getDomain() != null) Logger.logDebug("(" + func.getDomain().getName() + ")");
      funHasArg = false;
    }
  | idElement = ID_RULE()
    {
      rule = Utility.getRuleByNameDom(declared_Rules, idElement, null);
      rules.add(rule);
      rule.getConstraint().add(invariant);
      Logger.logDebug(idElement);
    }
  )
  (
    ","
    (
      idElement = ID_DOMAIN()
      {
        dom = (Domain) declared_Dom.get(idElement);
        if (dom == null) dom = Utility.getBasicDomain(domainsFactory, idElement);
        if (dom == null) dom = Utility.getPredefinedAbstractDomain(domainsFactory, idElement);
        if (dom == null) dom = Utility.getStructuredDomain(domainsFactory, idElement, header.getSignature());
        if (dom == null) throw new ParseException("Error: The domain " + idElement + " has not been declared. Invariant declaration failed.");
        domains.add(dom);
        dom.getConstraint().add(invariant);
        //create the association
        //XX AAxiomDom.add(dom,invariant);
        dom = null;
        Logger.logDebug("," + idElement);
      }
    | idElement = ID_FUNCTION()
      [
        "(" [ dom = getDomainByID() ] ")"
      ]
      {
        if (!funHasArg)
        {
          LinkedList f_list = (LinkedList) declared_Func.get(idElement);
          if (f_list == null) throw new ParseException("Error: The function " + idElement + " has not been declared. Invariant declaration failed.");
          else if (f_list.size() == 1) func = (Function) f_list.getFirst();
          else throw new ParseException("Error: The function " + idElement + " is overloaded. Specify its domain in the invariant declaration.");
        }
        else
        {
          func = Utility.getFunction(idElement, dom, false, new HashMap(), declared_Func);
          if (func == null) throw new ParseException("Error: The function " + idElement + "(" + dom.getName() + ") has not been declared. Invariant declaration failed.");
        }
        functions.add(func);
        func.getConstraint().add(invariant);
        //create the association
        //XX AAxiomFunc.add(func,invariant);
        Logger.logDebug("," + idElement);
        if (func.getDomain() != null) Logger.logDebug("(" + func.getDomain().getName() + ")");
        funHasArg = false;
      }
    | idElement = ID_RULE()
      {
        rule = Utility.getRuleByNameDom(declared_Rules, idElement, null);
        rules.add(rule);
        rule.getConstraint().add(invariant);
        //create the association
        //XX AAxiomRule.add(rule,invariant);
        Logger.logDebug("," + idElement);
      }
    )
  )*
  ":"
  {
    Logger.logDebug("body:");
  }
  exp = Term(localVar, false, null)
  {
    invariant.setBody(exp);
    //create the association
    //XX AAxiomBody AAxiomBody = defPack.getAAxiomBody();
    //XX AAxiomBody.add(invariant,exp);
    //ocl constraint 1 is granted for construction
    //check ocl constraint 2
    //PA 30/12/2010 poiche' abbiamo introdotto gli operatori temporali come
    //funzioni con codominio Boolean, qui bisognerebbe anche controllare
    //che all'interno di exp non sia stata utilizzata una funzione della
    //CTLlibrary o della LTLlibrary
    if (!OCL_Checker.isBoolean(exp))
    {
      Logger.logErr("Error: The expression specifying an invariant must be a term whose associated type-domain is Boolean.");
      //PA 2 feb 2011: aggiunta ParseException  
      throw new ParseException("Error: The expression specifying an invariant must be a term whose associated type-domain is Boolean.");
    }
  }
  {
    return invariant;
  }
}

//PA 19/05/2014 in order to add the CTLSPEC, LTLSPEC, FAIRNESS, JUSTICE, COMPASSION, and INVAR keywords: START
CtlSpec CtlSpec(Asm m) :
{
  Term exp;
  HashMap localVar = new HashMap();
  String name = null;
}
{
  < CTLSPEC > [ name = ID_CTL() ":" ]
  {
    Logger.logDebug("CTLSPEC");
    CtlSpec ctlSpec = defPack.createCtlSpec();
    if (name != null)
    {
      ctlSpec.setName(name);
    }
  }
  //":" //without the colon it's exactly like the NuSMV syntax
  {
    Logger.logDebug("body:");
  }
  exp = Term(localVar, false, null)
  {
    ctlSpec.setBody(exp);
    //PA 30/12/2010 here we should check that no function of the LTLlibrary is used
    if (!OCL_Checker.isBoolean(exp))
    {
      Logger.logErr("Error: The expression specifying a CTL propery must be a term whose associated type-domain is Boolean.");
      throw new ParseException("Error: The expression specifying a CTL propery must be a term whose associated type-domain is Boolean.");
    }
  }
  {
    return ctlSpec;
  }
}

LtlSpec LtlSpec(Asm m) :
{
  Term exp;
  HashMap localVar = new HashMap();
  String name = null;
  Token t;
}
{
  < LTLSPEC > [ name = ID_LTL() ":" ]
  {
    Logger.logDebug("LTLSPEC");
    LtlSpec ltlSpec = defPack.createLtlSpec();
    if (name != null)
    {
      ltlSpec.setName(name);
    }
  }
  //":" //without the colon it's exactly like the NuSMV syntax
  {
    Logger.logDebug("body:");
  }
  exp = Term(localVar, false, null)
  {
    ltlSpec.setBody(exp);
    //PA 30/12/2010 here we should check that no function of the CTLlibrary is used
    if (!OCL_Checker.isBoolean(exp))
    {
      Logger.logErr("Error: The expression specifying an LTL property must be a term whose associated type-domain is Boolean.");
      throw new ParseException("Error: The expression specifying an LTL property must be a term whose associated type-domain is Boolean.");
    }
  }
  {
    return ltlSpec;
  }
}

FairnessConstraint FairnessConstraint(Asm m) :
{
  FairnessConstraint fc;
}
{
  (
    fc = JusticeConstraint(m)
  | fc = CompassionConstraint(m)
  )
  {
    return fc;
  }
}

JusticeConstraint JusticeConstraint(Asm m) :
{
  Term exp;
  HashMap localVar = new HashMap();
  String name = null;
  Token t;
}
{
  < JUSTICE > //| < FAIRNESS > //TODO also the keyword FAIRNESS should be handled 
  {
    Logger.logDebug("JUSTICE");
    JusticeConstraint justiceConstraint = defPack.createJusticeConstraint();
  }
  //":" //without the colon it's exactly like the NuSMV syntax
  {
    Logger.logDebug("body:");
  }
  exp = Term(localVar, false, null)
  {
    justiceConstraint.setBody(exp);
    if (!OCL_Checker.isBoolean(exp))
    {
      Logger.logErr("Error: The expression specifying a JUSTICE constraint must be a term whose associated type-domain is Boolean.");
      throw new ParseException("Error: The expression specifying a JUSTICE constraint must be a term whose associated type-domain is Boolean.");
    }
  }
  {
    return justiceConstraint;
  }
}

CompassionConstraint CompassionConstraint(Asm m) :
{
  Term p, q;
  HashMap localVar = new HashMap();
  String name = null;
  Token t;
}
{
  < COMPASSION >
  {
    Logger.logDebug("COMPASSION");
    CompassionConstraint compassionConstraint = defPack.createCompassionConstraint();
  }
  "("
  {
    Logger.logDebug("p:");
  }
  p = Term(localVar, false, null) 
  ","
  {
    Logger.logDebug("q:");
  }
  q = Term(localVar, false, null)
  {
    compassionConstraint.setP(p);
    if (!OCL_Checker.isBoolean(p))
    {
      Logger.logErr("Error: The expression p specifying a COMPASSION constraint must be a term whose associated type-domain is Boolean.");
      throw new ParseException("Error: The expression p specifying a COMPASSION constraint must be a term whose associated type-domain is Boolean.");
    }
    compassionConstraint.setQ(q);
    if (!OCL_Checker.isBoolean(q))
    {
      Logger.logErr("Error: The expression q specifying a COMPASSION constraint must be a term whose associated type-domain is Boolean.");
      throw new ParseException("Error: The expression q specifying a COMPASSION constraint must be a term whose associated type-domain is Boolean.");
    }
  }
  {
    return compassionConstraint;
  }
}

InvarConstraint InvarConstraint(Asm m) :
{
  Term exp;
  HashMap localVar = new HashMap();
  String name = null;
  Token t;
}
{
  < INVAR >
  {
    Logger.logDebug("INVAR");
    InvarConstraint invarConstraint = defPack.createInvarConstraint();
  }
  //":" //without the colon it's exactly like the NuSMV syntax
  {
    Logger.logDebug("body:");
  }
  exp = Term(localVar, false, null)
  {
    invarConstraint.setBody(exp);
    if (!OCL_Checker.isBoolean(exp))
    {
      Logger.logErr("Error: The expression specifying an INVAR constraint must be a term whose associated type-domain is Boolean.");
      throw new ParseException("Error: The expression specifying an INVAR constraint must be a term whose associated type-domain is Boolean.");
    }
  }
  {
    return invarConstraint;
  }
}

//PA 19/05/2014 in order to add the CTLSPEC, LTLSPEC, FAIRNESS, JUSTICE, COMPASSION, and INVAR keywords: END
/*-----------------------------------------------------------*/
/**********************    DOMAIN    *************************/
/*-----------------------------------------------------------*/
Domain Domain() :
{
  Domain d;
}
{
  (
    LOOKAHEAD(2)
    d = ConcreteDomain()
  | d = TypeDomain()
  )
  {
    return d;
  }
}

/*----------------------  ConcreteDomain  --------------------*/
ConcreteDomain ConcreteDomain() :
{
  String name;
  boolean isDynamic = false;
  Domain typeDom;
}
{
  [
    < DYNAMIC >
    {
      isDynamic = true;
    }
  ]
  < DOMAIN > name = ID_DOMAIN() < SUBSETOF > typeDom = getDomainByID()
  {
    if (!(typeDom instanceof TypeDomain))
    {
      throw new ParseException("Error: A concrete domain cannot be defined over a concrete domain.");
    }
    //create the object
    ConcreteDomain concreteDom = defPack.getDomains().createConcreteDomain();
    concreteDom.setName(name);
    concreteDom.setIsDynamic(isDynamic);
    //set references
    concreteDom.setTypeDomain((TypeDomain) typeDom);
    Logger.logDebug(isDynamic ? "dynamic" : "" + "domain " + name + " subsetof " + typeDom.getName());
    return concreteDom;
  }
}

/*----------------------   TypeDomain  Ok! ----------------------*/
TypeDomain TypeDomain() :
{
  TypeDomain d;
}
{
  (
    d = AnyDomain()
  | d = StructuredTD()
  | d = EnumTD()
  | d = AbstractTD()
  | d = BasicTD()
  )
  {
    return d;
  }
}

/*---------------  AnyDomain  To be done! ------------------*/
AnyDomain AnyDomain() :
{
  String name;
}
{
  < ANYDOMAIN > name = ID_DOMAIN()
  {
    AnyDomain d = Utility.getAnyDomain(domainsFactory, name);
    if (d == null)
    {
      // TODO
      // check name and in case
      // throw new ParseException("Error: The domain "+ name + " cannot be declared as an AnyDomain");
      d = domainsFactory.createAnyDomain(name);
    }
    Logger.logDebug("anydomain " + name);
    return d;
  }
}

/*---------------  BasicTD  OK! ------------------*/
BasicTd BasicTD() :
{
  String name;
}
{
  < BASIC > < DOMAIN > name = ID_DOMAIN()
  {
    BasicTd basicTd = Utility.getBasicDomain(domainsFactory, name);
    if (basicTd == null) throw new ParseException("Error: A basic domain " + name + " not allowed has been declared.");
    Logger.logDebug("basic domain " + name);
    return basicTd;
  }
}

/*-------------  AbstractTD  OK! -----------------*/
AbstractTd AbstractTD() :
{
  String name;
  boolean isDynamic = false;
}
{
  [
    < DYNAMIC >
    {
      isDynamic = true;
    }
  ]
  < ABSTRACT > < DOMAIN > name = ID_DOMAIN()
  {
    // try predefined
    AbstractTd abstractTd = Utility.getPredefinedAbstractDomain(domainsFactory, name);
    // otherwise create new one
    if (abstractTd == null)
    {
      abstractTd = domainsFactory.createAbstractTd();
      abstractTd.setName(name);
      abstractTd.setIsDynamic(isDynamic);
      Logger.logDebug("creating abstract domain " + name);
    }
    else
    {
      Logger.logDebug("abstract domain " + name);
    }
    return abstractTd;
  }
}

/*---------------  EnumTD  OK! -------------------*/
EnumTd EnumTD() :
{
  String name;
  EnumElement elem;
}
{
  < ENUM > < DOMAIN > name = ID_DOMAIN()
  {
    EnumTd enumTd = defPack.getDomains().createEnumTd();
    enumTd.setName(name);
    Collection elements = enumTd.getElement();
    Logger.logDebug("enum domain " + name);
  }
  "=" "{" elem = EnumElement()
  { //add the new element to the collection
    elements.add(elem);
    //create the association
    //XX AEnumTdElem.add(elem,enumTd);
    //insert it in the hashMap of enum elements
    String symbol = elem.getSymbol();
    if (enumElem.put(symbol, enumTd) != null)
    {
      throw new ParseException("The enum symbol " + symbol + " is duplicate");
    }
    Logger.logDebug("={" + symbol);
  }
  (
    // aggiunto come sepratore anche la virgola 14/4/2020 AG
    ( "|"| ",") elem = EnumElement()
    { //add new element to the collection
      elements.add(elem);
      //create the association
      //XX AEnumTdElem.add(elem,enumTd);
      //insert it in the hashMap of enum elements
      symbol = elem.getSymbol();
      if (enumElem.put(symbol, enumTd) != null)
      {
        throw new ParseException("The enum symbol " + symbol + " is duplicate");
      }
      Logger.logDebug("|" + symbol);
    }
  )*
  "}"
  {
    Logger.logDebug("}");
    return enumTd;
  }
}

EnumElement EnumElement() :
{
  String symbol;
}
{
  symbol = ID_ENUM()
  {
    EnumElement elem = defPack.getDomains().createEnumElement();
    elem.setSymbol(symbol);
    return elem;
  }
}

/*-------------  StructuredTD  OK! ---------------*/
StructuredTd StructuredTD() :
{
  StructuredTd d;
}
{
  (
    d = RuleDomain()
  | d = ProductDomain()
  | d = SequenceDomain()
  | d = PowersetDomain()
  | d = BagDomain()
  | d = MapDomain()
  )
  {
    return d;
  }
}

RuleDomain RuleDomain() :
{
  Domain dom;
}
{
  < RULEDOM >
  {
    List ruleElemList = new LinkedList();
  }
  [
    "(" dom = getDomainByID()
    {
      ruleElemList.add(dom);
    }
    (
      "," dom = getDomainByID()
      {
        ruleElemList.add(dom);
      }
    )*
    ")"
  ]
  {
    return Utility.getRuleDomain(ruleElemList, defPack, header.getSignature());
  }
}

ProductDomain ProductDomain() :
{
  Domain dom;
}
{
  < PROD >
  {
    List prodElemList = new LinkedList();
  }
  "(" dom = getDomainByID()
  {
    //a StructuredTD can not be defined over a concrete domain  NO LONGER APPLIES!!!
    //if(!(dom instanceof TypeDomain))
    //   {   throw new ParseException("Error: A StructuredTD domain can not be defined over a concrete domain.");}
    //add a new element to the Domain list
    prodElemList.add(dom); //prodElemList.add((TypeDomain)dom);
  }
  (
    "," dom = getDomainByID()
    { //a StructuredTD can not be defined over a concrete domain  NO LONGER APPLIES!!!
      //if(!(dom instanceof TypeDomain))
      //   {   throw new ParseException("Error: A StructuredTD domain can not be defined over a concrete domain.");}
      //add a new element to the Domain list
      prodElemList.add(dom); //prodElemList.add((TypeDomain)dom);
    }
  )+
  ")"
  {
    return Utility.getProduct(prodElemList, defPack, header.getSignature());
  }
}

//OK!
SequenceDomain SequenceDomain() :
{
  Domain dom;
}
{
  < SEQ > "(" dom = getDomainByID() ")"
  { //NO LONGER APPLIES!!!
    //a SeqTD can not be defined over a concrete domain
    //if(!(dom instanceof TypeDomain))
    //{   throw new ParseException("Error: A SequenceTD can not be defined over a concrete domain.");}
    return Utility.getSequence(dom, defPack, header.getSignature());
  }
}

PowersetDomain PowersetDomain() :
{
  Domain dom;
}
{
  < POWERSET > "(" dom = getDomainByID() ")"
  { //NO LONGER APPLIES!!!
    //a PowerTD can not be defined over a concrete domain
    // if(!(dom instanceof TypeDomain))
    //    {   throw new ParseException("Error: A PowerTD can not be defined over a concrete domain.");}
    return Utility.getPowerset(dom, defPack, header.getSignature());
  }
}

BagDomain BagDomain() :
{
  Domain dom;
}
{
  < BAG > "(" dom = getDomainByID() ")"
  { //NO LONGER APPLIES!!!
    //a BagTD can not be defined over a concrete domain
    //if(!(dom instanceof TypeDomain))
    //   {   throw new ParseException("Error: A BagTD domain can not be defined over a concrete domain.");}
    return Utility.getBag(dom, defPack, header.getSignature());
  }
}

MapDomain MapDomain() :
{
  Domain dom1, dom2;
}
{
  < MAP > "(" dom1 = getDomainByID() "," dom2 = getDomainByID() ")"
  { //NO LONGER APPLIES!!!
    //a MapTD domain can not be defined over a concrete domain
    //if(!(dom1 instanceof TypeDomain)||!(dom2 instanceof TypeDomain))
    //    {   throw new ParseException("Error: A MapTD domain can not be defined over a concrete domain.");}
    return Utility.getMap(dom1, dom2, defPack, header.getSignature());
  }
}

//------------------------------------------------------------//
Domain getDomainByID() :
{
  String domName;
  Domain domain;
}
{
  (
    domName = ID_DOMAIN()
    {
      domain = declared_Dom.get(domName);
      if (domain == null) domain = Utility.getPredefinedDomain(domainsFactory, domName);
      if (domain == null) {
          	  throw new ParseException("Error: " + domName + " domain is not declared.");      
      }
    }
  | domain = StructuredTD()
  )
  {
    return domain;
  }
}

//------------------------------------------------------------//
/*-----------------------------------------------------------*/
/**********************   FUNCTIONS   OK! ************************/
/*-----------------------------------------------------------*/
Function Function() :
{
  Function func;
}
{
  (
    func = BasicFunction()
  | func = DerivedFunction()
  )
  {
    return func;
  }
}

BasicFunction BasicFunction() :
{
  BasicFunction func;
}
{
  (
    func = StaticFunction()
  | func = DynamicFunction()
  )
  {
    return func;
  }
}

DerivedFunction DerivedFunction() :
{
  String funcName;
  Domain dom = null;
  Domain cod;
}
{
  < DERIVED > funcName = ID_FUNCTION() ":"
  {
    DerivedFunction func = defPack.createDerivedFunction();
    func.setName(funcName);
  }
  [
    LOOKAHEAD(getDomainByID() "->")
    dom = getDomainByID() "->"
    {
      func.setDomain(dom);
    }
  ]
  cod = getDomainByID()
  {
    func.setCodomain(cod);
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
    int arity = OCL_Checker.evalArity(func);
    func.setArity(arity);
    Logger.logDebug("derived function " + funcName + ":" + ((dom != null) ? (dom.getName() + "->") : "") + cod.getName() + "\t arity = " + arity);
    return func;
  }
}

StaticFunction StaticFunction() :
{
  String funcName;
  Domain dom = null;
  Domain cod;
}
{
  {
    StaticFunction func = defPack.createStaticFunction();
  }
  < STATIC > funcName = ID_FUNCTION() ":"
  {
    func.setName(funcName);
  }
  [
    LOOKAHEAD(getDomainByID() "->")
    dom = getDomainByID() "->"
    {
      func.setDomain(dom);
    }
  ]
  cod = getDomainByID()
  {
    func.setCodomain(cod);
    int arity = OCL_Checker.evalArity(func);
    func.setArity(arity);
    Logger.logDebug("static function " + funcName + ":" + ((dom != null) ? (dom.getName() + "->") : "") + cod.getName() + "\t arity = " + arity);
    return func;
  }
}

//OK!
DynamicFunction DynamicFunction() :
{
  DynamicFunction result;
}
{
  // LOOKHEAD IS NECESSARY BEACUASE OF "DYNAMIC"
  (
    LOOKAHEAD(2)
    result = OutFunction()
  | LOOKAHEAD(2)
    result = MonitoredFunction()
  | LOOKAHEAD(2)
    result = SharedFunction()
  | LOOKAHEAD(2)
    result = ControlledFunction()
  | result = LocalFunction()
  )
  {
    return result;
  }
}

LocalFunction LocalFunction() :
{
  String funcName;
  Domain dom = null;
  Domain cod;
}
{
  {
    LocalFunction func = defPack.createLocalFunction();
  }
  [ < DYNAMIC > ] < LOCAL > funcName = ID_FUNCTION() ":"
  {
    func.setName(funcName);
  }
  [
    LOOKAHEAD(getDomainByID() "->")
    dom = getDomainByID() "->"
    {
      func.setDomain(dom);
      //create the association
      //XX AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX AFuncDom.add(func,dom);
    }
  ]
  cod = getDomainByID()
  {
    func.setCodomain(cod);
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
    int arity = OCL_Checker.evalArity(func);
    func.setArity(arity);
    Logger.logDebug("local function " + funcName + ":" + ((dom != null) ? (dom.getName() + "->") : "") + cod.getName() + "\t arity = " + arity);
    return func;
  }
}

ControlledFunction ControlledFunction() :
{
  String funcName;
  Domain dom = null;
  Domain cod;
}
{
  {
    ControlledFunction func = defPack.createControlledFunction();
  }
  [ < DYNAMIC > ] < CONTROLLED > funcName = ID_FUNCTION() ":"
  {
    func.setName(funcName);
  }
  [
    LOOKAHEAD(getDomainByID() "->")
    dom = getDomainByID() "->"
    {
      func.setDomain(dom);
      //create the association
      //XX  AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX AFuncDom.add(func,dom);
    }
  ]
  cod = getDomainByID()
  {
    func.setCodomain(cod);
    //create the association
    //XX  AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
    int arity = OCL_Checker.evalArity(func);
    func.setArity(arity);
    Logger.logDebug("controlled function " + funcName + ":" + ((dom != null) ? (dom.getName() + "->") : "") + cod.getName() + "\t arity = " + arity);
    return func;
  }
}

SharedFunction SharedFunction() :
{
  String funcName;
  Domain dom = null;
  Domain cod;
}
{
  {
    SharedFunction func = defPack.createSharedFunction();
  }
  [ < DYNAMIC > ] < SHARED > funcName = ID_FUNCTION() ":"
  {
    func.setName(funcName);
  }
  [
    LOOKAHEAD(getDomainByID() "->")
    dom = getDomainByID() "->"
    {
      func.setDomain(dom);
      //create the association
      //XX AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX AFuncDom.add(func,dom);
    }
  ]
  cod = getDomainByID()
  {
    func.setCodomain(cod);
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
    int arity = OCL_Checker.evalArity(func);
    func.setArity(arity);
    Logger.logDebug("shared function " + funcName + ":" + ((dom != null) ? (dom.getName() + "->") : "") + cod.getName() + "\t arity = " + arity);
    return func;
  }
}

MonitoredFunction MonitoredFunction() :
{
  String funcName;
  Domain dom = null;
  Domain cod;
}
{
  {
    MonitoredFunction func = defPack.createMonitoredFunction();
  }
  [ < DYNAMIC > ] < MONITORED > funcName = ID_FUNCTION() ":"
  {
    func.setName(funcName);
  }
  [
    LOOKAHEAD(getDomainByID() "->")
    dom = getDomainByID() "->"
    {
      func.setDomain(dom);
      //create the association
      //XX AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX  AFuncDom.add(func,dom);
    }
  ]
  cod = getDomainByID()
  {
    func.setCodomain(cod);
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
    int arity = OCL_Checker.evalArity(func);
    func.setArity(arity);
    Logger.logDebug("monitored function " + funcName + ":" + ((dom != null) ? (dom.getName() + "->") : "") + cod.getName() + "\t arity = " + arity);
    return func;
  }
}

OutFunction OutFunction() :
{
  String funcName;
  Domain dom = null;
  Domain cod;
}
{
  {
    OutFunction func = defPack.createOutFunction();
  }
  [ < DYNAMIC > ] < OUT > funcName = ID_FUNCTION() ":"
  {
    func.setName(funcName);
  }
  [
    LOOKAHEAD(getDomainByID() "->")
    dom = getDomainByID() "->"
    {
      func.setDomain(dom);
      //create the association
      //XX  AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX AFuncDom.add(func,dom);
    }
  ]
  cod = getDomainByID()
  {
    func.setCodomain(cod);
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
    int arity = OCL_Checker.evalArity(func);
    func.setArity(arity);
    Logger.logDebug("out function " + funcName + ":" + ((dom != null) ? (dom.getName() + "->") : "") + cod.getName() + "\t arity = " + arity);
    return func;
  }
}

/*-----------------------------------------------------------*/
/************************   TERMs    ***************************/
/*-----------------------------------------------------------*/
Term Term(HashMap localVar, boolean areAllowedNewVar, RuleDeclaration c) :
{
  Term t;
}
{
  t = TermForUpdateRule(localVar, areAllowedNewVar, c, null)
  {
    return t;
  }
}

Term TermForUpdateRule(HashMap localVar, boolean areAllowedNewVar, RuleDeclaration c, Domain expDom) :
{
  Term t;
}
{
  (
    LOOKAHEAD(Expression())
    t = Expression(localVar, areAllowedNewVar)
  | t = ExtendedTerm(localVar, areAllowedNewVar, c, expDom)
  )
  {
    return t;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*    Expression   */
//IMPLIES
Term Expression(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg1, arg2;
  Token tok;
}
{
  t = or_xorLogicExpr(localVar, areAllowedNewVar)
  (
    (
      LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("implies") })
      tok = < ID_FUNCTION >
      {
        Logger.logDebug("\timplies\t\toperator");
      }
      arg2 = or_xorLogicExpr(localVar, areAllowedNewVar)
    | LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("iff") })
      tok = < ID_FUNCTION >
      {
        Logger.logDebug("\tiff\t\toperator");
      }
      arg2 = or_xorLogicExpr(localVar, areAllowedNewVar)
    )
    {
      arg1 = t;
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();
      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
    }
  )*
  {
    return t;
  }
}

// OR  //XOR
Term or_xorLogicExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term arg1, arg2;
  Token op;
}
{
  arg1 = andLogicExpr(localVar, areAllowedNewVar)
  (
    (
      LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("or") })
      op = < ID_FUNCTION >
      /* op = <OR> */{
        Logger.logDebug("\tor\t\toperator");
      }
    | LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("xor") })
      op = < ID_FUNCTION >
      /*op = <XOR> */{
        Logger.logDebug("\txor\t\toperator");
      }
    )
    arg2 = andLogicExpr(localVar, areAllowedNewVar)
    {
      String funcName = Utility.getFunctionName(op.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();      arg1 = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());
      if (arg1 == null) throw new ParseException("Error at ");
    }
  )*
  {
    return arg1;
  }
}

// AND
Term andLogicExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg1, arg2;
  Token tok;
}
{
  t = relationalExpr(localVar, areAllowedNewVar)
  (
    LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("and") })
    tok = < ID_FUNCTION >
    /*tok = <AND> */{
      Logger.logDebug("\tand\t\toperator");
    }
    arg2 = relationalExpr(localVar, areAllowedNewVar)
    {
      arg1 = t;
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
    }
  )*
  {
    return t;
  }
}

/* NEVER USED
// in e !in (appartenenza)
Term includesExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg1, arg2;
  Token tok;
}
{
  t = relationalExpr(localVar, areAllowedNewVar)
  (
    (
      LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("in") })
      tok = < ID_FUNCTION >
      {
        Logger.logDebug("\tin\t\toperator");
      }
      arg2 = relationalExpr(localVar, areAllowedNewVar)
    | LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("notin") })
      tok = < ID_FUNCTION >
      {
        Logger.logDebug("\tnotin\t\toperator");
      }
      arg2 = relationalExpr(localVar, areAllowedNewVar)
    )
    {
      arg1 = t;
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
    }
  )?
  {
    return t;
  }
}*/

// == != > >= < <=
Term relationalExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg1, arg2;
  Token tok;
}
{
  t = notLogicExpr(localVar, areAllowedNewVar)
  (
    LOOKAHEAD(2)
    (
      tok = < EQ >
      {
        Logger.logDebug("\t=\t\toperator");
      }
      arg2 = notLogicExpr(localVar, areAllowedNewVar)
    | tok = < NEQ >
      {
        Logger.logDebug("\t!=\t\toperator");
      }
      arg2 = notLogicExpr(localVar, areAllowedNewVar)
    | tok = < LT >
      {
        Logger.logDebug("\t<\t\toperator");
      }
      arg2 = notLogicExpr(localVar, areAllowedNewVar)
    | tok = < LE >
      {
        Logger.logDebug("\t<=\t\toperator");
      }
      arg2 = notLogicExpr(localVar, areAllowedNewVar)
    | tok = < GT >
      {
        Logger.logDebug("\t>\t\toperator");
      }
      arg2 = notLogicExpr(localVar, areAllowedNewVar)
    | tok = < GE >
      {
        Logger.logDebug("\t>=\t\toperator");
      }
      arg2 = notLogicExpr(localVar, areAllowedNewVar)
    )
    {
      arg1 = t;
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();
      t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());      if (t == null) 
      		throw new ParseException("Error reading relationalExpr ");
    }
  )*
  {
    return t;
  }
}

// NOT
Term notLogicExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg;
  Token op;
}
{
  (
    LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("not") })
    op = < ID_FUNCTION >
    // op = <NOT> , non possibili vedi caso mod
    {
      Logger.logDebug("\tnot\t\toperator");
    }
    arg = additiveExpr(localVar, areAllowedNewVar)
    {
      String funcName = Utility.getFunctionName(op.image);
      TupleTerm tupleT = Utility.createSingle(arg, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();
      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
    }
  | t = additiveExpr(localVar, areAllowedNewVar)
  )
  {
    return t;
  }
}

//
// a +b
//
Term additiveExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg1, arg2;
  Token tok;
}
{
  t = multiplicativeExpr(localVar, areAllowedNewVar)
  (
    (
      LOOKAHEAD(2)
      tok = < PLUS >
      {
        Logger.logDebug("\t+\t\toperator");
      }
      arg2 = multiplicativeExpr(localVar, areAllowedNewVar)
    | tok = < MINUS >
      {
        Logger.logDebug("\t-\t\toperator");
      }
      arg2 = multiplicativeExpr(localVar, areAllowedNewVar)
    )
    {
      arg1 = t;
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
    }
  )*
  {
    return t;
  }
}

Term multiplicativeExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg1, arg2;
  Token tok;
}
{
  t = powerExpr(localVar, areAllowedNewVar)
  (
    (
      tok = < MULT >
      {
        Logger.logDebug("\t*\t\toperator");
      }
      arg2 = powerExpr(localVar, areAllowedNewVar)
    | tok = < DIV >
      {
        Logger.logDebug("\t/\t\toperator");
      }
      arg2 = powerExpr(localVar, areAllowedNewVar)
    | LOOKAHEAD({ getToken(1).kind == ID_FUNCTION && getToken(1).image.equals("mod") })
      tok = < ID_FUNCTION >
      {
        Logger.logDebug("\tmod\t\toperator");
      }
      // se definisco il token mod non posso più usarlo come funzione,
      // invece mod è definito nella standard library anche come funzione
      // quindi quando trova <MOD> invece che function protesta
      // tok = <MOD> {Logger.logDebug("\tmod\t\toperator");}
      arg2 = powerExpr(localVar, areAllowedNewVar)
    )
    {
      arg1 = t;
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
    }
  )*
  {
    return t;
  }
}

Term powerExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg1, arg2;
  Token tok;
}
{
  t = unaryExpr(localVar, areAllowedNewVar)
  (
    tok = < PWR >
    {
      Logger.logDebug("\t^\t\toperator");
    }
    arg2 = unaryExpr(localVar, areAllowedNewVar)
    {
      arg1 = t;
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
    }
  )*
  {
    return t;
  }
}

Term unaryExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t = null, arg;
  Token tok;
}
{
  (
    (
      LOOKAHEAD(2)
      tok = < PLUS >
      {
        Logger.logDebug("\tPLUS UNARY -\t\toperator");
      }
      arg = unaryExpr(localVar, areAllowedNewVar)
    | tok = < MINUS >
      {
        Logger.logDebug("\t MINUS  UNARY -\t\toperator");
      }
      arg = unaryExpr(localVar, areAllowedNewVar)
    )
    {
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createSingle(arg, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();      t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());
      if (t == null) throw new ParseException("Problems in creating unary espressions (" + funcName + ")");
      return t;
    }
  | t = basicExpr(localVar, areAllowedNewVar)
  )
  {
    return t;
  }
}

Term basicExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t;
}
{
  (
    LOOKAHEAD(BasicTerm())
    t = BasicTerm(localVar, areAllowedNewVar)
  | t = DomainTerm()
  | LOOKAHEAD(FiniteQuantificationTerm())
    t = FiniteQuantificationTerm(localVar)
  | "("
    {
      Logger.logDebug("\t(");
    }
    t = Expression(localVar, areAllowedNewVar) ")"
    {
      Logger.logDebug("\t)");
    }
  )
  {
    return t;
  }
}

////////////////////////////////////////////////////////////////////////////////////////
BasicTerm BasicTerm(HashMap localVar, boolean areAllowedNewVar) :
{
  BasicTerm t;
}
{
  (
    t = ConstantTerm()
  | t = VariableTerm(localVar, areAllowedNewVar)
  | t = FunctionTerm(localVar, areAllowedNewVar)
  )
  {
    return t;
  }
}

FunctionTerm FunctionTerm(HashMap localVar, boolean areAllowedNewVar) :
{
  String funcName;
  String agentName = null;
  TupleTerm tupleT = null;
  FunctionTerm t;
}
{
  {
    Logger.logDebug("\t");
  }
  [
    LOOKAHEAD(2)
    agentName = ID_AGENT() "."
    {
      Logger.logDebug(agentName + ".");
    }
  ]
  funcName = ID_FUNCTION()
  {
    Logger.logDebug(funcName + "\t\tFunctionTerm beginning");
  }
  [ tupleT = TupleTerm(localVar, areAllowedNewVar) ]
  {
    if (agentName != null)
    { //create a new functionTerm representing the agent
      FunctionTerm agent_funT;
      if (agentName.equals("self"))
      {
        if ((agent_funT = Utility.createFunctionTerm("self", null, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
      }
      else
      {
        Term arg = Utility.createStringT(agentName, termsPack, domainsFactory);
        TupleTerm agentArg = Utility.createSingle(arg, termsPack, defPack, header.getSignature());
        //assert agentArg.getTerms().size() == agentArg.getArity();
        if ((agent_funT = Utility.createFunctionTerm("getAgent", agentArg, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
      }
      //insert the functionTerm created as first element of tupleT
      if (tupleT == null)
      { //create a new TupleTerm for the FunctionTerm
        tupleT = Utility.createSingle(agent_funT, termsPack, defPack, header.getSignature());
        //assert tupleT.getTerms().size() == tupleT.getArity();      }
      else tupleT.getTerms().add(0, agent_funT);
    }
    if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) 
    	throw new ParseException("Problems in creating Function Term (" + funcName + ")");
    Logger.logDebug("\t\t\tFunctionTerm end, D=" + t.getDomain().getName());
    return t;
  }
}

LocationTerm LocationTerm(HashMap localVar, boolean areAllowedNewVar) :
{
  String funcName;
  TupleTerm tupleT = null;
  String agentName = null;
  LocationTerm t;
}
{
  {
    Logger.logDebug("\t");
  }
  [
    LOOKAHEAD(2)
    agentName = ID_AGENT() "."
    {
      Logger.logDebug(agentName + ".");
    }
  ]
  funcName = ID_FUNCTION()
  {
    Logger.logDebug("\t" + funcName + "\t\tLocationTerm beginning");
  }
  [ tupleT = TupleTerm(localVar, areAllowedNewVar) ]
  {
    if (agentName != null)
    { //create a new functionTerm representing the agent
      FunctionTerm agent_funT;
      if (agentName.equals("self"))
      {
        if ((agent_funT = Utility.createFunctionTerm("self", null, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
      }
      else
      {
        Term arg = Utility.createStringT(agentName, termsPack, domainsFactory);
        TupleTerm agentArg = Utility.createPair(arg, null, termsPack, defPack, header.getSignature());
        if ((agent_funT = Utility.createFunctionTerm("getAgent", agentArg, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException("Error at ");
      }
      //insert the functionTerm created as first element of tupleT
      if (tupleT == null)
      { //create a new TupleTerm for the FunctionTerm
        tupleT = Utility.createPair(agent_funT, null, termsPack, defPack, header.getSignature());
      }
      else tupleT.getTerms().add(0, agent_funT);
    }
    FunctionTerm f = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());
    t = (LocationTerm) f;
    if (t == null) throw new ParseException("Problems in creating Location Term ("+ funcName + ")");
    Logger.logDebug("\t\t\tLocationTerm end, TD=" + t.getDomain().getName());
    return t;
  }
}

/** reads a variable term v:
* if v is not in localVar and not areAllowedNewVar parseException
* if v is not in localVar and areAllowedNewVar then builds new variable
* if v is in localVar then insert it in localVar and return that variable
*/
VariableTerm VariableTerm(HashMap < String, VariableTerm > localVar, boolean areAllowedNewVar) :
{
  String name;
  VariableKind kind = VariableKind.LOGICAL_VAR; //Initially new created variableTerm have kind=logical
}
{
  name = ID_VARIABLE()
  {
    VariableTerm variable = (VariableTerm) localVar.get(name);
    if (!areAllowedNewVar && variable == null) throw new ParseException("Error: The definition of new variable is not allowed and " + name + " variable occurs for the first time");
    if (variable == null) //create a new variable
    { //create the object
      variable = termsPack.getBasicTerms().createVariableTerm(name, kind);
      //add this new variable to the localVar HashMap
      localVar.put(name, variable);
      //set TypeDomain
      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);
      if (anyDomain == null) throw new ParseException("Error: The AnyDomain is not defined");
      variable.setDomain(anyDomain);
    } //else use the variable found in the HashMap
    //OCL constraints are granted for construction.
    //The variable associations are set through the updateVariable() method invoked by the construct that use the variable
    Logger.logDebug("\t" + name + "\t\tVariableTerm, D=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    return variable;
  }
}

ConstantTerm ConstantTerm() :
{
  ConstantTerm t;
}
{
  (
    LOOKAHEAD(ComplexTerm())
    t = ComplexTerm()
  | LOOKAHEAD(RealTerm())
    t = RealTerm()
  | t = IntegerTerm()
  | t = NaturalTerm()
  | t = CharTerm()
  | t = StringTerm()
  | t = BooleanTerm()
  | t = UndefTerm()
  | t = EnumTerm()
  )
  {
    return t;
  }
}

ComplexTerm ComplexTerm() :
{
  Token t;
  String symbol;
}
{
  t = < COMPLEX_NUMBER > //a complex number is written like 2+i4 (without white spaces)
  {
    symbol = t.image;
    //create the object
    ComplexTerm term = termsPack.getFurtherTerms().createComplexTerm();
    // set the symbol
    term.setSymbol(symbol);
    //look for the Complex domain reference
    BasicTd complexDom = Utility.getBasicDomain(domainsFactory, "Complex");
    //set the reference
    term.setDomain(complexDom);
    //constraint 1 is granted for construction
    Logger.logDebug("\t" + term.getSymbol() + "\t\tComplexTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

RealTerm RealTerm() :
{
  Token t;
  String symbol = "";
}
{
  //((t="+"|t="-")          {symbol = symbol.concat(t.image);} )?
  (t = < REAL_NUMBER >)
  {
    symbol = symbol.concat(t.image);
    //create the object
    RealTerm term = termsPack.getFurtherTerms().createRealTerm();
    term.setSymbol(symbol);
    //look for the Real domain reference in the predefined_Dom HashMap
    TypeDomain dom = Utility.getBasicDomain(domainsFactory, "Real");
    if (dom == null)
    {
      throw new ParseException("Error: The Real domain is not defined");
    }
    //set references
    term.setDomain(dom);
    //constraint 1 is granted for construction
    Logger.logDebug("\t" + term.getSymbol() + "\t\tRealTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

IntegerTerm IntegerTerm() :
{
  Token t;
  String symbol = "";
}
{
  //(t ="+"|t ="-"){symbol = symbol.concat(t.image);}
  t = < NUMBER >
  {
    symbol = symbol.concat(t.image);
    //create the object
    IntegerTerm term = termsPack.getFurtherTerms().createIntegerTerm();
    term.setSymbol(symbol);
    //look for the Integer domain reference in the predefined_Dom HashMap
    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, "Integer");
    if (dom == null)
    {
      throw new ParseException("Error: The Integer domain is not defined");
    }
    //set references
    term.setDomain(dom);
    //constraint 1 is granted for construction
    Logger.logDebug("\t" + term.getSymbol() + "\t\tIntegerTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

NaturalTerm NaturalTerm() :
{
  Token t;
  String symbol;
}
{
  t = < NATNUMBER >
  {
    symbol = t.image;
    //create the object
    NaturalTerm term = termsPack.getFurtherTerms().createNaturalTerm();
    term.setSymbol(symbol);
    //look for the Natural domain reference in the predefined_Dom HashMap
    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, "Natural");
    if (dom == null)
    {
      throw new ParseException("Error: The Natural domain is not defined");
    }
    //set references
    term.setDomain(dom);
    //constraint 1 is granted for construction
    Logger.logDebug("\t" + term.getSymbol() + "\t\tNaturalTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

CharTerm CharTerm() :
{
  Token t;
  String symbol;
}
{
  t = < CHAR_LITERAL >
  {
    symbol = t.image;
    //create the object
    CharTerm term = termsPack.getFurtherTerms().createCharTerm();
    term.setSymbol(symbol);
    //look for the char domain reference in the predefined_Dom HashMap
    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, "Char");
    if (dom == null)
    {
      throw new ParseException("Error: The Char domain is not defined");
    }
    //set references
    term.setDomain(dom);
    //constraint 1 is granted for construction
    Logger.logDebug("\t" + term.getSymbol() + "\t\tCharTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

StringTerm StringTerm() :
{
  Token t;
  String symbol;
}
{
  t = < STRING_LITERAL >
  {
    //PA 2018/07/25
    //Con l'istruzione symbol = t.image; le stringhe sono
    //ritornate con le virgolette.
    //symbol = t.image;
    //Con l'istruzione qui sotto commentata le virgolette
    //sono rimosse. E' meglio averle le virgolette, o non averle? 
    symbol = t.image.substring(1, t.image.length() - 1);
    StringTerm term = Utility.createStringT(symbol, termsPack, domainsFactory);
    if (term == null) throw new ParseException("Error: The Char domain is not defined");
    Logger.logDebug("\t" + term.getSymbol() + "\t\tStringTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

BooleanTerm BooleanTerm() :
{
  Token t;
  String symbol;
}
{
  (
    t = < TRUE >
  | t = < FALSE >
  )
  {
    symbol = t.image;
    BooleanTerm term = termsPack.getBasicTerms().createBooleanTerm(Boolean.parseBoolean(symbol));
    //look for the boolean domain reference in the predefined_Dom HashMap
    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, "Boolean");
    if (dom == null)
    {
      throw new ParseException("Error: The Boolean domain is not defined.");
    }
    //set references
    term.setDomain(dom);
    //constraint 1 is granted for construction
    Logger.logDebug("\t" + term.getSymbol() + "\t\tBooleanTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

UndefTerm UndefTerm() :
{
  Token t;
  String symbol;
}
{
  t = < UNDEF >
  {
    Logger.logDebug("match:UndefTerm");
    symbol = t.image;
    UndefTerm term = termsPack.getBasicTerms().createUndefTerm();
    term.setSymbol(symbol);
    //look for the Undef domain reference in the predefined_Dom HashMap
    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, "Undef");
    if (dom == null)
    {
      throw new ParseException("Error: The Undef domain is not defined");
    }
    //set references
    term.setDomain(dom);
    //constraint 1 is granted for construction
    Logger.logDebug("\t" + term.getSymbol() + "\t\tUndefTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

EnumTerm EnumTerm() :
{
  String symbol;
}
{
  symbol = ID_ENUM()
  { //look for the enumTerm symbol in the enumElem HashMap to obtain the enumeration type-domain to which the enum term is associated.
    TypeDomain dom = (TypeDomain) enumElem.get(symbol);
    if (dom == null)
    {
      throw new ParseException("Error: The enumeration element " + symbol + " is not defined.");
    }
    //create the object
    EnumTerm term = termsPack.getFurtherTerms().createEnumTerm();
    term.setSymbol(symbol);
    //set references
    term.setDomain(dom);
    //constraint 1 and 2 are granted for construction
    Logger.logDebug("\t" + term.getSymbol() + "\t\tEnumTerm, TD=" + term.getDomain().getName());
    return term;
  }
}

ExtendedTerm ExtendedTerm(HashMap localVar, boolean areAllowedNewVar, RuleDeclaration c, Domain expDom) :
{
  ExtendedTerm t;
}
{
  (
    t = ConditionalTerm(localVar)
  | t = CaseTerm(localVar)
  | LOOKAHEAD(2) //to solve the conflict with the finite quantification terms  (exist... | existUnique... |forall... )
    t = TupleTerm(localVar, areAllowedNewVar)
    //| LOOKAHEAD(<LET>|"("|( ("{"|"["|"<")Term()("|"|("->" Term() "|")) )) //CHANGED! (new notation for comprehension terms)
  | LOOKAHEAD(< LET >
  | "("
  | (("{"
  | "["
  | "<") VariableTerm() < IN > Term() ("," VariableTerm() < IN > Term())* ("|" Term())? ":" //Comprehension terms
    //("|"|("->" Term() "|")) map comprehension term
    ))t = VariableBindingTerm(localVar)
  | t = CollectionTerm(localVar, areAllowedNewVar)
  | t = RuleAsTerm(localVar, c, expDom)
  | t = DomainTerm()
  )
  {
    return t;
  }
}

ConditionalTerm ConditionalTerm(HashMap localVar) :
{
  Term thenT, elseT, guard;
}
{
  < IF >
  {
    Logger.logDebug("\tif\t\tConditionalTerm beginning");
  }
  guard = Term(localVar, false, null) < THEN >
  {
    Logger.logDebug("\tthen");
  }
  thenT = Term(localVar, false, null)
  {
    ConditionalTerm term = termsPack.getFurtherTerms().createConditionalTerm();
    //set references
    term.setGuard(guard);
    term.setThenTerm(thenT);
    //create associations
    //XX AConditionalTermGuard a_conditionalT_guard = termsPack.getFurtherTerms().getAConditionalTermGuard();
    //XX a_conditionalT_guard.add(term,guard);
    //XX AConditionalTermThenTerm a_conditionalT_thenT = termsPack.getFurtherTerms().getAConditionalTermThenTerm();
    //XX a_conditionalT_thenT.add(term,thenT);
  }
  [
    < ELSE >
    {
      Logger.logDebug("\telse");
    }
    elseT = Term(localVar, false, null) //omettere l'else clause equivale a specificare "else undef"
    { //set the reference
      term.setElseTerm(elseT);
      //set the association
      //XX AConditionalTermElseTerm a_conditionalT_elseT = termsPack.getFurtherTerms().getAConditionalTermElseTerm();
      //XX a_conditionalT_elseT.add(term,elseT);
    }
  ]
  < ENDIF >
  { //set TypeDomain with "then term" type domain
    TypeDomain td = OCL_Checker.getTypeDomain(thenT.getDomain());
    term.setDomain(td);
    //check OCL constraints
    if (!OCL_Checker.checkConditionalTerm(term))
    {
      Logger.logErr(OCL_Checker.getMsgErr());
      Logger.logErr("       At a conditional term.");
    }
    Logger.logDebug("\tendif\t\tConditionalTerm end, TD=" + term.getDomain().getName());
    return term;
  }
}

CaseTerm CaseTerm(HashMap localVar) :
{
  Term switchT, caseT, resT;
}
{
  < SWITCH >
  {
    Logger.logDebug("\tswitch\t\tCaseTerm beginning");
  }
  switchT = Term(localVar, false, null)
  {
    CaseTerm term = termsPack.getFurtherTerms().createCaseTerm();
    //set the reference
    term.setComparedTerm(switchT);
    List comparingList = term.getComparingTerm();
    List resultList = term.getResultTerms();
  }
  (
    < CASE >
    {
      Logger.logDebug("\tcase");
    }
    caseT = Term(localVar, false, null) ":"
    {
      Logger.logDebug("\t:");
    }
    resT = Term(localVar, false, null)
    { //set the reference
      comparingList.add(caseT);
      resultList.add(resT);
    }
  )+
  [
    < OTHERWISE >
    {
      Logger.logDebug("\totherwise");
    }
    resT = Term(localVar, false, null)
    { //set the reference
      term.setOtherwiseTerm(resT);
      //create associations
      //X ACaseTermOtherwiseTerm a_caseT_otherwiseT = termsPack.getFurtherTerms().getACaseTermOtherwiseTerm();
      //X a_caseT_otherwiseT.add(term,resT);
    }
  ]
  < END_SWITCH >
  { //set TypeDomain with either the type domain of the last case result term or the one of the otherwise term (if it exist)
    TypeDomain td = OCL_Checker.getTypeDomain(resT.getDomain());
    term.setDomain(td);
    //check OCL constraints
    //constraint 1 is granted for construction
    //check constraints 2-3
    // to be improved
    if (!OCL_Checker.checkCaseTerm(term))
    {
      Logger.logErr(OCL_Checker.getMsgErr());
      Logger.logErr("       At a case term");
      throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a case term");
    }
    Logger.logDebug("\tendswitch\t\tCaseTerm end, TD=" + term.getDomain().getName());
    return term;
  }
}

TupleTerm TupleTerm(HashMap localVar, boolean areAllowedNewVar) : //possono avere natura mista, non ci puo' essere il tupleterm vuoto
{
  int arity;
  Term t;
}
{
  "("
  {
    Logger.logDebug("\t(\t\tTupleTerm beginning");
    //create the object
    TupleTerm term = termsPack.getBasicTerms().createTupleTerm();
    //List < Term > elemList = term.getTerms();//PA: 2018/01/08
    List < Term > elemList = new ArrayList < Term > (); //PA: 2018/01/08    List < Domain > prodDomList = new LinkedList < Domain > ();
  }
  t = Term(localVar, areAllowedNewVar, null)
  {
    //add the element to the terms list
    elemList.add(t);
    //add this domain to the domain list
    prodDomList.add(t.getDomain());
    //check constraint 1 (check elements type)
    if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a tuple term");
  }
  (
    "," t = Term(localVar, areAllowedNewVar, null)
    { //add a new element to the terms list
      elemList.add(t);
      //add this type domain to the domain list
      prodDomList.add(t.getDomain());
      //check constraint 1 (check elements type)
      if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a tuple term");
    }
  )*
  ")"
  {
    //set the tuple arity
    arity = elemList.size();
    term.setArity(arity);
    term.getTerms().addAll(elemList); //PA: 2018/01/08    //set the tuple TypeDomain
    Domain dom;
    if (arity == 1)  //the domain associated to the tuple term must be equal to the one associated to its unique term
    dom = ((Term) elemList.get(0)).getDomain();
    else //the type-domain associated to the tuple term must be a Cartesian product domain
    dom = Utility.getProduct(prodDomList, defPack, header.getSignature());
    term.setDomain(dom);
    //OCL constraints 2-3 granted for construction
    {
      Logger.logDebug("\t)\t\tTupleTerm end, arity=" + term.getArity() + ", TD=" + term.getDomain().getName());
    }
    OCL_Checker.checkTupleTerm(term);
    return term;
  }
}

CollectionTerm CollectionTerm(HashMap localVar, boolean areAllowedNewVar) :
{
  CollectionTerm t;
}
{
  (
    t = SequenceTerm(localVar, areAllowedNewVar)
  | LOOKAHEAD("{" ((Term() "->")
  | "->")) //{->} stands for the empty map
    t = MapTerm(localVar, areAllowedNewVar)
  | t = SetTerm(localVar, areAllowedNewVar)
  | t = BagTerm(localVar, areAllowedNewVar)
  )
  {
    return t;
  }
}

/* A collection of zero or more elements of the same nature which have an order and may be duplicated
For example, Sequence{?one?, ?table?, ?one?} and Sequence{?one?, ?one?, ?table?} are different sequences over the string domain.
*/
SequenceTerm SequenceTerm(HashMap localVar, boolean areAllowedNewVar) :
{
  int size;
  Term elem, firstElem, lastElem;
  Token tok;
  double step = 1;
  boolean natural_step = true;
}
{
  "["
  {
    Logger.logDebug("\t[\t\tSequenceTerm beginning");
  }
  { //create the object
    SequenceTerm term = termsPack.getFurtherTerms().createSequenceTerm();
    List < Term > elemList = term.getTerms();
  }
  [
    firstElem = Term(localVar, areAllowedNewVar, null)
    { //add a new element to the terms list
      elemList.add(firstElem);
      //constraint 3
      if (!OCL_Checker.termAccepted(firstElem)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a SequenceTerm.");
    }
    [
      (
        "," elem = Term(localVar, areAllowedNewVar, null) //esplicit sequence of elements
        { //add a new element to the terms list
          elemList.add(elem);
          //constraint 3
          if (!OCL_Checker.termAccepted(elem)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a SequenceTerm.");
        }
      )+
    |
      (
        ":"
        {
          Logger.logDebug("\t:");
        } //Interval notation
        lastElem = Term(localVar, areAllowedNewVar, null)
        [
          ","
          (
            elem = Term(localVar, areAllowedNewVar, null)
          ) //reading step, by default step = 1
          {
            if (!(elem.getDomain() instanceof IntegerDomain)) natural_step = false;
            step = Utility.convertToDouble(elem);
            Logger.logDebug("\t" + step + "\t\tinterval step");
            if (step <= 0) throw new ParseException("The step must be a positive number." + "\n       At a sequenceTerm.");
          }
        ]
      )
      {
        Utility.createTermCollection(firstElem, lastElem, elemList, step, natural_step, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());
      } //End Interval notation
    ]
  ]
  "]"
  {
    //set the size
    size = elemList.size();
    term.setSize(size);
    //set the TypeDomain
    TypeDomain elemTD;
    if (size == 0) //empty collection
    {
      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);
      if (anyDomain == null) throw new ParseException("Error: The genric Anydomain is not defined");
      elemTD = anyDomain;
    }
    else
    {
      elemTD = Utility.getCommonTD(elemList);
      if (elemTD == null) throw new ParseException("Error: every element of a sequence must have the same type-domain.\n");
    }
    Logger.logDebug("Common type-domain: " + elemTD.getName());
    SequenceDomain seqDom = Utility.getSequence(elemTD, defPack, header.getSignature());
    //set seqDom as the sequence TypeDomain
    term.setDomain(seqDom);
    // ocl constraints 1 and 2 granted for construction
    Logger.logDebug("\t]\t\tSequenceTerm end, size=" + term.getSize() + ", TD=" + term.getDomain().getName());
    return term;
  }
}

//A collection of zero or more elements of the same nature which have no order and cannot be duplicated
SetTerm SetTerm(HashMap localVar, boolean areAllowedNewVar) :
{
  int size;
  Term elem, firstElem, lastElem;
  Token tok;
  double step = 1;
  boolean natural_step = true;
}
{
  "{"
  {
    Logger.logDebug("\t{\t\tSetTerm beginning");
  }
  { //create the object
    SetTerm term = termsPack.getBasicTerms().createSetTerm();
    //X ASetTermTerm a_SetTerm_Term = termsPack.getBasicTerms().getASetTermTerm();
    Collection elemColl = term.getTerm();
  }
  [
    firstElem = Term(localVar, areAllowedNewVar, null)
    {
      //constraint 3
      if (!OCL_Checker.termAccepted(firstElem)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a SetTerm.");
      //add a new element to the terms list
      elemColl.add(firstElem);
      //add a new association
      //X a_SetTerm_Term.add(term,firstElem);
      //??? In this parser it is created a new term for every used symbol (number,char,string,boolean,ecc...)
      //So every term is a different object and two terms with the same value are inserted in the collection twice.
      //create an HashMap containing set elements and check if an element is duplicated
      HashMap insertedElem = new HashMap();
      String key = Utility.appendInKey(new StringBuffer(), firstElem).toString();
      insertedElem.put(new Integer(key.hashCode()), key);
    }
    [
      (
        "," elem = Term(localVar, areAllowedNewVar, null) //An explicit set
        {
          //constraint 3
          if (!OCL_Checker.termAccepted(elem)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a SetTerm.");
          //add a new element to the term list
          elemColl.add(elem);
          //add a new association
          //X a_SetTerm_Term.add(term,elem);
          //check if the element is duplicated
          key = Utility.appendInKey(new StringBuffer(), elem).toString();
          if (insertedElem.containsKey(new Integer(key.hashCode()))) throw new ParseException("Error: Duplicates are not allowed in a set. " + key + " is present twice.");
          insertedElem.put(new Integer(key.hashCode()), key);
        }
      )+
    |
      (
        ":"
        {
          Logger.logDebug("\t:");
        } //Interval notation
        lastElem = Term(localVar, areAllowedNewVar, null)
        [
          ","
          (
            elem = Term(localVar, areAllowedNewVar, null)
          ) //reading step, by default step = 1
          {
            if (!(elem.getDomain() instanceof IntegerDomain)) natural_step = false;
            step = Utility.convertToDouble(elem);
            Logger.logDebug("\t" + step + "\t\tinterval step");
            if (step <= 0) throw new ParseException("The step must be a positive number." + "\n       At a SetTerm.");
          }
        ]
      )
      {
        Utility.createTermCollection(firstElem, lastElem, elemColl, step, natural_step, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());
      } //End Interval notation
    ]
  ]
  "}"
  { //set the size
    size = elemColl.size();
    term.setSize(size);
    //set the TypeDomain
    TypeDomain elemTD;
    if (size == 0) //empty collection
    {
      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);
      if (anyDomain == null) throw new ParseException("Error: The generic Anydomain is not defined");
      elemTD = anyDomain;
    }
    else
    {
      elemTD = Utility.getCommonTD(elemColl);
      if (elemTD == null) throw new ParseException("Error: every element of a set must have the same type-domain.\n");
    }
    PowersetDomain setDom = Utility.getPowerset(elemTD, defPack, header.getSignature());
    //set setDom as the set TypeDomain
    term.setDomain(setDom);
    // ocl constraints 1 and 2 granted for construction
    Logger.logDebug("\t}\t\tSetTerm end, size=" + term.getSize() + ", TD=" + term.getDomain().getName());
    return term;
  }
}

/*A collection of zero or more associations which have no order and cannot be duplicated,
like Map{t1 -> s1, . . ., tn -> sn} where t1, . . ., tn are terms of the same nature, and so s1, . . ., sn.
*/
MapTerm MapTerm(HashMap localVar, boolean areAllowedNewVar) :
{
  Term elem1, elem2;
  TypeDomain sourceTD = null;
  TypeDomain targetTD = null;
}
{
  "{"
  {
    Logger.logDebug("\t{\t\tMapTerm beginning");
  }
  { //create the object
    MapTerm term = termsPack.getFurtherTerms().createMapTerm();
    //AMapTermPair a_MapTerm_Pair = termsPack.getFurtherTerms().getAMapTermPair();
    Collection pairColl = term.getPair();
  }
  (
    "->"
    {
      Logger.logDebug("\t->");
    }
  |
    (
      elem1 = Term(localVar, areAllowedNewVar, null) "->"
      {
        Logger.logDebug("\t->");
      }
      elem2 = Term(localVar, areAllowedNewVar, null)
      { //create a new pair
        TupleTerm pair = Utility.createPair(elem1, elem2, termsPack, defPack, header.getSignature());
        //add a new element to the terms list
        pairColl.add(pair);
        //add a new association
        //a_MapTerm_Pair.add(term,pair);
        sourceTD = OCL_Checker.getTypeDomain(elem1.getDomain());
        targetTD = OCL_Checker.getTypeDomain(elem2.getDomain());
        //In this parser it is created a new term for every used symbol (number,char,string,boolean,ecc...)
        //So every term is a different object and two equals pair are inserted in the collection twice
        //create an HashMap containing pairs and check if a pair is duplicated
        HashMap insertedPair = new HashMap();
        StringBuffer key = Utility.appendInKey(new StringBuffer(), elem1);
        key.append("->");
        Utility.appendInKey(key, elem2);
        // TODO: elimina l'uso di String o la conversione
        insertedPair.put(new Integer(key.toString().hashCode()), key.toString());
      }
      (
        "," elem1 = Term(localVar, areAllowedNewVar, null) "->"
        {
          Logger.logDebug("\t->");
        }
        elem2 = Term(localVar, areAllowedNewVar, null)
        { //create a new pair
          pair = Utility.createPair(elem1, elem2, termsPack, defPack, header.getSignature());
          //add a new element to the terms list
          pairColl.add(pair);
          //add a new association
          //a_MapTerm_Pair.add(term,pair);
          //check typeDomain of this pair
          if (!OCL_Checker.compatible(sourceTD, elem1.getDomain())) throw new ParseException("Error: every pair of a map must be compatible with the type-domain for the first pair element. \n" + "domain of the first element of the first pair: " + sourceTD.getName() + "  domain of another pair: " + elem1.getDomain().getName());
          if (!OCL_Checker.compatible(targetTD, elem2.getDomain())) throw new ParseException("Error: every pair of a map must be compatible with the type-domain for the second pair element. ");
          //check if a pair is duplicated
          key = Utility.appendInKey(new StringBuffer(), elem1);
          key.append("->");
          Utility.appendInKey(key, elem2);
          // TODO : eliminare conversione a String
          if (insertedPair.containsKey(new Integer(key.toString().hashCode())))
          {
            Logger.logWarning("Warning: Duplicate pairs are not allowed in a map. " + key + " is present twice.");
          }
          insertedPair.put(new Integer(key.hashCode()), key);
        }
      )*
    )
  )
  "}"
  { //set the size
    int size = pairColl.size();
    term.setSize(size);
    //set the TypeDomain when map size is 0
    if (size == 0) //empty collection
    {
      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);
      if (anyDomain == null) throw new ParseException("Error: The Anydomain is not defined");
      sourceTD = targetTD = anyDomain;
    }
    MapDomain mapDom = Utility.getMap(sourceTD, targetTD, defPack, header.getSignature());
    //set setDom as the set TypeDomain
    term.setDomain(mapDom);
    //OCL constraints 1,2 and 3 are granted for construction
    Logger.logDebug("\t}\t\tMapTerm end, size=" + term.getSize() + ", TD=" + term.getDomain().getName());
    return term;
  }
}

//A collection of zero or more elements of the same nature which have no order and may be duplicated
BagTerm BagTerm(HashMap localVar, boolean areAllowedNewVar) :
{
  int size;
  Term elem, firstElem, lastElem;
  Token tok;
  double step = 1;
  boolean natural_step = true;
}
{
  "<"
  {
    Logger.logDebug("\t<\t\tBagTerm beginning");
  }
  { //create the object
    BagTerm term = termsPack.getFurtherTerms().createBagTerm();
    //XX ABagTermTerm a_BagTerm_Term = termsPack.getFurtherTerms().getABagTermTerm();
    Collection elemColl = term.getTerm();
  }
  [
    firstElem = Term(localVar, areAllowedNewVar, null)
    { //add a new element to the terms list
      elemColl.add(firstElem);
      //add a new association
      //XX  a_BagTerm_Term.add(firstElem,term);
      //constraint 3
      if (!OCL_Checker.termAccepted(firstElem)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a BagTerm.");
    }
    [
      (
        "," elem = Term(localVar, areAllowedNewVar, null) //esplicit bag of elements
        { //add a new element to the terms list
          elemColl.add(elem);
          //add a new association
          //XX a_BagTerm_Term.add(elem,term);
          //constraint 3
          if (!OCL_Checker.termAccepted(elem)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a BagTerm.");
        }
      )+
    |
      (
        ":"
        {
          Logger.logDebug("\t:");
        } //Interval notation
        lastElem = Term(localVar, areAllowedNewVar, null)
        [
          ","
          (
            elem = Term(localVar, areAllowedNewVar, null)
          ) //reading step, by default step = 1
          {
            if (!(elem.getDomain() instanceof IntegerDomain)) natural_step = false;
            step = Utility.convertToDouble(elem);
            Logger.logDebug("\t" + step + "\t\tinterval step");
            if (step <= 0) throw new ParseException("The step must be a positive number." + "\n       At a sequenceTerm.");
          }
        ]
      )
      {
        Utility.createTermCollection(firstElem, lastElem, elemColl, step, natural_step, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());
      } //End Interval notation
    ]
  ]
  ">"
  { //set the bag size
    size = elemColl.size();
    term.setSize(size);
    //set the TypeDomain
    TypeDomain elemTD;
    if (size == 0) //empty collection
    {
      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);
      if (anyDomain == null) throw new ParseException("Error: The AnyDomain is not defined");
      elemTD = anyDomain;
    }
    else
    {
      elemTD = Utility.getCommonTD(elemColl);
      if (elemTD == null) throw new ParseException("Error: every element of a bag must have the same type-domain.\n");
    }
    BagDomain bagDom = Utility.getBag(elemTD, defPack, header.getSignature());
    //set bagDom as the bag TypeDomain
    term.setDomain(bagDom);
    // ocl constraints 1 and 2 granted for construction
    Logger.logDebug("\t>\t\tBagTerm end, size=" + term.getSize() + ", TD=" + term.getDomain().getName());
    return term;
  }
}

VariableBindingTerm VariableBindingTerm(HashMap localVar) :
{
  VariableBindingTerm t;
}
{
  (
    t = LetTerm(localVar)
  | t = FiniteQuantificationTerm(localVar)
  | t = ComprehensionTerm(localVar)
  )
  {
    return t;
  }
}

FiniteQuantificationTerm FiniteQuantificationTerm(HashMap localVar) :
{
  FiniteQuantificationTerm t;
}
{
  (
    LOOKAHEAD("(" < FORALL >)
    t = ForallTerm(localVar)
  | LOOKAHEAD("(" < EXIST > < UNIQUE >)
    t = ExistUniqueTerm(localVar)
  | t = ExistTerm(localVar)
  )
  { //check OCL constraints
    //(OCL constraint 1)set TypeDomain
    //look for the boolean domain reference in the predefined_Dom HashMap
    TypeDomain td = Utility.getBasicDomain(domainsFactory, "Boolean");
    if (td == null) throw new ParseException("\nError: The Boolean domain has not been declared.");
    //set the reference
    t.setDomain(td);
    //(constrains 4) check if the guard has a Boolen domain as associated TypeDomain
    if ((t.getGuard() != null) && !OCL_Checker.isBoolean(t.getGuard()))
    {
      Logger.logErr("\nError: The type-domain of terms after \"with\" must be the boolean domain\n        At a Finite-Quantification term\n");
    }
    Logger.logDebug(", TD=Boolean");
    return t;
  }
}

//NEW by Patrizia Added ranges
ExistTerm ExistTerm(HashMap localVar) :
{
  VariableTerm variable;
  Term inTerm, guard;
}
{
  "(" < EXIST >
  {
    Logger.logDebug("\t(exist\t\tExistTerm beginning");
    ExistTerm term = termsPack.getFurtherTerms().createExistTerm();
    List < Term > rangeList = term.getRanges();
    //check if the next variable is already used (look for it in the localVar HashMap)
    String nextVar = getToken(1).image;
    if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ExistTerm. It is already used.");
  }
  variable = VariableTerm(localVar, true) < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, null)
  { //set the reference to the variable
    Collection variableList = term.getVariable();
    variableList.add(variable);
    //check constraint 2 of superclass(part of it is granted for construction)
    if (!(OCL_Checker.getTypeDomain(inTerm.getDomain()) instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be the power set domain \n" + "       At an ExistTerm");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    rangeList.add(inTerm);
  }
  (
    ","
    { //check if the next variable is already used (look for it in the localVar HashMap)
      nextVar = getToken(1).image;
      if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ExistTerm. It is already used.");
    }
    variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, null)
    { //set the reference to the variable
      variableList.add(variable);
      //create the association
      //X a_FinQuantT_Var.add(variable,term);
      //check constraint 2 of superclass(part of it is granted for construction)
      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At an ExistTerm");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      rangeList.add(inTerm);
    }
  )*
  [
    < WITH >
    {
      Logger.logDebug("\twith");
    }
    guard = Term(localVar, false, null)
    { //set the reference
      term.setGuard(guard);
      //create associations
      //X AFiniteQuantificationTermGuard a_FinQuantT_Guard = termsPack.getFurtherTerms().getAFiniteQuantificationTermGuard();
      //X a_FinQuantT_Guard.add(guard,term);
    }
  ]
  ")"
  {
    Logger.logDebug("\t)\t\tExistTerm end");
  }
  {
    return term;
  }
}

//NEW by Patrizia Added ranges
ExistUniqueTerm ExistUniqueTerm(HashMap localVar) :
{
  VariableTerm variable;
  Term inTerm, guard;
}
{
  "(" < EXIST > < UNIQUE >
  {
    Logger.logDebug("\t(exist unique\t\tExistUniqueTerm beginning");
    ExistUniqueTerm term = termsPack.getFurtherTerms().createExistUniqueTerm();
    List < Term > rangeList = term.getRanges();
    //check if the next variable is already used (look for it in the localVar HashMap)
    String nextVar = getToken(1).image;
    if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ExistUniqueTerm. It is already used.");
  }
  variable = VariableTerm(localVar, true) < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, null)
  { //set the reference to the variable
    Collection variableList = term.getVariable();
    variableList.add(variable);
    //create the association
    //X AFiniteQuantificationTermVariable a_FinQuantT_Var = termsPack.getFurtherTerms().getAFiniteQuantificationTermVariable();
    //X a_FinQuantT_Var.add(variable,term);
    //check constraint 2 of superclass(part of it is granted for construction)
    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At an ExistUniqueTerm");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    rangeList.add(inTerm);
  }
  (
    ","
    { //check if the next variable is already used (look for it in the localVar HashMap)
      nextVar = getToken(1).image;
      if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ExistUniqueTerm. It is already used.");
    }
    variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, null)
    { //set the reference to the variable
      variableList.add(variable);
      //create the association
      //X a_FinQuantT_Var.add(variable,term);
      //check constraint 2 of superclass(part of it is granted for construction)
      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At an ExistUniqueTerm");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      rangeList.add(inTerm);
    }
  )*
  [
    < WITH >
    {
      Logger.logDebug("\twith");
    }
    guard = Term(localVar, false, null)
    { //set the reference
      term.setGuard(guard);
      //create associations
      //X AFiniteQuantificationTermGuard a_FinQuantT_Guard = termsPack.getFurtherTerms().getAFiniteQuantificationTermGuard();
      //X a_FinQuantT_Guard.add(guard,term);
    }
  ]
  ")"
  {
    Logger.logDebug("\t)\t\tExistUniqueTerm end");
  }
  {
    return term;
  }
}

//NEW by Patrizia Added ranges
ForallTerm ForallTerm(HashMap localVar) :
{
  VariableTerm variable;
  Term inTerm, guard;
}
{
  "(" < FORALL >
  {
    Logger.logDebug("\t(forall\t\tForallTerm beginning");
    ForallTerm term = termsPack.getFurtherTerms().createForallTerm();
    List < Term > rangeList = term.getRanges();
    //check if the next variable is already used (look for it in the localVar HashMap)
    String nextVar = getToken(1).image;
    if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ForallTerm. It is already used.");
  }
  variable = VariableTerm(localVar, true) < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, null)
  { //set the reference to the variable
    Collection variableList = term.getVariable();
    variableList.add(variable);
    //check constraint 2 of superclass(part of it is granted for construction)
    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At an ForallTerm");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    rangeList.add(inTerm);
  }
  (
    ","
    { //check if the next variable is already used (look for it in the localVar HashMap)
      nextVar = getToken(1).image;
      if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ForallTerm. It is already used.");
    }
    variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, null)
    { //set the reference to the variable
      variableList.add(variable);
      //check constraint 2 of superclass(part of it is granted for construction)
      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At an ForallTerm");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      rangeList.add(inTerm);
    }
  )*
  [
    < WITH >
    {
      Logger.logDebug("\twith");
    }
    guard = Term(localVar, false, null)
    { //set the reference
      term.setGuard(guard);
      //create associations
      //X AFiniteQuantificationTermGuard a_FinQuantT_Guard = termsPack.getFurtherTerms().getAFiniteQuantificationTermGuard();
      //X a_FinQuantT_Guard.add(guard,term);
    }
  ]
  ")"
  {
    Logger.logDebug("\t)\t\tForallTerm end");
  }
  {
    return term;
  }
}

LetTerm LetTerm(HashMap localVar) :
{
  VariableTerm variable;
  Term assignT, body;
}
{
  < LET > "("
  {
    Logger.logDebug("\tlet(\t\tLetTerm beginning");
  }
  { //check if the next variable is already used (look for it in the localVar HashMap)
    String nextVar = getToken(1).image;
    if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the LetTerm. It is already used.");
  }
  variable = VariableTerm(localVar, true) "="
  {
    Logger.logDebug("\t=");
  }
  assignT = Term(localVar, false, null)
  {
    LetTerm term = termsPack.getFurtherTerms().createLetTerm();
    List variableList = term.getVariable();
    List assignTList = term.getAssignmentTerm();
    //ALetTermVariable a_letT_Var = termsPack.getFurtherTerms().getALetTermVariable();
    //ALetTermAssignmentTerm a_letT_assignT = termsPack.getFurtherTerms().getALetTermAssignmentTerm();
    //set variable TypeDomain         
    // FIXME 1/4/2009 the domain can be a concrete domain, not only a type domain!
    Domain varTD = null;
    if (assignT.getDomain() instanceof ConcreteDomain)
    {
      varTD = assignT.getDomain();
    }
    else
    {
      varTD = OCL_Checker.getTypeDomain(assignT.getDomain());
    }
    variable.setDomain(varTD);
    //set variable kind
    if (varTD instanceof RuleDomain) variable.setKind(VariableKind.RULE_VAR);
    //set references
    variableList.add(variable);
    assignTList.add(assignT);
    //create associations
    //a_letT_Var.add(variable,term);
    //a_letT_assignT.add(term,assignT);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
  }
  (
    ","
    { //check if the next variable is already used (look for it in the localVar HashMap)
      nextVar = getToken(1).image;
      if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the LetTerm. It is already used.");
    }
    variable = VariableTerm(localVar, true) "="
    {
      Logger.logDebug("\t=");
    }
    assignT = Term(localVar, false, null)
    { // set variable TypeDomain
      //varTD = OCL_Checker.getTypeDomain(assignT.getDomain());
      varTD = null;
      if (assignT.getDomain() instanceof ConcreteDomain)
      {
        varTD = assignT.getDomain();
      }
      else
      {
        varTD = OCL_Checker.getTypeDomain(assignT.getDomain());
      }
      variable.setDomain(varTD);
      // set variable kind
      if (varTD instanceof RuleDomain) variable.setKind(VariableKind.RULE_VAR);
      //else kind=logicalVar (it has been setted when the variable term has been created)
      //set references
      variableList.add(variable);
      assignTList.add(assignT);
      //create associations
      //a_letT_Var.add(variable,term);
      //a_letT_assignT.add(term,assignT);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    }
  )*
  ")"
  {
    Logger.logDebug("\t)");
  }
  //nella docum non ci sono le parent
  < IN >
  {
    Logger.logDebug("\tin");
  }
  body = Term(localVar, false, null) < ENDLET >
  { //set the reference
    term.setBody(body);
    //create the association
    //XX ALetTermBody a_letT_body = termsPack.getFurtherTerms().getALetTermBody();
    //XX a_letT_body.add(term,body);
    //set LetTerm typeDomain
    TypeDomain td = OCL_Checker.getTypeDomain(body.getDomain());
    term.setDomain(td);
    //OCL constraint 1, 2, 3 granted for construction
    {
      Logger.logDebug("\tendlet\t\tLetTerm end, TD=" + term.getDomain().getName());
    }
    return term;
  }
}

ComprehensionTerm ComprehensionTerm(HashMap localVar) :
{
  ComprehensionTerm t;
}
{
  (
    LOOKAHEAD("{" VariableTerm() < IN > Term() ("," VariableTerm() < IN > Term())* ("|" Term())? ":" Term() "}")
    t = SetCT(localVar)
  | t = MapCT(localVar)
  | t = SequenceCT(localVar)
  | t = BagCT(localVar)
  )
  { //constraint 1 checked in the specific terms (SetCT, MapCT, SequenceCT, BagCT)
    //constraint 2 (check if the guard TypeDomain is the Boolean domain)
    if ((t.getGuard() != null) && (!OCL_Checker.isBoolean(t.getGuard())))
    {
      Logger.logErr("Error: The type-domain of terms after \"with\" must be the boolean domain\n        At a comprehension term\n");
    }
    return t;
  }
}

//NEW by Patrizia Added ranges.
SetCt SetCT(HashMap localVar) :
{
  Term t, inTerm, guard;
  VariableTerm variable;
  SetCt term = termsPack.getFurtherTerms().createSetCt();
  List < Term > rangeList = term.getRanges();
}
{
  "{"
  {
    Logger.logDebug("\t{\t\tSetCT beginning");
  }
  variable = VariableTerm(localVar, true)  //the new variable has already been created within the term t
  < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, null)
  { //if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
    if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException("Error: The variable " + variable.getName() + " cannot be used within the setCT. It is already used.");
    //set the reference to the variable
    Collection variableList = term.getVariable();
    variableList.add(variable);
    //create the association
    //X AComprehensionTermVariable a_Comp_Var = termsPack.getFurtherTerms().getAComprehensionTermVariable();
    //X a_Comp_Var.add(term,variable);
    //check constraint 2 (part of it is granted for construction)
    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At a SetCT");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    rangeList.add(inTerm);
  }
  (
    "," variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, null)
    { //if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
      if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException("Error: The variable " + variable.getName() + " cannot be used within the setCT. It is already used.");
      //set the reference to the variable
      variableList.add(variable);
      //create the association
      //X a_Comp_Var.add(term,variable);
      //check constraint 2 (part of it is granted for construction)
      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At a SetCT");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      rangeList.add(inTerm);
    }
  )*
  [
    "|"
    {
      Logger.logDebug("\t|");
    }
    guard = Term(localVar, false, null)
    { //set the reference
      term.setGuard(guard);
      //set the association
      //X AComprehensionTermGuard a_Comp_Guard = termsPack.getFurtherTerms().getAComprehensionTermGuard();
      //X a_Comp_Guard.add(term,guard);
    }
  ]
  ":"
  {
    Logger.logDebug("\t:");
  }
  t = Term(localVar, false, null)
  {
    //set the reference
    term.setTerm(t);
    //set the association
    //X AComprehensionTermTerm a_Comp_Term = termsPack.getFurtherTerms().getAComprehensionTermTerm();
    //X a_Comp_Term.add(term,t);
    //check constraint 1 of the superclass (check elements type)
    if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a SetComprehensionTerm.\n");
  }
  "}"
  { // set TypeDomain
    TypeDomain td = Utility.getPowerset(OCL_Checker.getTypeDomain(t.getDomain()), defPack, header.getSignature());
    term.setDomain(td);
    //OCL constraint 1 granted for construction
    Logger.logDebug("\t}\t\tSetCT end, TD=" + term.getDomain().getName());
    return term;
  }
}

//NEW by Patrizia Added ranges.
MapCt MapCT(HashMap localVar) :
{
  Term t1, t2, inTerm, guard;
  VariableTerm variable;
  List < Term > rangeList = new ArrayList < Term > ();
  MapCt term = termsPack.getFurtherTerms().createMapCt(rangeList);
}
{
  "{"
  {
    Logger.logDebug("\t{\t\tMapCT beginning");
  }
  variable = VariableTerm(localVar, true)  //the new variable has already been created within the term pair
  < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, null)
  { //if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
    if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException("Error: The variable " + variable.getName() + " cannot be used within the mapCT. It is already used.");
    //set the reference to the variable
    Collection variableList = term.getVariable();
    variableList.add(variable);
    //create the association
    //X AComprehensionTermVariable a_Comp_Var = termsPack.getFurtherTerms().getAComprehensionTermVariable();
    //X a_Comp_Var.add(term,variable);
    //check constraint 3 (part of it is granted for construction)
    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At a MapCT");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    rangeList.add(inTerm);
  }
  (
    "," variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, null)
    { //if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
      if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException("Error: The variable " + variable.getName() + " cannot be used within the mapCT. It is already used.");
      //set the reference to the variable
      variableList.add(variable);
      //create the association
      //X a_Comp_Var.add(term,variable);
      //check constraint 3 (part of it is granted for construction)
      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At a MapCT");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      rangeList.add(inTerm);
    }
  )*
  [
    "|"
    {
      Logger.logDebug("\t|");
    }
    guard = Term(localVar, false, null)
    { //set the reference
      term.setGuard(guard);
      //set the association
      //X AComprehensionTermGuard a_Comp_Guard = termsPack.getFurtherTerms().getAComprehensionTermGuard();
      //X a_Comp_Guard.add(term,guard);
    }
  ]
  ":"
  {
    Logger.logDebug("\t:");
  }
  t1 = Term(localVar, false, null) "->"
  {
    Logger.logDebug("\t->");
  }
  t2 = Term(localVar, false, null) "|"
  {
    Logger.logDebug("\t|");
  }
  {
    //create a new pair
    TupleTerm pair = Utility.createPair(t1, t2, termsPack, defPack, header.getSignature());
    //set the reference
    term.setTerm(pair);
    //set the association
    //X AComprehensionTermTerm a_Comp_Term = termsPack.getFurtherTerms().getAComprehensionTermTerm();
    //X a_Comp_Term.add(term,pair);
  }
  "}"
  { // set TypeDomain
    TypeDomain td = Utility.getMap(OCL_Checker.getTypeDomain(t1.getDomain()), OCL_Checker.getTypeDomain(t2.getDomain()), defPack, header.getSignature());
    term.setDomain(td);
    //OCL constraints 1, 2 granted for construction
    Logger.logDebug("\t}\t\tMapCTend, TD=" + term.getDomain().getName());
    return term;
  }
}

SequenceCt SequenceCT(HashMap localVar) :
{
  //Notation  [D | P : E] where D are variable declarations, P is the property, E is the espression.
  //P is optional, if not present: [D : E]
  Term t, inTerm, guard;
  VariableTerm variable;
  SequenceCt term = termsPack.getFurtherTerms().createSequenceCt();
  List < Term > rangeList = term.getRanges();
}
{
  "["
  {
    Logger.logDebug("\t[\t\tSequenceCT beginning");
  }
  variable = VariableTerm(localVar, true)  //the new variable has not yet been created within the term t
  < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, null)
  { //if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
    if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException("Error: The variable " + variable.getName() + " cannot be used within the SequenceCT. It is already used.");
    //set the reference to the variable
    Collection variableList = term.getVariable();
    variableList.add(variable);
    //create the association
    //X AComprehensionTermVariable a_Comp_Var = termsPack.getFurtherTerms().getAComprehensionTermVariable();
    //X a_Comp_Var.add(term,variable);
    //check constraint 2 (part of it is granted for construction)
    if (!(inTerm.getDomain() instanceof SequenceDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a sequence domain \n" + "       At a SequenceCT");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    rangeList.add(inTerm);
  }
  (
    "," variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, null)
    { //if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
      if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException("Error: The variable " + variable.getName() + " cannot be used within the SequenceCT. It is already used.");
      //set the reference to the variable
      variableList.add(variable);
      //create the association
      //X a_Comp_Var.add(term,variable);
      //check constraint 2 (part of it is granted for construction)
      if (!(inTerm.getDomain() instanceof SequenceDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a sequence domain \n" + "       At a SequenceCT");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      rangeList.add(inTerm);
    }
  )*
  [
    "|"
    {
      Logger.logDebug("\t|");
    }
    guard = Term(localVar, false, null)
    { //set the reference
      term.setGuard(guard);
      //set the association
      //AComprehensionTermGuard a_Comp_Guard = termsPack.getFurtherTerms().getAComprehensionTermGuard();
      //a_Comp_Guard.add(term,guard);
    }
  ]
  ":"
  {
    Logger.logDebug("\t:");
  }
  t = Term(localVar, false, null)
  {
    //set the expression reference
    term.setTerm(t);
    //set the association
    //X AComprehensionTermTerm a_Comp_Term = termsPack.getFurtherTerms().getAComprehensionTermTerm();
    //X a_Comp_Term.add(term,t);
    //check constraint 1 of the superclass (check elements type)
    if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a sequence-comprehension term.\n");
  }
  "]"
  { // set TypeDomain
    TypeDomain td = Utility.getSequence(OCL_Checker.getTypeDomain(t.getDomain()), defPack, header.getSignature());
    term.setDomain(td);
    //OCL constraint 1 granted for construction
    Logger.logDebug("\t]\t\tSequenceCT end, TD=" + term.getDomain().getName());
    return term;
  }
}

//NEW by Patrizia Added ranges
BagCt BagCT(HashMap localVar) :
{
  Term t, inTerm, guard;
  VariableTerm variable;
  BagCt term = termsPack.getFurtherTerms().createBagCt();
  List < Term > rangeList = term.getRanges();
}
{
  "<"
  {
    Logger.logDebug("\t<\t\tBagCT beginning");
  }
  variable = VariableTerm(localVar, true)  //the new variable has not yet been created within the term t
  < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, null)
  { //if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
    if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException("Error: The variable " + variable.getName() + " cannot be used within the BagCT. It is already used.");
    //set the reference to the variable
    Collection variableList = term.getVariable();
    variableList.add(variable);
    //create the association
    //X AComprehensionTermVariable a_Comp_Var = termsPack.getFurtherTerms().getAComprehensionTermVariable();
    //X a_Comp_Var.add(term,variable);
    //check constraint 2 (part of it is granted for construction)
    if (!(inTerm.getDomain() instanceof BagDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a bag domain \n" + "       At a BagCT");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    rangeList.add(inTerm);
  }
  (
    "," variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, null)
    { //if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
      if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException("Error: The variable " + variable.getName() + " cannot be used within the BagCT. It is already used.");
      //set the reference to the variable
      variableList.add(variable);
      //create the association
      //X a_Comp_Var.add(term,variable);
      //check constraint 2 (part of it is granted for construction)
      if (!(inTerm.getDomain() instanceof BagDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a bag domain \n" + "       At a BagCT");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      rangeList.add(inTerm);
    }
  )*
  [
    "|"
    {
      Logger.logDebug("\t|");
    }
    guard = Term(localVar, false, null)
    { //set the reference
      term.setGuard(guard);
      //set the association
      //AComprehensionTermGuard a_Comp_Guard = termsPack.getFurtherTerms().getAComprehensionTermGuard();
      //a_Comp_Guard.add(term,guard);
    }
  ]
  ":"
  {
    Logger.logDebug("\t:");
  }
  t = Term(localVar, false, null)
  {
    //set the reference
    term.setTerm(t);
    //set the association
    //X AComprehensionTermTerm a_Comp_Term = termsPack.getFurtherTerms().getAComprehensionTermTerm();
    //X a_Comp_Term.add(term,t);
    //check constraint 1 of the superclass (check elements type)
    if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a bag-comprehension term.\n");
  }
  ">"
  { // set TypeDomain
    TypeDomain td = Utility.getBag(OCL_Checker.getTypeDomain(t.getDomain()), defPack, header.getSignature());
    term.setDomain(td);
    //OCL constraint 1 granted for construction
    Logger.logDebug("\t>\t\tBagCT end, TD=" + term.getDomain().getName());
    return term;
  }
}

DomainTerm DomainTerm() :
{
  Domain d;
}
{
  d = getDomainByID()
  { //create the object
    DomainTerm term = termsPack.getBasicTerms().createDomainTerm();
    //set references
    term.setDomain(d);
    //set the TypeDomain
    PowersetDomain powersetDom = Utility.getPowerset(d, defPack, header.getSignature());
    //set references
    term.setDomain(powersetDom);
    //OCL constraint 1 granted for construction
    Logger.logDebug("\t" + d.getName() + "\t\tDomainTerm, D=" + term.getDomain().getName());
    return term;
  }
}

/*
* modified 10 Jan 2008 by acarioni
*
*/
RuleAsTerm RuleAsTerm(HashMap localVar, RuleDeclaration c, Domain expDom) :
{
  RuleDeclaration r;
  Object [ ] dcl;
  String ruleName;
  List < Domain > ruleDomList;
}
{
  "<<"
  {
    Logger.logDebug("\t<<\t\tRuleAsTerm beginning");
  }
  // ruleName=ID_RULE()
  dcl = MacroDcl()
  {
    ruleName = (String) dcl [ 0 ];
    ruleDomList = (List < Domain >) dcl [ 1 ];
  }
  ">>"
  {
    Logger.logDebug("\t>>\t");
    RuleAsTerm term = termsPack.getBasicTerms().createRuleAsTerm();
    /* commented 10 Jan 2008 by acarioni
      //look for the Rule domain reference; it is created in case it does note yet exist
      // convert expDomn to RuleDomain
	  RuleDomain rDom = (RuleDomain) expDom;
      List<Domain> ruleDomList = null;
      if(rDom.getDomains()!=null){
            ruleDomList = new LinkedList();
      		for(Object o : rDom.getDomains()){
	  			Domain d = MDRConnector.toDomain(o);
				ruleDomList.add(d);
	  		}
      }
      */
    //look for the rule declaration in the rule HashMap
    r = Utility.getRuleByNameDom(declared_Rules, ruleName, ruleDomList);
    if (r == null)
    {
      throw new ParseException("ERROR: Unresolved reference to " + ruleName + Utility.toString(ruleDomList));
    }
    //set the rule reference
    term.setRule(r);
    RuleDomain dom = Utility.getRuleDomain(ruleDomList, defPack, header.getSignature());
    //set the domain reference
    term.setDomain(dom);
    Logger.logDebug("\tRuleAsTerm end, TD=" + dom.getName());
    return term;
  }
}

/*
* added 10 Jan 2008 by acarioni
*
* Returns a 2-value array containing a macro rule name and a list of domains
* as the formal parameter domains.
* It is used by RuleAsTerm.
*
*/
Object [ ] MacroDcl() :
{
  Logger.logDebug("begin - macro rule in RuleAsTerm");
  String ruleName;
  Domain inDom;
  List < Domain > domains = new ArrayList < Domain > ();
}
{
  ruleName = ID_RULE()
  {
    Logger.logDebug("\t" + ruleName);
  }
  [
    {
      Logger.logDebug("domains: ");
    }
    "(" inDom = getDomainByID()
    { //add it to the list
      domains.add(inDom);
      Logger.logDebug("\t" + inDom.getName());
    }
    (
      "," inDom = getDomainByID()
      { //add it to the list
        domains.add(inDom);
        Logger.logDebug("\t" + inDom.getName());
      }
    )*
    ")"
  ]
  {
    Logger.logDebug("end - macro rule in RuleAsTerm");
    return new Object [ ]
    {
      ruleName, domains
    }
    ;
  }
}

////////////////////////////////////// RULES ////////////////////////////////////////////
//OK! No derived rules
Rule Rule(HashMap localVar, RuleDeclaration c) :
{
  Rule r;
}
{
  (
    LOOKAHEAD(2)
    r = BasicRule(localVar, c)
  | r = TurboRule(localVar, c)
  | LOOKAHEAD((VariableTerm()
  | LocationTerm()) ":=")
    r = UpdateRule(localVar, c)
  | LOOKAHEAD((VariableTerm()
  | LocationTerm()) "<-")
    r = TurboReturnRule(localVar, c)
  | r = TermAsRule(localVar, c)
  | r = DerivedRule(localVar, c)
  )
  {
    return r;
  }
}

//OK!
TermAsRule TermAsRule(HashMap localVar, RuleDeclaration c) :
{
  Logger.logDebug("\t\t\tTermAsRule beginning");
  Term par, t = null;
  TermAsRule rule = rulesPack.getBasicTransitionRules().createTermAsRule();
  List < Term > actualParamList = rule.getParameters();
}
{
  (
    t = FunctionTerm(localVar, false)
  | t = VariableTerm(localVar, false)
  )
  [
    "["
    {
      Logger.logDebug("\t[");
    }
    par = Term(localVar, false, c)
    {
      actualParamList.add(par);
    }
    (
      "," par = Term(localVar, false, c)
      {
        actualParamList.add(par);
      }
    )*
    "]"
  ]
  {
    //set the references
    rule.setTerm(t);
    // check OCL constraint
    if (!OCL_Checker.checkTermAsRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At a RuleAsTerm");
    Logger.logDebug("\t\t\tTermAsRule end");
    return rule;
  }
}

Rule BasicRule(HashMap localVar, RuleDeclaration c) :
{
  Rule r;
}
{
  (
    r = SkipRule()
  | r = MacroCallRule(localVar, c)
  | r = BlockRule(localVar, c)
  | r = ConditionalRule(localVar, c)
  | r = ChooseRule(localVar, c)
  | r = ForallRule(localVar, c)
  | r = LetRule(localVar, c)
  | r = ExtendRule(localVar, c)
  )
  {
    return r;
  }
}

///////////////////////// BASIC RULES //////////////////////////////////////////
//OK!
SkipRule SkipRule() :
{
  SkipRule rule;
}
{
  < Skip >
  {
    Logger.logDebug("\tskip\t\tSkipRule");
    rule = rulesPack.getBasicTransitionRules().createSkipRule();
    return rule;
  }
}

/* build an updateRule*/
UpdateRule UpdateRule(HashMap localVar, RuleDeclaration c) :
{
  Term loc = null;
  Term updatingT;
}
{
  {
    Logger.logDebug("\t\t\tUpdateRule beginning");
    //create the object
    UpdateRule rule = rulesPack.getBasicTransitionRules().createUpdateRule();
  }
  (
    loc = LocationTerm(localVar, false) //only an occurrence of the variable
    { //set the reference to the location to be updated
      rule.setLocation(loc);
    }
  | loc = VariableTerm(localVar, false) //only an occurrence of the variable
    { //set the reference to the variable
      VariableTerm locVar = (VariableTerm) loc;
      rule.setLocation(locVar);
      // check and update the variable kind
      if (locVar.getKind() == VariableKind.LOGICAL_VAR)
      {
        locVar.setKind(VariableKind.LOCATION_VAR);
        Logger.logDebug("\t\t\t" + locVar.getName() + " updated: TD=" + locVar.getDomain().getName() + ", kind=" + locVar.getKind().toString());
      }
      else if (locVar.getKind() == VariableKind.RULE_VAR) throw new ParseException("Error: In an Updating rule, the variable to update must be a location variable, not a rule variable. ");
    }
  )
  ":="
  {
    Logger.logDebug("\t:=");
  }
  updatingT = TermForUpdateRule
  (
    localVar, false, c, loc.getDomain()
  )
  {
    assert updatingT != null;
    //set the references
    rule.setUpdatingTerm(updatingT);
    // OCL check R1
    //NEW by Patrizia to allow result:=... to pass constraint R1
    //****
    if (loc != null && (loc instanceof LocationTerm) && ((LocationTerm) loc).getFunction().getName().equals("result"))
    {
      rule.getLocation().setDomain(rule.getUpdatingTerm().getDomain());
      Logger.logDebug("\t\t\t Location term \"result\" updated: TD=" + rule.getUpdatingTerm().getDomain().getName());
    }
    //****
    if (!OCL_Checker.checkUpdateRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the application of the update-rule.\n" + c);
    Logger.logDebug("\t\t\tUpdateRule end");
    return rule;
  }
}

//OK (a parte controllare il metamodello)
BlockRule BlockRule(HashMap localVar, RuleDeclaration c) :
{
  Rule r;
}
{
  < PAR >
  {
    Logger.logDebug("\tpar\t\tBlockRule beginning");
    BlockRule rule = rulesPack.getBasicTransitionRules().createBlockRule();
    List < Rule > rulesList = rule.getRules();
  }
  r = Rule(localVar, c)
  { //set the reference
    rulesList.add(r);
  }
  (
    r = Rule(localVar, c)
    { //set the reference
      rulesList.add(r);
    }
  )+
  < ENDPAR >
  {
    Logger.logDebug("\tendpar\t\tBlockRule end\n");
    return rule;
  }
}

//OK!
ConditionalRule ConditionalRule(HashMap localVar, RuleDeclaration c) :
{
  Rule thenR, elseR;
  Term guard;
}
{
  < IF >
  {
    Logger.logDebug("\tif\t\tConditionalRule beginning");
  }
  guard = Term(localVar, false, c) < THEN >
  {
    Logger.logDebug("\tthen");
  }
  thenR = Rule(localVar, c)
  {
    ConditionalRule rule = rulesPack.getBasicTransitionRules().createConditionalRule();
    //set references
    rule.setGuard(guard);
    rule.setThenRule(thenR);
  }
  [
    < ELSE >
    {
      Logger.logDebug("\telse");
    }
    elseR = Rule(localVar, c) //omettere l'else clause equivale a specificare "else skip"
    { //set the reference
      rule.setElseRule(elseR);
    }
  ]
  < ENDIF >
  { //(OCL constraints 1) check if the guard TypeDomain is the Boolean domain
    if (!OCL_Checker.isBoolean(guard))
    {
      //PA 31 gen 2011. commentato logger ed introdotta ParseException
      //Logger.logErr("Error: In a conditional rule the type-domain associated to the term after \"if\" must be the Boolean domain.");
      throw new ParseException("Error: In a conditional rule the type-domain associated to the term after \"if\" must be the Boolean domain.");
    }
    Logger.logDebug("\tendif\t\tConditionalRule end");
    return rule;
  }
}

//NEW by Patrizia Added ranges. Please don't touch!
ChooseRule ChooseRule(HashMap localVar, RuleDeclaration c) :
{
  VariableTerm variable;
  Term inTerm, guard;
  Rule doRule, ifnone;
}
{
  < CHOOSE >
  {
    Logger.logDebug("\tchoose\t\tChooseRule beginning");
    ChooseRule rule = rulesPack.getBasicTransitionRules().createChooseRule();
    List < Term > rangeList = rule.getRanges();
    //check if the next variable is already used (look for it in the localVar HashMap)
    String nextVar = getToken(1).image;
    if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ChooseRule. It is already used.");
  }
  variable = VariableTerm(localVar, true) < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, c)
  { //set the reference to the variable
    Collection variableList = rule.getVariable();
    variableList.add(variable);
    //check constraint R7
    if (!(OCL_Checker.getTypeDomain(inTerm.getDomain()) instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At a ChooseRule");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: D=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    //set the reference to the variable range
    rangeList.add(inTerm);
    //Constraints R10, R8 granted for construction
  }
  (
    ","
    { //check if the next variable is already used (look for it in the localVar HashMap)
      nextVar = getToken(1).image;
      if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ChooseRule. It is already used.");
    }
    variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, c)
    { //set the reference to the variable
      variableList.add(variable);
      if (!(OCL_Checker.getTypeDomain(inTerm.getDomain()) instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At a ChooseRule");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      //set the reference to the variable range
      rangeList.add(inTerm);
      //Constraints R10, R8 granted for construction
    }
  )* 
  {
    //se la guardia non c'e', creiamo una guardia fittizia "true"
    guard = termsPack.getBasicTerms().createBooleanTerm(true);
  }
  [
    < WITH >
    {
      Logger.logDebug("\twith");
    }
    guard = Term(localVar, false, c)
    {
	      //Check constraint R9
	      if (!OCL_Checker.isBoolean(guard))
      {
		        Logger.logErr("Error: In a ChooseRule the type-domain associated to the term after \"with\" must be the Boolean domain");
      }
    }
  ]
  { //set the reference to the guard
    rule.setGuard(guard);
  }
  < DO >
  {
    Logger.logDebug("\tdo");
  }
  doRule = Rule(localVar, c)
  { //set the reference to the body rule
    rule.setDoRule(doRule);
  }
  [
    LOOKAHEAD(1)
    < IFNONE >
    {
      Logger.logDebug("\tifnone");
    }
    ifnone = Rule(localVar, c)
    //il LOOKAHEAD(1) associa l'<IFNONE> alla rule pi? vicina
    //il problema si crea per il classico problema dell'else nel conditional,cio?,visto che non c'? un tag di fine
    //e ho due chooseRule annidati come faccio a sapere se l'ultimo IFNONE si associa all'ultima o alla penultima
    //regola choose
    { //set the reference to the ifnone rule
      rule.setIfnone(ifnone);
    }
  ]
  {
    Logger.logDebug("\t\t\tChooseRule end");
    return rule;
  }
}

//NEW by Patrizia Added ranges. Please don't touch!
ForallRule ForallRule(HashMap localVar, RuleDeclaration c) :
{
  VariableTerm variable;
  Term inTerm, guard;
  Rule doRule;
}
{
  < FORALL >
  {
    Logger.logDebug("\tforall\t\tForallRule beginning");
    ForallRule rule = rulesPack.getBasicTransitionRules().createForallRule();
    List < Term > rangeList = rule.getRanges();
    //check if the next variable is already used (look for it in the localVar HashMap)
    String nextVar = getToken(1).image;
    if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ForallRule. It is already used.");
  }
  variable = VariableTerm(localVar, true) < IN >
  {
    Logger.logDebug("\tin");
  }
  inTerm = Term(localVar, false, c)
  { //set the reference to the variable
    Collection variableList = rule.getVariable();
    variableList.add(variable);
    //check constraint 1 (part of it is granted for construction)
    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At a ForallRule");
    //update variable features
    Utility.updateVariable(variable, inTerm);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    //set the reference to the variable range
    rangeList.add(inTerm);
  }
  (
    ","
    { //check if the next variable is already used (look for it in the localVar HashMap)
      nextVar = getToken(1).image;
      if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ForallRule. It is already used.");
    }
    variable = VariableTerm(localVar, true) < IN >
    {
      Logger.logDebug("\tin");
    }
    inTerm = Term(localVar, false, c)
    { //set the reference to the variable
      variableList.add(variable);
      //check constraint 1 (part of it is granted for construction)
      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException("Error: The type-domain of terms after \"in\"  must be a power set domain \n" + "       At a ForallRule");
      //update variable features
      Utility.updateVariable(variable, inTerm);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: TD=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
      //set the reference to the variable range
      rangeList.add(inTerm);
    }
  )*
  //se la guardia non c'e', creiamo una guardia fittizia "true"
  {
    guard = termsPack.getBasicTerms().createBooleanTerm(true);
  }
  [
    < WITH >
    {
      Logger.logDebug("\twith");
    }
    guard = Term(localVar, false, c)
    {
      //(OCL constraints 2) check if the guard TypeDomain is the Boolean domain
      if (!OCL_Checker.isBoolean(guard))
      {
        Logger.logErr("Error: In a ForallRule the type-domain associated to the term after \"with\" must be the Boolean domain");
      }
    }
  ]
  { //set the reference
    rule.setGuard(guard);
  }
  < DO >
  {
    Logger.logDebug("\tdo");
  }
  doRule = Rule(localVar, c)
  { //set the reference
    rule.setDoRule(doRule);
    Logger.logDebug("\t\t\tForallRule end");
    return rule;
  }
}

// DA CONTROLLARE IL METAMODELLO
LetRule LetRule(HashMap localVar, RuleDeclaration c) :
{
  VariableTerm variable;
  Term initExp;
  Rule inRule;
}
{
  < LET > "("
  {
    Logger.logDebug("\tlet(\t\tLetRule beginning");
    //check if the next variable is already used (look for it in the localVar HashMap)
    String nextVar = getToken(1).image;
    if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the LetRule. It is already used.");
  }
  variable = VariableTerm(localVar, true) "="
  {
    Logger.logDebug("\t=");
  }
  initExp = Term(localVar, false, c)
  {
    LetRule rule = rulesPack.getBasicTransitionRules().createLetRule();
    List < VariableTerm > variableList = rule.getVariable();
    List < Term > initExpList = rule.getInitExpression();
    Domain varD;
    //set variable TypeDomain
    varD = initExp.getDomain();
    variable.setDomain(varD);
    //set variable kind
    if (varD instanceof RuleDomain) variable.setKind(VariableKind.RULE_VAR);
    //set references
    variableList.add(variable);
    initExpList.add(initExp);
    Logger.logDebug("\t\t\t" + variable.getName() + " updated: D=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
  }
  (
    ","
    {
      nextVar = getToken(1).image;
      if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the LetRule. It is already used.");
    }
    variable = VariableTerm(localVar, true) "="
    {
      Logger.logDebug("\t=");
    }
    initExp = Term(localVar, false, c)
    { // set variable TypeDomain
      varD = initExp.getDomain();
      variable.setDomain(varD);
      // set variable kind
      if (varD instanceof RuleDomain) variable.setKind(VariableKind.RULE_VAR);
      //set references
      variableList.add(variable);
      initExpList.add(initExp);
      Logger.logDebug("\t\t\t" + variable.getName() + " updated: D=" + variable.getDomain().getName() + ", kind=" + variable.getKind().toString());
    }
  )*
  ")"
  {
    Logger.logDebug("\t)");
  }
  < IN >
  {
    Logger.logDebug("\tin");
  }
  inRule = Rule(localVar, c)
  { //set the reference
    rule.setInRule(inRule);
    //create the association
    //check OCL constraints
    if (!OCL_Checker.checkLetRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the application of the let-rule.");
  }
  < ENDLET >
  {
    Logger.logDebug("\tendlet\t\tLetRule end");
    return rule;
  }
}

//Ok!
/*
* modified 10 Jan 2008 by acarioni
*
*/
MacroCallRule MacroCallRule(HashMap localVar, RuleDeclaration c) :
{
  String ruleName;
  Term par;
}
{
  ruleName = ID_RULE()
  {
    Logger.logDebug("\t" + ruleName + "\t\tMacroCallRule beginning");
    //create the object
    MacroCallRule rule = rulesPack.getBasicTransitionRules().createMacroCallRule();
    List < Term > actualParamList = rule.getParameters();
  }
  "["
  {
    Logger.logDebug("\t[");
  }
  [
    par = Term(localVar, false, c)
    {
      actualParamList.add(par);
    }
    (
      "," par = Term(localVar, false, c)
      {
        actualParamList.add(par);
      }
    )*
  ]
  "]"
  {
    Logger.logDebug("\t]\t\tMacroCallRule end");
  }
  {
    //look for the rule in the rule HashMap
    RuleDeclaration r = Utility.getRuleByNameTerm(declared_Rules, ruleName, actualParamList);
    //PA: 15/10/2011
    /*List<Domain> doms = Utility.buildDomains(actualParamList);
		List<VariableTerm> list = r.getVariable();
		Iterator<VariableTerm> it = list.iterator();
		HashMap<String, Domain> genericDomValue =  new HashMap<String, Domain>();		
		for(Domain domain: doms)	{
		  Domain other = it.next().getDomain();
		  System.out.println(domain.getName() + " " + other.getName() +" " +OCL_Checker.applicable(domain, other));
		  System.out.println(other.getName() + " " + domain.getName() +" " +OCL_Checker.applicable(other, domain));
		  
		  //if(!OCL_Checker.compareFixingAnyDomain(other, domain, genericDomValue))
		  if(!OCL_Checker.applicable(domain, other))		  {
		    throw new ParseException("Error: ");		  }		}*/
    //PA: 15/10/2011 - end
    // added 10 Jan 2008 by acarioni
    if (r == null)
    {
      List < Domain > domains = Utility.buildDomains(actualParamList);
      Logger.logErr("rules already declared: " + Utility.toString(declared_Rules));
      throw new ParseException("Error: Unresolved reference to " + ruleName + Utility.toString(domains));
    }
    //******* NEW by Patrizia to manage recursion
    // NON FUNZIONA PIU' if (c!= null && ruleName.equals(c.getName()))
    //         	   r = c;
    if (!(r instanceof MacroDeclaration)) throw new ParseException("Error: The rule " + ruleName + " is not a macro");
    //set reference
    rule.setCalledMacro((MacroDeclaration) r);
    //PA: 15/10/2011 - start
    StringBuilder sb = new StringBuilder();
    sb.append("Macro call rule " + rule.getCalledMacro().getName() + " has been associated to the rule " + r.getName() + "[");
    for (VariableTerm v : r.getVariable())
    {
      sb.append(v.getDomain().getName());
    }
    sb.append("]");
    Logger.logDebug(sb.toString());
    //PA: 15/10/2011 - end
    //check OCL constraints
    if (!OCL_Checker.checkMacroCallRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the application of the rule " + ruleName + " as a macro.");
    Logger.logDebug("The macro call rule respects the OCL constraints.");
    return rule;
  }
}

//OK!
ExtendRule ExtendRule(HashMap localVar, RuleDeclaration c) :
{
  String id_dom;
  VariableTerm v;
  Rule doRule;
}
{
  < EXTEND >
  {
    Logger.logDebug("\textend\t\tExtendRule beginning");
  }
  id_dom = ID_DOMAIN()
  {
    ExtendRule rule = rulesPack.getBasicTransitionRules().createExtendRule();
    Domain dom = (Domain) declared_Dom.get(id_dom);
    rule.setExtendedDomain(dom);
    //XAExtendRuleExtendedDomain a_ExtendR_Dom= rulesPack.getBasicTransitionRules().getAExtendRuleExtendedDomain();
    //Xa_ExtendR_Dom.add(rule,(AbstractTd)dom);
  }
  < WITH >
  {
    Logger.logDebug("\twith");
  }
  {
    String nextVar = getToken(1).image;
    if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ExtendRule. It is already used.");
  }
  v = VariableTerm(localVar, true)
  {
    Collection VariablesList = rule.getBoundVar();
    VariablesList.add(v);
    //XAExtendRuleBoundVar a_ExtendR_Var= rulesPack.getBasicTransitionRules().getAExtendRuleBoundVar();
    //Xa_ExtendR_Var.add(rule,v);
    ReserveDomain Reservedom = (ReserveDomain) Utility.getPredefinedAbstractDomain(domainsFactory, "Reserve");
    if (Reservedom == null) throw new ParseException("Error: The domain Reserve has not been declared.");
    Utility.updateVariable(v, dom);
    //constraint R6 is granted for construction
    Logger.logDebug("\t\t\tTD assigned to " + v.getName() + ": " + v.getDomain().getName());
  }
  (
    ","
    {
      nextVar = getToken(1).image;
      if (localVar.get(nextVar) != null) throw new ParseException("Error: The variable " + nextVar + " cannot be bound to a value in the ExtendRule. It is already used.");
    }
    v = VariableTerm(localVar, true)
    {
      VariablesList.add(v);
      //Xa_ExtendR_Var.add(rule,v);
      Utility.updateVariable(v, dom);
      //constraint R6 is granted for construction
      Logger.logDebug("\t\t\tTD assigned to " + v.getName() + ": " + v.getDomain().getName());
    }
  )*
  < DO >
  {
    Logger.logDebug("\tdo");
  }
  doRule = Rule(localVar, c) //LogicalVariableTerm()
  //forse al posto di ID_DOMAIN() e' meglio mettere domain_link()(semantica: cerca un dominio
  //nella signature e torna un collegamento all'oggetto[lo dobbiamo fare anche qui])perche' in tal modo si permetterebbe
  //all'utente di utilizzare uno structuredDomain e bisognerebbe dopo fare il controllo che non lo sia
  {
    rule.setDoRule(doRule);
    //X AExtendRuleDoRule a_ExtendR_DoRule= rulesPack.getBasicTransitionRules().getAExtendRuleDoRule();
    //X a_ExtendR_DoRule.add(rule,doRule);
    //check OCL constraints
    if (!OCL_Checker.checkExtendRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the application of the extend rule.");
    Logger.logDebug("\t\t\tExtendRule end");
    return rule;
  }
}

/////////////////////////////////////////////////////////////////////////
TurboRule TurboRule(HashMap localVar, RuleDeclaration c) :
{
  TurboRule result;
}
{
  (
    result = SeqRule(localVar, c)
  | result = IterateRule(localVar, c)
  | result = TurboCallRule(localVar, c)
  | result = TurboLocalStateRule(localVar, c)
    //| result =TryCatchRule(localVar,c)
  )
  {
    return result;
  }
}

///////////////// TURBO RULE /////////////////
SeqRule SeqRule(HashMap localVar, RuleDeclaration c) :
{
  Rule r;
}
{
  < seq >
  {
    Logger.logDebug("\tseq\t\tSeqRule beginning");
    SeqRule rule = rulesPack.getTurboTransitionRules().createSeqRule();
    List < Rule > rulesList = rule.getRules();
  }
  r = Rule(localVar, c)
  { //add rules
    rulesList.add(r);
  }
  (
    r = Rule(localVar, c)
    { //set the reference
      rulesList.add(r);
    }
  )+
  < ENDSEQ >
  {
    Logger.logDebug("\tendseq\t\tSeqRule end");
    return rule;
  }
}

IterateRule IterateRule(HashMap localVar, RuleDeclaration c) :
{
  Rule r;
}
{
  < ITERATE >
  {
    Logger.logDebug("\titerate\t\tIterateRule beginning");
  }
  r = Rule(localVar, c) < ENDITERATE >
  {
    Logger.logDebug("\tenditerate\t\tIterateRule end");
  }
  {
    IterateRule rule = rulesPack.getTurboTransitionRules().createIterateRule();
    //set the reference
    rule.setRule(r);
    return rule;
  }
}

TurboCallRule TurboCallRule(HashMap localVar, RuleDeclaration c) :
{
  String ruleName;
  Term par;
}
{
  ruleName = ID_RULE()
  {
    Logger.logDebug("\t" + ruleName + "\t\tTurboCallRule beginning");
    Logger.logDebug("\t context: " + ((c == null) ? "null" : c.getName()));
    //create the object
    TurboCallRule rule = rulesPack.getTurboTransitionRules().createTurboCallRule();
    List < Term > actualParamList = rule.getParameters();
  }
  "("
  {
    Logger.logDebug("\t(");
  }
  [
    par = Term(localVar, false, c)
    {
      actualParamList.add(par);
    }
    (
      "," par = Term(localVar, false, c)
      {
        actualParamList.add(par);
      }
    )*
  ]
  ")"
  {
    Logger.logDebug("\t)\t\tTurboCallRule end");
  }
  {
    //look for the rule in the rule HashMap
    RuleDeclaration r = Utility.getRuleByNameTerm(declared_Rules, ruleName, actualParamList);
    //******* NEW by Patrizia to manage recursion
    if (c != null && ruleName.equals(c.getName())) r = c;
    //*************
    // added 10 Jan 2008 by acarioni
    if (r == null)
    {
      List < Domain > domains = Utility.buildDomains(actualParamList);
      Logger.logErr("rules already declared: " + Utility.toString(declared_Rules));
      //Logger.logErr("Asbtract domains:" + Utility.toString(Utility.abstractTds.values()));
      throw new ParseException("Error: Unresolved reference to " + ruleName + Utility.toString(domains));
    }
    if (!(r instanceof TurboDeclaration)) throw new ParseException("Error: The rule " + ruleName + " is not declared as turbo, but it is called as it was.");
    //set reference
    rule.setCalledRule((TurboDeclaration) r);
    if (ruleName.equals(c.getName()))  //***NEW by Patrizia - in case of recursion, don't check OCL constraints
    return rule;
    //check OCL constraints
    if (!OCL_Checker.checkTurboCallRule(rule))
    { //For debugging
      Logger.logDebug(rule.getParameters().size() + " " + rule.getCalledRule().getArity());
      throw new ParseException(OCL_Checker.getMsgErr() + "\n       At the application of the rule " + ruleName + " as a submachine.");
    }
    return rule;
  }
}

TurboReturnRule TurboReturnRule(HashMap localVar, RuleDeclaration c) :
{
  LocationTerm loc;
  VariableTerm locVar;
  TurboCallRule updateR;
}
{
  {
    Logger.logDebug("\t\t\tTurboReturnRule beginning");
    TurboReturnRule rule = rulesPack.getTurboTransitionRules().createTurboReturnRule();
  }
  (
    loc = LocationTerm(localVar, false)
    { //set the reference
      rule.setLocation(loc);
    }
  | locVar = VariableTerm(localVar, false)
    { //set the reference
      rule.setLocation(locVar);
      // check and update the variable kind
      if (locVar.getKind() == VariableKind.LOGICAL_VAR)
      {
        locVar.setKind(VariableKind.LOCATION_VAR);
        Logger.logDebug("\t\t\t" + locVar.getName() + " updated: TD=" + locVar.getDomain().getName() + ", kind=" + locVar.getKind().toString());
      }
      else if (locVar.getKind() == VariableKind.RULE_VAR) throw new ParseException("Error: In a turbo-return rule, the variable to update must be a location variable, not a rule variable.");
    }
  )
  "<-"
  {
    Logger.logDebug("\t<-");
  }
  updateR = TurboCallRule(localVar, c)
  { //set the references
    rule.setUpdateRule(updateR);
    // constraint 1 and 2 are granted for construction
    Logger.logDebug("\t\t\tTurboReturnRule end");
    return rule;
  }
}

TurboLocalStateRule TurboLocalStateRule(HashMap localVar, RuleDeclaration c) :
{
  Rule init, body;
  LocalFunction localF;
  LinkedList localFunctions = new LinkedList();
}
{
  {
    Logger.logDebug("\t\t\tTurboLocalStateRule beginning");
    Logger.logDebug("\t");
  }
  localF = LocalFunction()
  {
    boolean inserted = Utility.insert(localF, declared_Func);
    if (inserted) localFunctions.add(localF);
    else throw new ParseException("Error: The function " + localF.getName() + ":" + ((localF.getDomain() == null) ? "" : (localF.getDomain().getName() + "->")) + localF.getCodomain().getName() + " has been declared twice.");
  }
  "["
  {
    Logger.logDebug("\t[");
  }
  init = Rule(localVar, c) "]"
  {
    Logger.logDebug("\t]");
  }
  {
    TurboLocalStateRule rule = rulesPack.getTurboTransitionRules().createTurboLocalStateRule();
    List LocFunList = rule.getLocalFunction();
    List InitRulesList = rule.getInit();
    //X ATurboLocalStateRuleInit a_TurLocStaTR_Init = rulesPack.getTurboTransitionRules().getATurboLocalStateRuleInit();
    //X ATurboLocalStateRuleLocalFunction a_TurLocStaTR_LocF = rulesPack.getTurboTransitionRules().getATurboLocalStateRuleLocalFunction();
    //set references
    LocFunList.add(localF);
    InitRulesList.add(init);
    //create associations
    //X a_TurLocStaTR_LocF.add(rule,localF);
    //X a_TurLocStaTR_Init.add(rule,init);
    //(OCL constraints 1) the dynamic functions must be local
    //if(!(localF.getKind().toString().equals("local")))
    //  throw new ParseException("Error: In a turbo rule with local state, the dynamic functions must be local.");
  }
  (
    LOOKAHEAD(1)
    {
      Logger.logDebug("\t");
    }
    localF = LocalFunction()
    {
      inserted = Utility.insert(localF, declared_Func);
      if (inserted) localFunctions.add(localF);
      else throw new ParseException("Error: The function " + localF.getName() + ":" + ((localF.getDomain() == null) ? "" : (localF.getDomain().getName() + "->")) + localF.getCodomain().getName() + " has been declared twice.");
    }
    "["
    {
      Logger.logDebug("\t[");
    }
    init = Rule(localVar, c) "]"
    {
      Logger.logDebug("\t]");
    }
    { //set references
      LocFunList.add(localF);
      InitRulesList.add(init);
      //create associations
      //X a_TurLocStaTR_LocF.add(rule,localF);
      //X a_TurLocStaTR_Init.add(rule,init);
      //(OCL constraints 1) the dynamic functions must be local
      //if(!(localF.getKind().toString().equals("local")))
      //   throw new ParseException("Error: In a turbo rule with local state, the dynamic functions must be local.");
    }
  )*
  body = Rule(localVar, c)
  {
    rule.setBody(body);
    //X ATurboLocalStateRuleBody a_TurLocStaTR_Body = rulesPack.getTurboTransitionRules().getATurboLocalStateRuleBody();
    //X a_TurLocStaTR_Body.add(rule,body);
    LocalFunction f;
    for (int count = 0; count < localFunctions.size(); count++)
    {
      f = (LocalFunction) localFunctions.get(count);
      Utility.remove(f, declared_Func);
    }
    Logger.logDebug("\t\t\tTurboLocalStateRule end");
    //Check OCL constraints
    if (!OCL_Checker.checkTurboLocalStateRule(rule))
    {
      Logger.logErr(OCL_Checker.getMsgErr());
      Logger.logErr("       At the TurboLocalStateRule.\n");
    }
    return rule;
  }
}

TryCatchRule TryCatchRule(HashMap localVar, RuleDeclaration c) :
{
  Rule tryR, catchR;
  Term loc;
}
{
  < TRY >
  {
    Logger.logDebug("\ttry\t\tTryCatchRule beginning");
  }
  tryR = Rule(localVar, c)
  { //create the object
    TryCatchRule rule = rulesPack.getTurboTransitionRules().createTryCatchRule();
    //set the reference
    rule.setTryRule(tryR);
    //create the association
    //X ATryCatchRuleTryRule a_TryCatchR_TryR = rulesPack.getTurboTransitionRules().getATryCatchRuleTryRule();
    //X a_TryCatchR_TryR.add(rule,tryR);
    Collection locColl = rule.getLocation();
    //X ATryCatchRuleLocation a_TryCatchR_Loc = rulesPack.getTurboTransitionRules().getATryCatchRuleLocation();
    //X ATryCatchRuleLocationVar a_TryCatchR_LocVar = rulesPack.getTurboTransitionRules().getATryCatchRuleLocationVar();
  }
  < CATCH >
  {
    Logger.logDebug("\tcatch");
  }
  (
    loc = Term(localVar, false, c)
    { //add location term to collection
      locColl.add(loc);
      //create the association
      //X a_TryCatchR_Loc.add(rule,loc);
      // check and update the variable kind
      if (loc instanceof VariableTerm)
      {
        VariableTerm locVar = (VariableTerm) loc;
        if (locVar.getKind() == VariableKind.LOGICAL_VAR)
        {
          ((VariableTerm) loc).setKind(VariableKind.LOCATION_VAR);
          Logger.logDebug("\t\t\t" + locVar.getName() + " updated: TD=" + locVar.getDomain().getName() + ", kind=" + locVar.getKind().toString());
        }
        else if (locVar.getKind() == VariableKind.RULE_VAR) throw new ParseException("Error: In a try-catch rule, the variable to catch must be a location variable, not a rule variable. ");
      }
    }
  )
  (
    ","
    (
      loc = Term(localVar, false, c)
      { //add location term to collection
        locColl.add(loc);
        // check and update the variable kind
        if (loc instanceof VariableTerm)
        {
          VariableTerm locVar = (VariableTerm) loc;
          if (locVar.getKind() == VariableKind.LOGICAL_VAR)
          {
            ((VariableTerm) loc).setKind(VariableKind.LOCATION_VAR);
            Logger.logDebug("\t\t\t" + locVar.getName() + " updated: TD=" + locVar.getDomain().getName() + ", kind=" + locVar.getKind().toString());
          }
          else if (locVar.getKind() == VariableKind.RULE_VAR) throw new ParseException("Error: In a try-catch rule, the variable to catch must be a location variable, not a rule variable. ");
        }
      }
    )
  )*
  catchR = Rule(localVar, c)
  { //set the reference
    rule.setCatchRule(catchR);
    //create the association
    //X ATryCatchRuleCatchRule a_TryCatchR_CatchR = rulesPack.getTurboTransitionRules().getATryCatchRuleCatchRule();
    //X a_TryCatchR_CatchR.add(rule,catchR);
    Logger.logDebug("\t\t\tTryCatchRule end");
    //OCL constraints granted for construction!
    return rule;
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
DerivedRule DerivedRule(HashMap localVar, RuleDeclaration c) :
{
  DerivedRule r;
}
{
  (
    r = BasicDerivedRule(localVar, c)
  | r = TurboDerivedRule(localVar, c)
  )
  {
    return r;
  }
}

BasicDerivedRule BasicDerivedRule(HashMap localVar, RuleDeclaration c) :
{
  BasicDerivedRule r;
}
{
  r = CaseRule(localVar, c)
  {
    return r;
  }
}

CaseRule CaseRule(HashMap localVar, RuleDeclaration c) :
{
  Term caseT, term;
  Rule resRule;
}
{
  < SWITCH >
  {
    Logger.logDebug("\tswitch\t\tCaseRule beginning");
  }
  term = Term(localVar, false, c)
  { //create the object
    CaseRule rule = rulesPack.getDerivedTransitionRules().createCaseRule();
    //set the reference
    rule.setTerm(term);
    List < Term > caseTermsList = rule.getCaseTerm();
    List < Rule > resList = rule.getCaseBranches();
  }
  (
    < CASE >
    {
      Logger.logDebug("\tcase");
    }
    term = Term(localVar, false, c) ":"
    {
      Logger.logDebug("\t:");
    }
    resRule = Rule(localVar, c)
    {
      caseTermsList.add(term);
      resList.add(resRule);
    }
  )+
  [
    < OTHERWISE >
    {
      Logger.logDebug("\totherwise");
    }
    resRule = Rule(localVar, c)
    { //set the reference
      rule.setOtherwiseBranch(resRule);
    }
  ]
  < END_SWITCH >
  {
    //check OCL constraints
    if (!OCL_Checker.checkCaseRule(rule))
    {
      Logger.logErr(OCL_Checker.getMsgErr());
      Logger.logErr("       At a case rule");
    }
    Logger.logDebug("\tendswitch\t\tCaseRule end");
    return rule;
  }
}

TurboDerivedRule TurboDerivedRule(HashMap localVar, RuleDeclaration c) :
{
  TurboDerivedRule r;
}
{
  (
    r = RecursiveWhileRule(localVar, c)
  | r = IterativeWhileRule(localVar, c)
  )
  {
    return r;
  }
}

RecursiveWhileRule RecursiveWhileRule(HashMap localVar, RuleDeclaration c) :
{
  Term guard;
  Rule r;
}
{
  < WHILEREC >
  {
    Logger.logDebug("\twhilerec\t\tRecursiveWhileRule beginning");
  }
  guard = Term(localVar, false, c) < DO >
  {
    Logger.logDebug("\tdo");
  }
  r = Rule(localVar, c)
  {
    RecursiveWhileRule rule = rulesPack.getDerivedTransitionRules().createRecursiveWhileRule();
    //set references
    rule.setGuard(guard);
    rule.setRule(r);
    //create associations
    //X ARecursiveWhileRuleGuard a_RecWhileR_Guard = rulesPack.getDerivedTransitionRules().getARecursiveWhileRuleGuard();
    //X a_RecWhileR_Guard.add(rule,guard);
    //X ARecursiveWhileRuleRule a_RecWhileR_Rule = rulesPack.getDerivedTransitionRules().getARecursiveWhileRuleRule();
    //X a_RecWhileR_Rule.add(r,rule);
    //OCL constraints
    if (!OCL_Checker.checkRecursiveWhileRule(rule))
    {
      Logger.logErr(OCL_Checker.getMsgErr());
      Logger.logErr("       At a RecursiveWhileRule");
    }
    Logger.logDebug("\t\t\tRecursiveWhileRule end");
    return rule;
  }
}

IterativeWhileRule IterativeWhileRule(HashMap localVar, RuleDeclaration c) :
{
  Term guard;
  Rule r;
}
{
  < WHILE >
  {
    Logger.logDebug("\twhile\t\tIterativeWhileRule beginning");
  }
  guard = Term(localVar, false, c) < DO >
  {
    Logger.logDebug("\tdo");
  }
  r = Rule(localVar, c)
  {
    IterativeWhileRule rule = rulesPack.getDerivedTransitionRules().createIterativeWhileRule();
    //set references
    rule.setGuard(guard);
    rule.setRule(r);
    //create associations
    //X AIterativeWhileRuleGuard a_ItWhileR_Guard = rulesPack.getDerivedTransitionRules().getAIterativeWhileRuleGuard();
    //X a_ItWhileR_Guard.add(rule,guard);
    //X AIterativeWhileRuleRule a_ItWhileR_Rule = rulesPack.getDerivedTransitionRules().getAIterativeWhileRuleRule();
    //X a_ItWhileR_Rule.add(r,rule);
    //OCL constraints
    if (!OCL_Checker.checkIterativeWhileRule(rule))
    {
      Logger.logErr(OCL_Checker.getMsgErr());
      Logger.logErr("       At a IterativeWhileRule");
    }
    Logger.logDebug("\t\t\tIterativeWhileRule end");
    return rule;
  }
}

////////////////////////////////////////////////////////
/////////////////////////////////// END OF GRAMMAR ///////////////////////////
String ID_VARIABLE() :
{
  Token t;
}
{
  t = < ID_VARIABLE >
  {
    return t.image;
  }
}

String ID_ENUM() :
{
  Token t;
}
{
  t = < ID_ENUM >
  {
    return t.image;
  }
}

String ID_DOMAIN() :
{
  Token t;
}
{
  t = < ID_DOMAIN >
  {
    return t.image;
  }
}

String ID_RULE() :
{
  Token t;
}
{
  t = < ID_RULE >
  {
    return t.image;
  }
}

String ID_AXIOM() :
{
  Token t;
}
{
  t = < ID_AXIOM >
  {
    return t.image;
  }
}

String ID_CTL() :
{
  Token t;
}
{
  t = < ID_CTL >
  {
    return t.image;
  }
}

String ID_LTL() :
{
  Token t;
}
{
  t = < ID_LTL >
  {
    return t.image;
  }
}

String ID_FUNCTION() :
{
  Token t;
}
{
  t = < ID_FUNCTION >
  {
    return t.image;
  }
}

String ID_AGENT() :
{
  Token t;
}
{
  t = < ID_FUNCTION >
  {
    return t.image;
  }
}

String ID() :
{
  Token t;
}
{
  (t = < ID >)
  {
    return t.image;
  }
}

String MOD_ID() :
{
  Token t;
}
{
  (t = < MOD_ID >)
  {
    return t.image;
  }
}