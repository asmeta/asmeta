/*
 * generated by Xtext 2.21.0
 */
package org.asmeta.xt.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.asmeta.xt.asmetal.AbstractTD;
import org.asmeta.xt.asmetal.AgentDomain;
import org.asmeta.xt.asmetal.AgentInitialization;
import org.asmeta.xt.asmetal.AnyDomain;
import org.asmeta.xt.asmetal.Asm;
import org.asmeta.xt.asmetal.AsmetalPackage;
import org.asmeta.xt.asmetal.BagCT;
import org.asmeta.xt.asmetal.BagDomain;
import org.asmeta.xt.asmetal.BagTerm;
import org.asmeta.xt.asmetal.BasicTD;
import org.asmeta.xt.asmetal.BinaryOperation;
import org.asmeta.xt.asmetal.BlockRule;
import org.asmeta.xt.asmetal.Body;
import org.asmeta.xt.asmetal.BooleanDomain;
import org.asmeta.xt.asmetal.BooleanTerm;
import org.asmeta.xt.asmetal.CaseRule;
import org.asmeta.xt.asmetal.CaseTerm;
import org.asmeta.xt.asmetal.CharDomain;
import org.asmeta.xt.asmetal.CharTerm;
import org.asmeta.xt.asmetal.ChooseRule;
import org.asmeta.xt.asmetal.CompassionConstraint;
import org.asmeta.xt.asmetal.ComplexDomain;
import org.asmeta.xt.asmetal.ComplexTerm;
import org.asmeta.xt.asmetal.ConcreteDomain;
import org.asmeta.xt.asmetal.ConditionalRule;
import org.asmeta.xt.asmetal.ConditionalTerm;
import org.asmeta.xt.asmetal.ControlledFunction;
import org.asmeta.xt.asmetal.CtlSpec;
import org.asmeta.xt.asmetal.DerivedFunction;
import org.asmeta.xt.asmetal.Domain;
import org.asmeta.xt.asmetal.DomainDefinition;
import org.asmeta.xt.asmetal.DomainInitialization;
import org.asmeta.xt.asmetal.EnumElement;
import org.asmeta.xt.asmetal.EnumTD;
import org.asmeta.xt.asmetal.EnumTerm;
import org.asmeta.xt.asmetal.ExistTerm;
import org.asmeta.xt.asmetal.ExistUniqueTerm;
import org.asmeta.xt.asmetal.ExportClause;
import org.asmeta.xt.asmetal.Expression;
import org.asmeta.xt.asmetal.ExtendRule;
import org.asmeta.xt.asmetal.ForallRule;
import org.asmeta.xt.asmetal.ForallTerm;
import org.asmeta.xt.asmetal.FunctionDefinition;
import org.asmeta.xt.asmetal.FunctionInitialization;
import org.asmeta.xt.asmetal.FunctionTerm;
import org.asmeta.xt.asmetal.Header;
import org.asmeta.xt.asmetal.ImportClause;
import org.asmeta.xt.asmetal.Initialization;
import org.asmeta.xt.asmetal.IntegerDomain;
import org.asmeta.xt.asmetal.IntegerTerm;
import org.asmeta.xt.asmetal.Invariant;
import org.asmeta.xt.asmetal.InvariantConstraint;
import org.asmeta.xt.asmetal.InvariantElement;
import org.asmeta.xt.asmetal.IterateRule;
import org.asmeta.xt.asmetal.IterativeWhileRule;
import org.asmeta.xt.asmetal.JusticeConstraint;
import org.asmeta.xt.asmetal.LetRule;
import org.asmeta.xt.asmetal.LetTerm;
import org.asmeta.xt.asmetal.LocalFunction;
import org.asmeta.xt.asmetal.LocationTerm;
import org.asmeta.xt.asmetal.LtlSpec;
import org.asmeta.xt.asmetal.MacroCallRule;
import org.asmeta.xt.asmetal.MacroDeclaration;
import org.asmeta.xt.asmetal.MapCT;
import org.asmeta.xt.asmetal.MapDomain;
import org.asmeta.xt.asmetal.MapTerm;
import org.asmeta.xt.asmetal.MonitoredFunction;
import org.asmeta.xt.asmetal.NaturalDomain;
import org.asmeta.xt.asmetal.NaturalTerm;
import org.asmeta.xt.asmetal.OutFunction;
import org.asmeta.xt.asmetal.PowersetDomain;
import org.asmeta.xt.asmetal.ProductDomain;
import org.asmeta.xt.asmetal.RealDomain;
import org.asmeta.xt.asmetal.RealTerm;
import org.asmeta.xt.asmetal.RecursiveWhileRule;
import org.asmeta.xt.asmetal.ReserveDomain;
import org.asmeta.xt.asmetal.RuleAsTerm;
import org.asmeta.xt.asmetal.RuleDomain;
import org.asmeta.xt.asmetal.SeqRule;
import org.asmeta.xt.asmetal.SequenceCT;
import org.asmeta.xt.asmetal.SequenceDomain;
import org.asmeta.xt.asmetal.SequenceTerm;
import org.asmeta.xt.asmetal.SetCT;
import org.asmeta.xt.asmetal.SetTerm;
import org.asmeta.xt.asmetal.SharedFunction;
import org.asmeta.xt.asmetal.Signature;
import org.asmeta.xt.asmetal.SkipRule;
import org.asmeta.xt.asmetal.StaticFunction;
import org.asmeta.xt.asmetal.StringDomain;
import org.asmeta.xt.asmetal.StringTerm;
import org.asmeta.xt.asmetal.TermAsRule;
import org.asmeta.xt.asmetal.TupleTerm;
import org.asmeta.xt.asmetal.TurboCallRule;
import org.asmeta.xt.asmetal.TurboDeclaration;
import org.asmeta.xt.asmetal.TurboLocalStateRule;
import org.asmeta.xt.asmetal.TurboReturnRule;
import org.asmeta.xt.asmetal.UndefDomain;
import org.asmeta.xt.asmetal.UndefTerm;
import org.asmeta.xt.asmetal.UpdateRule;
import org.asmeta.xt.asmetal.VariableTerm;
import org.asmeta.xt.asmetal.importData;
import org.asmeta.xt.services.AsmetaLGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AsmetaLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AsmetaLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AsmetalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AsmetalPackage.ABSTRACT_TD:
				sequence_GenericAbstractTD(context, (AbstractTD) semanticObject); 
				return; 
			case AsmetalPackage.AGENT_DOMAIN:
				sequence_AgentDomain(context, (AgentDomain) semanticObject); 
				return; 
			case AsmetalPackage.AGENT_INITIALIZATION:
				sequence_AgentInitialization(context, (AgentInitialization) semanticObject); 
				return; 
			case AsmetalPackage.ANY_DOMAIN:
				sequence_AnyDomain(context, (AnyDomain) semanticObject); 
				return; 
			case AsmetalPackage.ASM:
				sequence_Asm(context, (Asm) semanticObject); 
				return; 
			case AsmetalPackage.BAG_CT:
				sequence_BagCT(context, (BagCT) semanticObject); 
				return; 
			case AsmetalPackage.BAG_DOMAIN:
				sequence_BagDomain(context, (BagDomain) semanticObject); 
				return; 
			case AsmetalPackage.BAG_TERM:
				sequence_BagTerm(context, (BagTerm) semanticObject); 
				return; 
			case AsmetalPackage.BASIC_TD:
				sequence_BasicTD(context, (BasicTD) semanticObject); 
				return; 
			case AsmetalPackage.BINARY_OPERATION:
				sequence_AdditiveExpression_AndExpression_CompareExpression_EqualityExpression_ImpliesIffExpression_MultiplicativeExpression_PowerExpression_XorOrExpression(context, (BinaryOperation) semanticObject); 
				return; 
			case AsmetalPackage.BLOCK_RULE:
				sequence_BlockRule(context, (BlockRule) semanticObject); 
				return; 
			case AsmetalPackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case AsmetalPackage.BOOLEAN_DOMAIN:
				sequence_BooleanDomain(context, (BooleanDomain) semanticObject); 
				return; 
			case AsmetalPackage.BOOLEAN_TERM:
				sequence_BooleanTerm(context, (BooleanTerm) semanticObject); 
				return; 
			case AsmetalPackage.CASE_RULE:
				sequence_CaseRule(context, (CaseRule) semanticObject); 
				return; 
			case AsmetalPackage.CASE_TERM:
				sequence_CaseTerm(context, (CaseTerm) semanticObject); 
				return; 
			case AsmetalPackage.CHAR_DOMAIN:
				sequence_CharDomain(context, (CharDomain) semanticObject); 
				return; 
			case AsmetalPackage.CHAR_TERM:
				sequence_CharTerm(context, (CharTerm) semanticObject); 
				return; 
			case AsmetalPackage.CHOOSE_RULE:
				sequence_ChooseRule(context, (ChooseRule) semanticObject); 
				return; 
			case AsmetalPackage.COMPASSION_CONSTRAINT:
				sequence_CompassionConstraint(context, (CompassionConstraint) semanticObject); 
				return; 
			case AsmetalPackage.COMPLEX_DOMAIN:
				sequence_ComplexDomain(context, (ComplexDomain) semanticObject); 
				return; 
			case AsmetalPackage.COMPLEX_TERM:
				sequence_ComplexTerm(context, (ComplexTerm) semanticObject); 
				return; 
			case AsmetalPackage.CONCRETE_DOMAIN:
				sequence_ConcreteDomain(context, (ConcreteDomain) semanticObject); 
				return; 
			case AsmetalPackage.CONDITIONAL_RULE:
				sequence_ConditionalRule(context, (ConditionalRule) semanticObject); 
				return; 
			case AsmetalPackage.CONDITIONAL_TERM:
				sequence_ConditionalTerm(context, (ConditionalTerm) semanticObject); 
				return; 
			case AsmetalPackage.CONTROLLED_FUNCTION:
				sequence_ControlledFunction(context, (ControlledFunction) semanticObject); 
				return; 
			case AsmetalPackage.CTL_SPEC:
				sequence_CtlSpec(context, (CtlSpec) semanticObject); 
				return; 
			case AsmetalPackage.DERIVED_FUNCTION:
				sequence_DerivedFunction(context, (DerivedFunction) semanticObject); 
				return; 
			case AsmetalPackage.DOMAIN:
				if (rule == grammarAccess.getGetDomainByIDRule()
						|| rule == grammarAccess.getTermRule()
						|| rule == grammarAccess.getDomainTermRule()) {
					sequence_getDomainByID_nameofDomain(context, (Domain) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNameofDomainRule()) {
					sequence_nameofDomain(context, (Domain) semanticObject); 
					return; 
				}
				else break;
			case AsmetalPackage.DOMAIN_DEFINITION:
				sequence_DomainDefinition(context, (DomainDefinition) semanticObject); 
				return; 
			case AsmetalPackage.DOMAIN_INITIALIZATION:
				sequence_DomainInitialization(context, (DomainInitialization) semanticObject); 
				return; 
			case AsmetalPackage.ENUM_ELEMENT:
				sequence_EnumElement(context, (EnumElement) semanticObject); 
				return; 
			case AsmetalPackage.ENUM_TD:
				sequence_EnumTD(context, (EnumTD) semanticObject); 
				return; 
			case AsmetalPackage.ENUM_TERM:
				sequence_EnumTerm(context, (EnumTerm) semanticObject); 
				return; 
			case AsmetalPackage.EXIST_TERM:
				sequence_ExistTerm(context, (ExistTerm) semanticObject); 
				return; 
			case AsmetalPackage.EXIST_UNIQUE_TERM:
				sequence_ExistUniqueTerm(context, (ExistUniqueTerm) semanticObject); 
				return; 
			case AsmetalPackage.EXPORT_CLAUSE:
				sequence_ExportClause(context, (ExportClause) semanticObject); 
				return; 
			case AsmetalPackage.EXPRESSION:
				sequence_UnaryOperation(context, (Expression) semanticObject); 
				return; 
			case AsmetalPackage.EXTEND_RULE:
				sequence_ExtendRule(context, (ExtendRule) semanticObject); 
				return; 
			case AsmetalPackage.FORALL_RULE:
				sequence_ForallRule(context, (ForallRule) semanticObject); 
				return; 
			case AsmetalPackage.FORALL_TERM:
				sequence_ForallTerm(context, (ForallTerm) semanticObject); 
				return; 
			case AsmetalPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case AsmetalPackage.FUNCTION_INITIALIZATION:
				sequence_FunctionInitialization(context, (FunctionInitialization) semanticObject); 
				return; 
			case AsmetalPackage.FUNCTION_TERM:
				sequence_FunctionTerm(context, (FunctionTerm) semanticObject); 
				return; 
			case AsmetalPackage.HEADER:
				sequence_Header(context, (Header) semanticObject); 
				return; 
			case AsmetalPackage.IMPORT_CLAUSE:
				sequence_ImportClause(context, (ImportClause) semanticObject); 
				return; 
			case AsmetalPackage.INITIALIZATION:
				sequence_Initialization(context, (Initialization) semanticObject); 
				return; 
			case AsmetalPackage.INTEGER_DOMAIN:
				sequence_IntegerDomain(context, (IntegerDomain) semanticObject); 
				return; 
			case AsmetalPackage.INTEGER_TERM:
				sequence_IntegerTerm(context, (IntegerTerm) semanticObject); 
				return; 
			case AsmetalPackage.INVARIANT:
				sequence_Invariant(context, (Invariant) semanticObject); 
				return; 
			case AsmetalPackage.INVARIANT_CONSTRAINT:
				sequence_InvariantConstraint(context, (InvariantConstraint) semanticObject); 
				return; 
			case AsmetalPackage.INVARIANT_ELEMENT:
				sequence_InvariantElement(context, (InvariantElement) semanticObject); 
				return; 
			case AsmetalPackage.ITERATE_RULE:
				sequence_IterateRule(context, (IterateRule) semanticObject); 
				return; 
			case AsmetalPackage.ITERATIVE_WHILE_RULE:
				sequence_IterativeWhileRule(context, (IterativeWhileRule) semanticObject); 
				return; 
			case AsmetalPackage.JUSTICE_CONSTRAINT:
				sequence_JusticeConstraint(context, (JusticeConstraint) semanticObject); 
				return; 
			case AsmetalPackage.LET_RULE:
				sequence_LetRule(context, (LetRule) semanticObject); 
				return; 
			case AsmetalPackage.LET_TERM:
				sequence_LetTerm(context, (LetTerm) semanticObject); 
				return; 
			case AsmetalPackage.LOCAL_FUNCTION:
				sequence_LocalFunction(context, (LocalFunction) semanticObject); 
				return; 
			case AsmetalPackage.LOCATION_TERM:
				sequence_LocationTerm(context, (LocationTerm) semanticObject); 
				return; 
			case AsmetalPackage.LTL_SPEC:
				sequence_LtlSpec(context, (LtlSpec) semanticObject); 
				return; 
			case AsmetalPackage.MACRO_CALL_RULE:
				sequence_MacroCallRule(context, (MacroCallRule) semanticObject); 
				return; 
			case AsmetalPackage.MACRO_DECLARATION:
				sequence_MacroDeclaration(context, (MacroDeclaration) semanticObject); 
				return; 
			case AsmetalPackage.MAP_CT:
				sequence_MapCT(context, (MapCT) semanticObject); 
				return; 
			case AsmetalPackage.MAP_DOMAIN:
				sequence_MapDomain(context, (MapDomain) semanticObject); 
				return; 
			case AsmetalPackage.MAP_TERM:
				sequence_MapTerm(context, (MapTerm) semanticObject); 
				return; 
			case AsmetalPackage.MONITORED_FUNCTION:
				sequence_MonitoredFunction(context, (MonitoredFunction) semanticObject); 
				return; 
			case AsmetalPackage.NATURAL_DOMAIN:
				sequence_NaturalDomain(context, (NaturalDomain) semanticObject); 
				return; 
			case AsmetalPackage.NATURAL_TERM:
				sequence_NaturalTerm(context, (NaturalTerm) semanticObject); 
				return; 
			case AsmetalPackage.OUT_FUNCTION:
				sequence_OutFunction(context, (OutFunction) semanticObject); 
				return; 
			case AsmetalPackage.POWERSET_DOMAIN:
				sequence_PowersetDomain(context, (PowersetDomain) semanticObject); 
				return; 
			case AsmetalPackage.PRODUCT_DOMAIN:
				sequence_ProductDomain(context, (ProductDomain) semanticObject); 
				return; 
			case AsmetalPackage.REAL_DOMAIN:
				sequence_RealDomain(context, (RealDomain) semanticObject); 
				return; 
			case AsmetalPackage.REAL_TERM:
				sequence_RealTerm(context, (RealTerm) semanticObject); 
				return; 
			case AsmetalPackage.RECURSIVE_WHILE_RULE:
				sequence_RecursiveWhileRule(context, (RecursiveWhileRule) semanticObject); 
				return; 
			case AsmetalPackage.RESERVE_DOMAIN:
				sequence_ReserveDomain(context, (ReserveDomain) semanticObject); 
				return; 
			case AsmetalPackage.RULE_AS_TERM:
				sequence_RuleAsTerm(context, (RuleAsTerm) semanticObject); 
				return; 
			case AsmetalPackage.RULE_DOMAIN:
				sequence_RuleDomain(context, (RuleDomain) semanticObject); 
				return; 
			case AsmetalPackage.SEQ_RULE:
				sequence_SeqRule(context, (SeqRule) semanticObject); 
				return; 
			case AsmetalPackage.SEQUENCE_CT:
				sequence_SequenceCT(context, (SequenceCT) semanticObject); 
				return; 
			case AsmetalPackage.SEQUENCE_DOMAIN:
				sequence_SequenceDomain(context, (SequenceDomain) semanticObject); 
				return; 
			case AsmetalPackage.SEQUENCE_TERM:
				sequence_SequenceTerm(context, (SequenceTerm) semanticObject); 
				return; 
			case AsmetalPackage.SET_CT:
				sequence_SetCT(context, (SetCT) semanticObject); 
				return; 
			case AsmetalPackage.SET_TERM:
				sequence_SetTerm(context, (SetTerm) semanticObject); 
				return; 
			case AsmetalPackage.SHARED_FUNCTION:
				sequence_SharedFunction(context, (SharedFunction) semanticObject); 
				return; 
			case AsmetalPackage.SIGNATURE:
				sequence_Signature(context, (Signature) semanticObject); 
				return; 
			case AsmetalPackage.SKIP_RULE:
				sequence_SkipRule(context, (SkipRule) semanticObject); 
				return; 
			case AsmetalPackage.STATIC_FUNCTION:
				sequence_StaticFunction(context, (StaticFunction) semanticObject); 
				return; 
			case AsmetalPackage.STRING_DOMAIN:
				sequence_StringDomain(context, (StringDomain) semanticObject); 
				return; 
			case AsmetalPackage.STRING_TERM:
				sequence_StringTerm(context, (StringTerm) semanticObject); 
				return; 
			case AsmetalPackage.TERM_AS_RULE:
				sequence_TermAsRule(context, (TermAsRule) semanticObject); 
				return; 
			case AsmetalPackage.TUPLE_TERM:
				sequence_TupleTerm(context, (TupleTerm) semanticObject); 
				return; 
			case AsmetalPackage.TURBO_CALL_RULE:
				sequence_TurboCallRule(context, (TurboCallRule) semanticObject); 
				return; 
			case AsmetalPackage.TURBO_DECLARATION:
				sequence_TurboDeclaration(context, (TurboDeclaration) semanticObject); 
				return; 
			case AsmetalPackage.TURBO_LOCAL_STATE_RULE:
				sequence_TurboLocalStateRule(context, (TurboLocalStateRule) semanticObject); 
				return; 
			case AsmetalPackage.TURBO_RETURN_RULE:
				sequence_TurboReturnRule(context, (TurboReturnRule) semanticObject); 
				return; 
			case AsmetalPackage.UNDEF_DOMAIN:
				sequence_UndefDomain(context, (UndefDomain) semanticObject); 
				return; 
			case AsmetalPackage.UNDEF_TERM:
				sequence_UndefTerm(context, (UndefTerm) semanticObject); 
				return; 
			case AsmetalPackage.UPDATE_RULE:
				sequence_UpdateRule(context, (UpdateRule) semanticObject); 
				return; 
			case AsmetalPackage.VARIABLE_TERM:
				sequence_VariableTerm(context, (VariableTerm) semanticObject); 
				return; 
			case AsmetalPackage.IMPORT_DATA:
				sequence_importData(context, (importData) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Term returns BinaryOperation
	 *     Expression returns BinaryOperation
	 *     ImpliesIffExpression returns BinaryOperation
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     XorOrExpression returns BinaryOperation
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     AndExpression returns BinaryOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     EqualityExpression returns BinaryOperation
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     CompareExpression returns BinaryOperation
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     AdditiveExpression returns BinaryOperation
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     MultiplicativeExpression returns BinaryOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     PowerExpression returns BinaryOperation
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *     UnaryOperation returns BinaryOperation
	 *     ParenthesizedExpression returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=ImpliesIffExpression_BinaryOperation_1_0_0_0 (op='implies' | op='iff') right=XorOrExpression) | 
	 *         (left=XorOrExpression_BinaryOperation_1_0_0_0 (op='xor' | op='or') right=AndExpression) | 
	 *         (left=AndExpression_BinaryOperation_1_0_0_0 op='and' right=EqualityExpression) | 
	 *         (left=EqualityExpression_BinaryOperation_1_0_0_0 (op='=' | op='!=') right=CompareExpression) | 
	 *         (left=CompareExpression_BinaryOperation_1_0_0_0 (op='>' | op='<' | op='>=' | op='<=') right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_BinaryOperation_1_0_0_0 (op='+' | op='-') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryOperation_1_0_0_0 (op='*' | op='/' | op='mod') right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryOperation_1_0_0_0 op='^' right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_CompareExpression_EqualityExpression_ImpliesIffExpression_MultiplicativeExpression_PowerExpression_XorOrExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns AgentDomain
	 *     TypeDomain returns AgentDomain
	 *     AbstractTD returns AgentDomain
	 *     AgentDomain returns AgentDomain
	 *     getDomainByID returns AgentDomain
	 *     Term returns AgentDomain
	 *     DomainTerm returns AgentDomain
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name='Agent')
	 */
	protected void sequence_AgentDomain(ISerializationContext context, AgentDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AgentInitialization returns AgentInitialization
	 *
	 * Constraint:
	 *     ((domainName=ID | domainName='Agent') program=MacroCallRule)
	 */
	protected void sequence_AgentInitialization(ISerializationContext context, AgentInitialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns AnyDomain
	 *     TypeDomain returns AnyDomain
	 *     AnyDomain returns AnyDomain
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AnyDomain(ISerializationContext context, AnyDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnyDomainAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Asm returns Asm
	 *
	 * Constraint:
	 *     (
	 *         isAsynchr?='asyncr'? 
	 *         (type='asm' | type='module') 
	 *         (name=extendedNameForAsm | name=STRING) 
	 *         headerSection=Header 
	 *         bodySection=Body 
	 *         mainrule=MacroDeclaration? 
	 *         (initialState+=Initialization* defaultInitialState=Initialization initialState+=Initialization*)?
	 *     )
	 */
	protected void sequence_Asm(ISerializationContext context, Asm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BagCT
	 *     ExtendedTerm returns BagCT
	 *     VariableBindingTerm returns BagCT
	 *     ComprehensionTerm returns BagCT
	 *     BagCT returns BagCT
	 *
	 * Constraint:
	 *     (variable+=VariableTerm ranges+=Term (variable+=VariableTerm ranges+=Term)* guard=Term? term=Term)
	 */
	protected void sequence_BagCT(ISerializationContext context, BagCT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns BagDomain
	 *     TypeDomain returns BagDomain
	 *     StructuredTD returns BagDomain
	 *     BagDomain returns BagDomain
	 *     getDomainByID returns BagDomain
	 *     Term returns BagDomain
	 *     DomainTerm returns BagDomain
	 *
	 * Constraint:
	 *     (name='Bag' domain=getDomainByID)
	 */
	protected void sequence_BagDomain(ISerializationContext context, BagDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.BAG_DOMAIN__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.BAG_DOMAIN__DOMAIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBagDomainAccess().getNameBagKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBagDomainAccess().getDomainGetDomainByIDParserRuleCall_2_0(), semanticObject.getDomain());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BagTerm
	 *     ExtendedTerm returns BagTerm
	 *     CollectionTerm returns BagTerm
	 *     BagTerm returns BagTerm
	 *
	 * Constraint:
	 *     (start_term=BasicTerm (other_terms+=BasicTerm+ | (end_term=ConstantTerm step=ConstantTerm?))?)?
	 */
	protected void sequence_BagTerm(ISerializationContext context, BagTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns BasicTD
	 *     TypeDomain returns BasicTD
	 *     BasicTD returns BasicTD
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_BasicTD(ISerializationContext context, BasicTD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBasicTDAccess().getNameIDTerminalRuleCall_2_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns BlockRule
	 *     BasicRule returns BlockRule
	 *     BlockRule returns BlockRule
	 *
	 * Constraint:
	 *     (rules+=Rule rules+=Rule+)
	 */
	protected void sequence_BlockRule(ISerializationContext context, BlockRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Body returns Body
	 *
	 * Constraint:
	 *     (
	 *         domainDefinition+=DomainDefinition* 
	 *         functionDefinition+=FunctionDefinition* 
	 *         ruleDeclaration+=RuleDeclaration* 
	 *         invariantConstraint+=InvariantConstraint* 
	 *         fairnessConstraint+=FairnessConstraint* 
	 *         property+=Property*
	 *     )
	 */
	protected void sequence_Body(ISerializationContext context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns BooleanDomain
	 *     TypeDomain returns BooleanDomain
	 *     BasicTD returns BooleanDomain
	 *     StandardDomain returns BooleanDomain
	 *     BooleanDomain returns BooleanDomain
	 *     getDomainByID returns BooleanDomain
	 *     Term returns BooleanDomain
	 *     DomainTerm returns BooleanDomain
	 *
	 * Constraint:
	 *     name='Boolean'
	 */
	protected void sequence_BooleanDomain(ISerializationContext context, BooleanDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanDomainAccess().getNameBooleanKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BooleanTerm
	 *     Expression returns BooleanTerm
	 *     ImpliesIffExpression returns BooleanTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns BooleanTerm
	 *     XorOrExpression returns BooleanTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns BooleanTerm
	 *     AndExpression returns BooleanTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BooleanTerm
	 *     EqualityExpression returns BooleanTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns BooleanTerm
	 *     CompareExpression returns BooleanTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns BooleanTerm
	 *     AdditiveExpression returns BooleanTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns BooleanTerm
	 *     MultiplicativeExpression returns BooleanTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BooleanTerm
	 *     PowerExpression returns BooleanTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns BooleanTerm
	 *     UnaryOperation returns BooleanTerm
	 *     ParenthesizedExpression returns BooleanTerm
	 *     basicExpr returns BooleanTerm
	 *     BasicTerm returns BooleanTerm
	 *     ConstantTerm returns BooleanTerm
	 *     BooleanTerm returns BooleanTerm
	 *
	 * Constraint:
	 *     (symbol='true' | symbol='false')
	 */
	protected void sequence_BooleanTerm(ISerializationContext context, BooleanTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns CaseRule
	 *     DerivedRule returns CaseRule
	 *     BasicDerivedRule returns CaseRule
	 *     CaseRule returns CaseRule
	 *
	 * Constraint:
	 *     (term=Term (caseTerm+=Term caseBranch+=Rule)+ otherwiseBranch=Rule?)
	 */
	protected void sequence_CaseRule(ISerializationContext context, CaseRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns CaseTerm
	 *     ExtendedTerm returns CaseTerm
	 *     CaseTerm returns CaseTerm
	 *
	 * Constraint:
	 *     (comparedTerm=Term (comparingTerm+=Term resultTerms+=Term)+ otherwiseTerm=Term?)
	 */
	protected void sequence_CaseTerm(ISerializationContext context, CaseTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns CharDomain
	 *     TypeDomain returns CharDomain
	 *     BasicTD returns CharDomain
	 *     StandardDomain returns CharDomain
	 *     CharDomain returns CharDomain
	 *     getDomainByID returns CharDomain
	 *     Term returns CharDomain
	 *     DomainTerm returns CharDomain
	 *
	 * Constraint:
	 *     name='Char'
	 */
	protected void sequence_CharDomain(ISerializationContext context, CharDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharDomainAccess().getNameCharKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns CharTerm
	 *     Expression returns CharTerm
	 *     ImpliesIffExpression returns CharTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns CharTerm
	 *     XorOrExpression returns CharTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns CharTerm
	 *     AndExpression returns CharTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns CharTerm
	 *     EqualityExpression returns CharTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns CharTerm
	 *     CompareExpression returns CharTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns CharTerm
	 *     AdditiveExpression returns CharTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns CharTerm
	 *     MultiplicativeExpression returns CharTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns CharTerm
	 *     PowerExpression returns CharTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns CharTerm
	 *     UnaryOperation returns CharTerm
	 *     ParenthesizedExpression returns CharTerm
	 *     basicExpr returns CharTerm
	 *     BasicTerm returns CharTerm
	 *     ConstantTerm returns CharTerm
	 *     CharTerm returns CharTerm
	 *
	 * Constraint:
	 *     symbol=CHAR_LITERAL
	 */
	protected void sequence_CharTerm(ISerializationContext context, CharTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharTermAccess().getSymbolCHAR_LITERALTerminalRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns ChooseRule
	 *     BasicRule returns ChooseRule
	 *     ChooseRule returns ChooseRule
	 *
	 * Constraint:
	 *     (
	 *         variable+=VariableTerm 
	 *         ranges+=Term 
	 *         (variable+=VariableTerm ranges+=Term)* 
	 *         guard=Term 
	 *         doRule=Rule 
	 *         ifnone=Rule?
	 *     )
	 */
	protected void sequence_ChooseRule(ISerializationContext context, ChooseRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FairnessConstraint returns CompassionConstraint
	 *     CompassionConstraint returns CompassionConstraint
	 *
	 * Constraint:
	 *     (p=Term q=Term)
	 */
	protected void sequence_CompassionConstraint(ISerializationContext context, CompassionConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.COMPASSION_CONSTRAINT__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.COMPASSION_CONSTRAINT__P));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.COMPASSION_CONSTRAINT__Q) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.COMPASSION_CONSTRAINT__Q));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompassionConstraintAccess().getPTermParserRuleCall_2_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getCompassionConstraintAccess().getQTermParserRuleCall_4_0(), semanticObject.getQ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns ComplexDomain
	 *     TypeDomain returns ComplexDomain
	 *     BasicTD returns ComplexDomain
	 *     StandardDomain returns ComplexDomain
	 *     ComplexDomain returns ComplexDomain
	 *     getDomainByID returns ComplexDomain
	 *     Term returns ComplexDomain
	 *     DomainTerm returns ComplexDomain
	 *
	 * Constraint:
	 *     name='Complex'
	 */
	protected void sequence_ComplexDomain(ISerializationContext context, ComplexDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexDomainAccess().getNameComplexKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ComplexTerm
	 *     Expression returns ComplexTerm
	 *     ImpliesIffExpression returns ComplexTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns ComplexTerm
	 *     XorOrExpression returns ComplexTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns ComplexTerm
	 *     AndExpression returns ComplexTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ComplexTerm
	 *     EqualityExpression returns ComplexTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ComplexTerm
	 *     CompareExpression returns ComplexTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns ComplexTerm
	 *     AdditiveExpression returns ComplexTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ComplexTerm
	 *     MultiplicativeExpression returns ComplexTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ComplexTerm
	 *     PowerExpression returns ComplexTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns ComplexTerm
	 *     UnaryOperation returns ComplexTerm
	 *     ParenthesizedExpression returns ComplexTerm
	 *     basicExpr returns ComplexTerm
	 *     BasicTerm returns ComplexTerm
	 *     ConstantTerm returns ComplexTerm
	 *     ComplexTerm returns ComplexTerm
	 *
	 * Constraint:
	 *     symbol=COMPLEX_NUMBER
	 */
	protected void sequence_ComplexTerm(ISerializationContext context, ComplexTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComplexTermAccess().getSymbolCOMPLEX_NUMBERTerminalRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns ConcreteDomain
	 *     ConcreteDomain returns ConcreteDomain
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name=ID typeDomain=getDomainByID)
	 */
	protected void sequence_ConcreteDomain(ISerializationContext context, ConcreteDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns ConditionalRule
	 *     BasicRule returns ConditionalRule
	 *     ConditionalRule returns ConditionalRule
	 *
	 * Constraint:
	 *     (guard=Term thenRule=Rule elseRule=Rule?)
	 */
	protected void sequence_ConditionalRule(ISerializationContext context, ConditionalRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ConditionalTerm
	 *     ExtendedTerm returns ConditionalTerm
	 *     ConditionalTerm returns ConditionalTerm
	 *
	 * Constraint:
	 *     (guard=Term thenTerm=Term elseTerm=Term?)
	 */
	protected void sequence_ConditionalTerm(ISerializationContext context, ConditionalTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns ControlledFunction
	 *     BasicFunction returns ControlledFunction
	 *     DynamicFunction returns ControlledFunction
	 *     ControlledFunction returns ControlledFunction
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name=extendedName domain=getDomainByID? codomain=getDomainByID)
	 */
	protected void sequence_ControlledFunction(ISerializationContext context, ControlledFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns CtlSpec
	 *     TemporalProperty returns CtlSpec
	 *     CtlSpec returns CtlSpec
	 *
	 * Constraint:
	 *     (name=ID? body=Term)
	 */
	protected void sequence_CtlSpec(ISerializationContext context, CtlSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns DerivedFunction
	 *     DerivedFunction returns DerivedFunction
	 *
	 * Constraint:
	 *     (name=ID domain=getDomainByID? codomain=getDomainByID)
	 */
	protected void sequence_DerivedFunction(ISerializationContext context, DerivedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainDefinition returns DomainDefinition
	 *
	 * Constraint:
	 *     (definedDomainName=ID body=Term)
	 */
	protected void sequence_DomainDefinition(ISerializationContext context, DomainDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN_DEFINITION__DEFINED_DOMAIN_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN_DEFINITION__DEFINED_DOMAIN_NAME));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN_DEFINITION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN_DEFINITION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainDefinitionAccess().getDefinedDomainNameIDTerminalRuleCall_1_0(), semanticObject.getDefinedDomainName());
		feeder.accept(grammarAccess.getDomainDefinitionAccess().getBodyTermParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DomainInitialization returns DomainInitialization
	 *
	 * Constraint:
	 *     (initializedDomain=ID body=Term)
	 */
	protected void sequence_DomainInitialization(ISerializationContext context, DomainInitialization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN_INITIALIZATION__INITIALIZED_DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN_INITIALIZATION__INITIALIZED_DOMAIN));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN_INITIALIZATION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN_INITIALIZATION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainInitializationAccess().getInitializedDomainIDTerminalRuleCall_1_0(), semanticObject.getInitializedDomain());
		feeder.accept(grammarAccess.getDomainInitializationAccess().getBodyTermParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnumElement returns EnumElement
	 *
	 * Constraint:
	 *     symbol=ENUM_ID
	 */
	protected void sequence_EnumElement(ISerializationContext context, EnumElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.ENUM_ELEMENT__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.ENUM_ELEMENT__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumElementAccess().getSymbolENUM_IDTerminalRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns EnumTD
	 *     TypeDomain returns EnumTD
	 *     EnumTD returns EnumTD
	 *
	 * Constraint:
	 *     (name=ID element+=EnumElement element+=EnumElement*)
	 */
	protected void sequence_EnumTD(ISerializationContext context, EnumTD semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns EnumTerm
	 *     Expression returns EnumTerm
	 *     ImpliesIffExpression returns EnumTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns EnumTerm
	 *     XorOrExpression returns EnumTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns EnumTerm
	 *     AndExpression returns EnumTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns EnumTerm
	 *     EqualityExpression returns EnumTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns EnumTerm
	 *     CompareExpression returns EnumTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns EnumTerm
	 *     AdditiveExpression returns EnumTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns EnumTerm
	 *     MultiplicativeExpression returns EnumTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns EnumTerm
	 *     PowerExpression returns EnumTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns EnumTerm
	 *     UnaryOperation returns EnumTerm
	 *     ParenthesizedExpression returns EnumTerm
	 *     basicExpr returns EnumTerm
	 *     BasicTerm returns EnumTerm
	 *     ConstantTerm returns EnumTerm
	 *     EnumTerm returns EnumTerm
	 *
	 * Constraint:
	 *     symbol=ENUM_ID
	 */
	protected void sequence_EnumTerm(ISerializationContext context, EnumTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumTermAccess().getSymbolENUM_IDTerminalRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ExistTerm
	 *     Expression returns ExistTerm
	 *     ImpliesIffExpression returns ExistTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns ExistTerm
	 *     XorOrExpression returns ExistTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns ExistTerm
	 *     AndExpression returns ExistTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ExistTerm
	 *     EqualityExpression returns ExistTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ExistTerm
	 *     CompareExpression returns ExistTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns ExistTerm
	 *     AdditiveExpression returns ExistTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ExistTerm
	 *     MultiplicativeExpression returns ExistTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ExistTerm
	 *     PowerExpression returns ExistTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns ExistTerm
	 *     UnaryOperation returns ExistTerm
	 *     ParenthesizedExpression returns ExistTerm
	 *     basicExpr returns ExistTerm
	 *     ExtendedTerm returns ExistTerm
	 *     VariableBindingTerm returns ExistTerm
	 *     FiniteQuantificationTerm returns ExistTerm
	 *     ExistTerm returns ExistTerm
	 *
	 * Constraint:
	 *     (variable+=VariableTerm ranges+=Term (variable+=VariableTerm ranges+=Term)* guard=Term?)
	 */
	protected void sequence_ExistTerm(ISerializationContext context, ExistTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ExistUniqueTerm
	 *     Expression returns ExistUniqueTerm
	 *     ImpliesIffExpression returns ExistUniqueTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns ExistUniqueTerm
	 *     XorOrExpression returns ExistUniqueTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns ExistUniqueTerm
	 *     AndExpression returns ExistUniqueTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ExistUniqueTerm
	 *     EqualityExpression returns ExistUniqueTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ExistUniqueTerm
	 *     CompareExpression returns ExistUniqueTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns ExistUniqueTerm
	 *     AdditiveExpression returns ExistUniqueTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ExistUniqueTerm
	 *     MultiplicativeExpression returns ExistUniqueTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ExistUniqueTerm
	 *     PowerExpression returns ExistUniqueTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns ExistUniqueTerm
	 *     UnaryOperation returns ExistUniqueTerm
	 *     ParenthesizedExpression returns ExistUniqueTerm
	 *     basicExpr returns ExistUniqueTerm
	 *     ExtendedTerm returns ExistUniqueTerm
	 *     VariableBindingTerm returns ExistUniqueTerm
	 *     FiniteQuantificationTerm returns ExistUniqueTerm
	 *     ExistUniqueTerm returns ExistUniqueTerm
	 *
	 * Constraint:
	 *     (variable+=VariableTerm ranges+=Term (variable+=VariableTerm ranges+=Term)* guard=Term?)
	 */
	protected void sequence_ExistUniqueTerm(ISerializationContext context, ExistUniqueTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExportClause returns ExportClause
	 *
	 * Constraint:
	 *     ((exportedList+=extendedName exportedList+=extendedName*) | exportAll?='*')
	 */
	protected void sequence_ExportClause(ISerializationContext context, ExportClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns ExtendRule
	 *     BasicRule returns ExtendRule
	 *     ExtendRule returns ExtendRule
	 *
	 * Constraint:
	 *     (extendedDomain=getDomainByID boundVar+=VariableTerm boundVar+=VariableTerm* doRule=Rule)
	 */
	protected void sequence_ExtendRule(ISerializationContext context, ExtendRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns ForallRule
	 *     BasicRule returns ForallRule
	 *     ForallRule returns ForallRule
	 *
	 * Constraint:
	 *     (variable+=VariableTerm ranges+=Term (variable+=VariableTerm ranges+=Term)* guard=Term? doRule=Rule)
	 */
	protected void sequence_ForallRule(ISerializationContext context, ForallRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ForallTerm
	 *     Expression returns ForallTerm
	 *     ImpliesIffExpression returns ForallTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns ForallTerm
	 *     XorOrExpression returns ForallTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns ForallTerm
	 *     AndExpression returns ForallTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ForallTerm
	 *     EqualityExpression returns ForallTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ForallTerm
	 *     CompareExpression returns ForallTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns ForallTerm
	 *     AdditiveExpression returns ForallTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ForallTerm
	 *     MultiplicativeExpression returns ForallTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ForallTerm
	 *     PowerExpression returns ForallTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns ForallTerm
	 *     UnaryOperation returns ForallTerm
	 *     ParenthesizedExpression returns ForallTerm
	 *     basicExpr returns ForallTerm
	 *     ExtendedTerm returns ForallTerm
	 *     VariableBindingTerm returns ForallTerm
	 *     FiniteQuantificationTerm returns ForallTerm
	 *     ForallTerm returns ForallTerm
	 *
	 * Constraint:
	 *     (variable+=VariableTerm ranges+=Term (variable+=VariableTerm ranges+=Term)* guard=Term?)
	 */
	protected void sequence_ForallTerm(ISerializationContext context, ForallTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (definedFunctionName=ID (variables+=ID_VARIABLE domain+=getDomainByID (variables+=ID_VARIABLE domain+=getDomainByID)*)? body=Term)
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionInitialization returns FunctionInitialization
	 *
	 * Constraint:
	 *     (
	 *         inizializedFunctionName=extendedNameForFunction 
	 *         (variables+=ID_VARIABLE domain+=getDomainByID (variables+=ID_VARIABLE domain+=getDomainByID)*)? 
	 *         body=Term
	 *     )
	 */
	protected void sequence_FunctionInitialization(ISerializationContext context, FunctionInitialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns FunctionTerm
	 *     Expression returns FunctionTerm
	 *     ImpliesIffExpression returns FunctionTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns FunctionTerm
	 *     XorOrExpression returns FunctionTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns FunctionTerm
	 *     AndExpression returns FunctionTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns FunctionTerm
	 *     EqualityExpression returns FunctionTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns FunctionTerm
	 *     CompareExpression returns FunctionTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns FunctionTerm
	 *     AdditiveExpression returns FunctionTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns FunctionTerm
	 *     MultiplicativeExpression returns FunctionTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns FunctionTerm
	 *     PowerExpression returns FunctionTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns FunctionTerm
	 *     UnaryOperation returns FunctionTerm
	 *     ParenthesizedExpression returns FunctionTerm
	 *     basicExpr returns FunctionTerm
	 *     BasicTerm returns FunctionTerm
	 *     FunctionTerm returns FunctionTerm
	 *
	 * Constraint:
	 *     (agent=extendedName? functionName=extendedNameForFunction arguments=TupleTerm?)
	 */
	protected void sequence_FunctionTerm(ISerializationContext context, FunctionTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns AbstractTD
	 *     TypeDomain returns AbstractTD
	 *     AbstractTD returns AbstractTD
	 *     GenericAbstractTD returns AbstractTD
	 *     getDomainByID returns AbstractTD
	 *     Term returns AbstractTD
	 *     DomainTerm returns AbstractTD
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name=ID)
	 */
	protected void sequence_GenericAbstractTD(ISerializationContext context, AbstractTD semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Header returns Header
	 *
	 * Constraint:
	 *     (importClause+=ImportClause* exportClause=ExportClause? signature=Signature)
	 */
	protected void sequence_Header(ISerializationContext context, Header semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportClause returns ImportClause
	 *
	 * Constraint:
	 *     ((moduleName=MOD_ID | moduleName=STRING) (importedList+=importData importedList+=importData*)?)
	 */
	protected void sequence_ImportClause(ISerializationContext context, ImportClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initialization returns Initialization
	 *
	 * Constraint:
	 *     (
	 *         name=extendedName 
	 *         domainInitialization+=DomainInitialization* 
	 *         functionInitialization+=FunctionInitialization* 
	 *         agentInitialization+=AgentInitialization*
	 *     )
	 */
	protected void sequence_Initialization(ISerializationContext context, Initialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns IntegerDomain
	 *     TypeDomain returns IntegerDomain
	 *     BasicTD returns IntegerDomain
	 *     StandardDomain returns IntegerDomain
	 *     IntegerDomain returns IntegerDomain
	 *     getDomainByID returns IntegerDomain
	 *     Term returns IntegerDomain
	 *     DomainTerm returns IntegerDomain
	 *
	 * Constraint:
	 *     name='Integer'
	 */
	protected void sequence_IntegerDomain(ISerializationContext context, IntegerDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerDomainAccess().getNameIntegerKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns IntegerTerm
	 *     Expression returns IntegerTerm
	 *     ImpliesIffExpression returns IntegerTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns IntegerTerm
	 *     XorOrExpression returns IntegerTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns IntegerTerm
	 *     AndExpression returns IntegerTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns IntegerTerm
	 *     EqualityExpression returns IntegerTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns IntegerTerm
	 *     CompareExpression returns IntegerTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns IntegerTerm
	 *     AdditiveExpression returns IntegerTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns IntegerTerm
	 *     MultiplicativeExpression returns IntegerTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns IntegerTerm
	 *     PowerExpression returns IntegerTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns IntegerTerm
	 *     UnaryOperation returns IntegerTerm
	 *     ParenthesizedExpression returns IntegerTerm
	 *     basicExpr returns IntegerTerm
	 *     BasicTerm returns IntegerTerm
	 *     ConstantTerm returns IntegerTerm
	 *     NumberTerm returns IntegerTerm
	 *     IntegerTerm returns IntegerTerm
	 *
	 * Constraint:
	 *     (symbol=NUMBER_TOKEN | symbol=NumberWithSign)
	 */
	protected void sequence_IntegerTerm(ISerializationContext context, IntegerTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InvariantConstraint returns InvariantConstraint
	 *
	 * Constraint:
	 *     body=Term
	 */
	protected void sequence_InvariantConstraint(ISerializationContext context, InvariantConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.INVARIANT_CONSTRAINT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.INVARIANT_CONSTRAINT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantConstraintAccess().getBodyTermParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InvariantElement returns InvariantElement
	 *
	 * Constraint:
	 *     (constrainedName=ID domainList+=getDomainByID?)
	 */
	protected void sequence_InvariantElement(ISerializationContext context, InvariantElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Invariant
	 *     Invariant returns Invariant
	 *
	 * Constraint:
	 *     (name=ID? invar_list+=InvariantElement invar_list+=InvariantElement* body=Term)
	 */
	protected void sequence_Invariant(ISerializationContext context, Invariant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns IterateRule
	 *     TurboRule returns IterateRule
	 *     IterateRule returns IterateRule
	 *
	 * Constraint:
	 *     rule=Rule
	 */
	protected void sequence_IterateRule(ISerializationContext context, IterateRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.ITERATE_RULE__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.ITERATE_RULE__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIterateRuleAccess().getRuleRuleParserRuleCall_1_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns IterativeWhileRule
	 *     DerivedRule returns IterativeWhileRule
	 *     TurboDerivedRule returns IterativeWhileRule
	 *     IterativeWhileRule returns IterativeWhileRule
	 *
	 * Constraint:
	 *     (guard=Term rule=Rule)
	 */
	protected void sequence_IterativeWhileRule(ISerializationContext context, IterativeWhileRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.TURBO_DERIVED_RULE__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.TURBO_DERIVED_RULE__GUARD));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.TURBO_DERIVED_RULE__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.TURBO_DERIVED_RULE__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIterativeWhileRuleAccess().getGuardTermParserRuleCall_1_0(), semanticObject.getGuard());
		feeder.accept(grammarAccess.getIterativeWhileRuleAccess().getRuleRuleParserRuleCall_3_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FairnessConstraint returns JusticeConstraint
	 *     JusticeConstraint returns JusticeConstraint
	 *
	 * Constraint:
	 *     body=Term
	 */
	protected void sequence_JusticeConstraint(ISerializationContext context, JusticeConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.JUSTICE_CONSTRAINT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.JUSTICE_CONSTRAINT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJusticeConstraintAccess().getBodyTermParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns LetRule
	 *     BasicRule returns LetRule
	 *     LetRule returns LetRule
	 *
	 * Constraint:
	 *     (variable+=VariableTerm initExpression+=Term (variable+=VariableTerm initExpression+=Term)* inRule=Rule)
	 */
	protected void sequence_LetRule(ISerializationContext context, LetRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns LetTerm
	 *     ExtendedTerm returns LetTerm
	 *     VariableBindingTerm returns LetTerm
	 *     LetTerm returns LetTerm
	 *
	 * Constraint:
	 *     (variable+=VariableTerm assignmentTerm+=Term (variable+=VariableTerm assignmentTerm+=Term)* body=Term)
	 */
	protected void sequence_LetTerm(ISerializationContext context, LetTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns LocalFunction
	 *     BasicFunction returns LocalFunction
	 *     DynamicFunction returns LocalFunction
	 *     LocalFunction returns LocalFunction
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name=extendedName domain=getDomainByID? codomain=getDomainByID)
	 */
	protected void sequence_LocalFunction(ISerializationContext context, LocalFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns LocationTerm
	 *     Expression returns LocationTerm
	 *     ImpliesIffExpression returns LocationTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns LocationTerm
	 *     XorOrExpression returns LocationTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns LocationTerm
	 *     AndExpression returns LocationTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns LocationTerm
	 *     EqualityExpression returns LocationTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns LocationTerm
	 *     CompareExpression returns LocationTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns LocationTerm
	 *     AdditiveExpression returns LocationTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns LocationTerm
	 *     MultiplicativeExpression returns LocationTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns LocationTerm
	 *     PowerExpression returns LocationTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns LocationTerm
	 *     UnaryOperation returns LocationTerm
	 *     ParenthesizedExpression returns LocationTerm
	 *     basicExpr returns LocationTerm
	 *     BasicTerm returns LocationTerm
	 *     LocationTerm returns LocationTerm
	 *
	 * Constraint:
	 *     (agent=extendedName? functionName=extendedNameForFunction arguments=TupleTerm?)
	 */
	protected void sequence_LocationTerm(ISerializationContext context, LocationTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns LtlSpec
	 *     TemporalProperty returns LtlSpec
	 *     LtlSpec returns LtlSpec
	 *
	 * Constraint:
	 *     (name=ID? body=Term)
	 */
	protected void sequence_LtlSpec(ISerializationContext context, LtlSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns MacroCallRule
	 *     BasicRule returns MacroCallRule
	 *     MacroCallRule returns MacroCallRule
	 *
	 * Constraint:
	 *     (name=extendedName (parameters+=Term parameters+=Term*)?)
	 */
	protected void sequence_MacroCallRule(ISerializationContext context, MacroCallRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleDeclaration returns MacroDeclaration
	 *     MacroDeclaration returns MacroDeclaration
	 *
	 * Constraint:
	 *     (
	 *         name=RULE_ID 
	 *         (variables+=ID_VARIABLE domain+=getDomainByID (variables+=ID_VARIABLE domain+=getDomainByID)*)? 
	 *         returnedDomain=getDomainByID? 
	 *         ruleBody=Rule
	 *     )
	 */
	protected void sequence_MacroDeclaration(ISerializationContext context, MacroDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns MapCT
	 *     ExtendedTerm returns MapCT
	 *     VariableBindingTerm returns MapCT
	 *     ComprehensionTerm returns MapCT
	 *     MapCT returns MapCT
	 *
	 * Constraint:
	 *     (variable+=VariableTerm ranges+=Term (variable+=VariableTerm ranges+=Term)* guard=Term? term=Term)
	 */
	protected void sequence_MapCT(ISerializationContext context, MapCT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns MapDomain
	 *     TypeDomain returns MapDomain
	 *     StructuredTD returns MapDomain
	 *     MapDomain returns MapDomain
	 *     getDomainByID returns MapDomain
	 *     Term returns MapDomain
	 *     DomainTerm returns MapDomain
	 *
	 * Constraint:
	 *     (name='Map' sourceDomain=getDomainByID targetDomain=getDomainByID)
	 */
	protected void sequence_MapDomain(ISerializationContext context, MapDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.MAP_DOMAIN__SOURCE_DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.MAP_DOMAIN__SOURCE_DOMAIN));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.MAP_DOMAIN__TARGET_DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.MAP_DOMAIN__TARGET_DOMAIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapDomainAccess().getNameMapKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMapDomainAccess().getSourceDomainGetDomainByIDParserRuleCall_2_0(), semanticObject.getSourceDomain());
		feeder.accept(grammarAccess.getMapDomainAccess().getTargetDomainGetDomainByIDParserRuleCall_4_0(), semanticObject.getTargetDomain());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns MapTerm
	 *     ExtendedTerm returns MapTerm
	 *     CollectionTerm returns MapTerm
	 *     MapTerm returns MapTerm
	 *
	 * Constraint:
	 *     (term+=Term term+=Term (term+=Term term+=Term)*)?
	 */
	protected void sequence_MapTerm(ISerializationContext context, MapTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns MonitoredFunction
	 *     BasicFunction returns MonitoredFunction
	 *     DynamicFunction returns MonitoredFunction
	 *     MonitoredFunction returns MonitoredFunction
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name=extendedName domain=getDomainByID? codomain=getDomainByID)
	 */
	protected void sequence_MonitoredFunction(ISerializationContext context, MonitoredFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns NaturalDomain
	 *     TypeDomain returns NaturalDomain
	 *     BasicTD returns NaturalDomain
	 *     StandardDomain returns NaturalDomain
	 *     NaturalDomain returns NaturalDomain
	 *     getDomainByID returns NaturalDomain
	 *     Term returns NaturalDomain
	 *     DomainTerm returns NaturalDomain
	 *
	 * Constraint:
	 *     name='Natural'
	 */
	protected void sequence_NaturalDomain(ISerializationContext context, NaturalDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNaturalDomainAccess().getNameNaturalKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns NaturalTerm
	 *     Expression returns NaturalTerm
	 *     ImpliesIffExpression returns NaturalTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns NaturalTerm
	 *     XorOrExpression returns NaturalTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns NaturalTerm
	 *     AndExpression returns NaturalTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns NaturalTerm
	 *     EqualityExpression returns NaturalTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns NaturalTerm
	 *     CompareExpression returns NaturalTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns NaturalTerm
	 *     AdditiveExpression returns NaturalTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns NaturalTerm
	 *     MultiplicativeExpression returns NaturalTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns NaturalTerm
	 *     PowerExpression returns NaturalTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns NaturalTerm
	 *     UnaryOperation returns NaturalTerm
	 *     ParenthesizedExpression returns NaturalTerm
	 *     basicExpr returns NaturalTerm
	 *     BasicTerm returns NaturalTerm
	 *     ConstantTerm returns NaturalTerm
	 *     NaturalTerm returns NaturalTerm
	 *
	 * Constraint:
	 *     symbol=NATNUMBER
	 */
	protected void sequence_NaturalTerm(ISerializationContext context, NaturalTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNaturalTermAccess().getSymbolNATNUMBERTerminalRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns OutFunction
	 *     BasicFunction returns OutFunction
	 *     DynamicFunction returns OutFunction
	 *     OutFunction returns OutFunction
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name=extendedName domain=getDomainByID? codomain=getDomainByID)
	 */
	protected void sequence_OutFunction(ISerializationContext context, OutFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns PowersetDomain
	 *     TypeDomain returns PowersetDomain
	 *     StructuredTD returns PowersetDomain
	 *     PowersetDomain returns PowersetDomain
	 *     getDomainByID returns PowersetDomain
	 *     Term returns PowersetDomain
	 *     DomainTerm returns PowersetDomain
	 *
	 * Constraint:
	 *     (name='Powerset' baseDomain=getDomainByID)
	 */
	protected void sequence_PowersetDomain(ISerializationContext context, PowersetDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.POWERSET_DOMAIN__BASE_DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.POWERSET_DOMAIN__BASE_DOMAIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowersetDomainAccess().getNamePowersetKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPowersetDomainAccess().getBaseDomainGetDomainByIDParserRuleCall_2_0(), semanticObject.getBaseDomain());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns ProductDomain
	 *     TypeDomain returns ProductDomain
	 *     StructuredTD returns ProductDomain
	 *     ProductDomain returns ProductDomain
	 *     getDomainByID returns ProductDomain
	 *     Term returns ProductDomain
	 *     DomainTerm returns ProductDomain
	 *
	 * Constraint:
	 *     (name='Prod' domains+=getDomainByID domains+=getDomainByID+)
	 */
	protected void sequence_ProductDomain(ISerializationContext context, ProductDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns RealDomain
	 *     TypeDomain returns RealDomain
	 *     BasicTD returns RealDomain
	 *     StandardDomain returns RealDomain
	 *     RealDomain returns RealDomain
	 *     getDomainByID returns RealDomain
	 *     Term returns RealDomain
	 *     DomainTerm returns RealDomain
	 *
	 * Constraint:
	 *     name='Real'
	 */
	protected void sequence_RealDomain(ISerializationContext context, RealDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealDomainAccess().getNameRealKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns RealTerm
	 *     Expression returns RealTerm
	 *     ImpliesIffExpression returns RealTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns RealTerm
	 *     XorOrExpression returns RealTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns RealTerm
	 *     AndExpression returns RealTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns RealTerm
	 *     EqualityExpression returns RealTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns RealTerm
	 *     CompareExpression returns RealTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns RealTerm
	 *     AdditiveExpression returns RealTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns RealTerm
	 *     MultiplicativeExpression returns RealTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns RealTerm
	 *     PowerExpression returns RealTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns RealTerm
	 *     UnaryOperation returns RealTerm
	 *     ParenthesizedExpression returns RealTerm
	 *     basicExpr returns RealTerm
	 *     BasicTerm returns RealTerm
	 *     ConstantTerm returns RealTerm
	 *     NumberTerm returns RealTerm
	 *     RealTerm returns RealTerm
	 *
	 * Constraint:
	 *     symbol=RealNumberWithSign
	 */
	protected void sequence_RealTerm(ISerializationContext context, RealTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealTermAccess().getSymbolRealNumberWithSignParserRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns RecursiveWhileRule
	 *     DerivedRule returns RecursiveWhileRule
	 *     TurboDerivedRule returns RecursiveWhileRule
	 *     RecursiveWhileRule returns RecursiveWhileRule
	 *
	 * Constraint:
	 *     (guard=Term rule=Rule)
	 */
	protected void sequence_RecursiveWhileRule(ISerializationContext context, RecursiveWhileRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.TURBO_DERIVED_RULE__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.TURBO_DERIVED_RULE__GUARD));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.TURBO_DERIVED_RULE__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.TURBO_DERIVED_RULE__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecursiveWhileRuleAccess().getGuardTermParserRuleCall_1_0(), semanticObject.getGuard());
		feeder.accept(grammarAccess.getRecursiveWhileRuleAccess().getRuleRuleParserRuleCall_3_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns ReserveDomain
	 *     TypeDomain returns ReserveDomain
	 *     AbstractTD returns ReserveDomain
	 *     ReserveDomain returns ReserveDomain
	 *     getDomainByID returns ReserveDomain
	 *     Term returns ReserveDomain
	 *     DomainTerm returns ReserveDomain
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name='Reserve')
	 */
	protected void sequence_ReserveDomain(ISerializationContext context, ReserveDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns RuleAsTerm
	 *     ExtendedTerm returns RuleAsTerm
	 *     RuleAsTerm returns RuleAsTerm
	 *
	 * Constraint:
	 *     (name=extendedName (domains+=getDomainByID domains+=getDomainByID*)?)
	 */
	protected void sequence_RuleAsTerm(ISerializationContext context, RuleAsTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns RuleDomain
	 *     TypeDomain returns RuleDomain
	 *     StructuredTD returns RuleDomain
	 *     RuleDomain returns RuleDomain
	 *     getDomainByID returns RuleDomain
	 *     Term returns RuleDomain
	 *     DomainTerm returns RuleDomain
	 *
	 * Constraint:
	 *     (name='Rule' (domains+=getDomainByID domains+=getDomainByID*)?)
	 */
	protected void sequence_RuleDomain(ISerializationContext context, RuleDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns SeqRule
	 *     TurboRule returns SeqRule
	 *     SeqRule returns SeqRule
	 *
	 * Constraint:
	 *     (rules+=Rule rules+=Rule+)
	 */
	protected void sequence_SeqRule(ISerializationContext context, SeqRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SequenceCT
	 *     ExtendedTerm returns SequenceCT
	 *     VariableBindingTerm returns SequenceCT
	 *     ComprehensionTerm returns SequenceCT
	 *     SequenceCT returns SequenceCT
	 *
	 * Constraint:
	 *     (variable+=VariableTerm ranges+=Term (variable+=VariableTerm ranges+=Term)* guard=Term? term=Term)
	 */
	protected void sequence_SequenceCT(ISerializationContext context, SequenceCT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns SequenceDomain
	 *     TypeDomain returns SequenceDomain
	 *     StructuredTD returns SequenceDomain
	 *     SequenceDomain returns SequenceDomain
	 *     getDomainByID returns SequenceDomain
	 *     Term returns SequenceDomain
	 *     DomainTerm returns SequenceDomain
	 *
	 * Constraint:
	 *     (name='Seq' domain=getDomainByID)
	 */
	protected void sequence_SequenceDomain(ISerializationContext context, SequenceDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.SEQUENCE_DOMAIN__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.SEQUENCE_DOMAIN__DOMAIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSequenceDomainAccess().getNameSeqKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSequenceDomainAccess().getDomainGetDomainByIDParserRuleCall_2_0(), semanticObject.getDomain());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SequenceTerm
	 *     ExtendedTerm returns SequenceTerm
	 *     CollectionTerm returns SequenceTerm
	 *     SequenceTerm returns SequenceTerm
	 *
	 * Constraint:
	 *     (start_term=Term (other_terms+=Term+ | (end_term=Term step=ConstantTerm?))?)?
	 */
	protected void sequence_SequenceTerm(ISerializationContext context, SequenceTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SetCT
	 *     ExtendedTerm returns SetCT
	 *     VariableBindingTerm returns SetCT
	 *     ComprehensionTerm returns SetCT
	 *     SetCT returns SetCT
	 *
	 * Constraint:
	 *     (variable+=VariableTerm ranges+=Term (variable+=VariableTerm ranges+=Term)* guard=Term? term=Term)
	 */
	protected void sequence_SetCT(ISerializationContext context, SetCT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SetTerm
	 *     ExtendedTerm returns SetTerm
	 *     CollectionTerm returns SetTerm
	 *     SetTerm returns SetTerm
	 *
	 * Constraint:
	 *     (start_term=Term (other_terms+=Term+ | (end_term=Term step=ConstantTerm?))?)?
	 */
	protected void sequence_SetTerm(ISerializationContext context, SetTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns SharedFunction
	 *     BasicFunction returns SharedFunction
	 *     DynamicFunction returns SharedFunction
	 *     SharedFunction returns SharedFunction
	 *
	 * Constraint:
	 *     (dynamic?='dynamic'? name=extendedName domain=getDomainByID? codomain=getDomainByID)
	 */
	protected void sequence_SharedFunction(ISerializationContext context, SharedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signature returns Signature
	 *
	 * Constraint:
	 *     (domain+=Domain* function+=Function*)
	 */
	protected void sequence_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns SkipRule
	 *     BasicRule returns SkipRule
	 *     SkipRule returns SkipRule
	 *
	 * Constraint:
	 *     {SkipRule}
	 */
	protected void sequence_SkipRule(ISerializationContext context, SkipRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns StaticFunction
	 *     BasicFunction returns StaticFunction
	 *     StaticFunction returns StaticFunction
	 *
	 * Constraint:
	 *     (name=extendedNameForFunction domain=getDomainByID? codomain=getDomainByID)
	 */
	protected void sequence_StaticFunction(ISerializationContext context, StaticFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns StringDomain
	 *     TypeDomain returns StringDomain
	 *     BasicTD returns StringDomain
	 *     StandardDomain returns StringDomain
	 *     StringDomain returns StringDomain
	 *     getDomainByID returns StringDomain
	 *     Term returns StringDomain
	 *     DomainTerm returns StringDomain
	 *
	 * Constraint:
	 *     name='String'
	 */
	protected void sequence_StringDomain(ISerializationContext context, StringDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringDomainAccess().getNameStringKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns StringTerm
	 *     Expression returns StringTerm
	 *     ImpliesIffExpression returns StringTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns StringTerm
	 *     XorOrExpression returns StringTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns StringTerm
	 *     AndExpression returns StringTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns StringTerm
	 *     EqualityExpression returns StringTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns StringTerm
	 *     CompareExpression returns StringTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns StringTerm
	 *     AdditiveExpression returns StringTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns StringTerm
	 *     MultiplicativeExpression returns StringTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns StringTerm
	 *     PowerExpression returns StringTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns StringTerm
	 *     UnaryOperation returns StringTerm
	 *     ParenthesizedExpression returns StringTerm
	 *     basicExpr returns StringTerm
	 *     BasicTerm returns StringTerm
	 *     ConstantTerm returns StringTerm
	 *     StringTerm returns StringTerm
	 *
	 * Constraint:
	 *     symbol=STRING_LITERAL
	 */
	protected void sequence_StringTerm(ISerializationContext context, StringTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTermAccess().getSymbolSTRING_LITERALTerminalRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns TermAsRule
	 *     TermAsRule returns TermAsRule
	 *
	 * Constraint:
	 *     ((term=FunctionTerm | term=VariableTerm) (parameters+=Term parameters+=Term*)?)
	 */
	protected void sequence_TermAsRule(ISerializationContext context, TermAsRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns TupleTerm
	 *     ExtendedTerm returns TupleTerm
	 *     TupleTerm returns TupleTerm
	 *
	 * Constraint:
	 *     (terms+=Term terms+=Term*)
	 */
	protected void sequence_TupleTerm(ISerializationContext context, TupleTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns TurboCallRule
	 *     TurboRule returns TurboCallRule
	 *     TurboCallRule returns TurboCallRule
	 *
	 * Constraint:
	 *     (calledRuleName=RULE_ID (parameters+=Term parameters+=Term*)?)
	 */
	protected void sequence_TurboCallRule(ISerializationContext context, TurboCallRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleDeclaration returns TurboDeclaration
	 *     TurboDeclaration returns TurboDeclaration
	 *
	 * Constraint:
	 *     (
	 *         name=RULE_ID 
	 *         (variables+=ID_VARIABLE domain+=getDomainByID (variables+=ID_VARIABLE domain+=getDomainByID)*)? 
	 *         returnedDomain=getDomainByID? 
	 *         ruleBody=Rule
	 *     )
	 */
	protected void sequence_TurboDeclaration(ISerializationContext context, TurboDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns TurboLocalStateRule
	 *     TurboRule returns TurboLocalStateRule
	 *     TurboLocalStateRule returns TurboLocalStateRule
	 *
	 * Constraint:
	 *     (localFunction+=LocalFunction init+=Rule (localFunction+=LocalFunction init+=Rule)* body=Rule)
	 */
	protected void sequence_TurboLocalStateRule(ISerializationContext context, TurboLocalStateRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns TurboReturnRule
	 *     TurboReturnRule returns TurboReturnRule
	 *
	 * Constraint:
	 *     ((location=FunctionTerm | location=VariableTerm) updateRule=TurboCallRule)
	 */
	protected void sequence_TurboReturnRule(ISerializationContext context, TurboReturnRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns Expression
	 *     Expression returns Expression
	 *     ImpliesIffExpression returns Expression
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     XorOrExpression returns Expression
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     AndExpression returns Expression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     EqualityExpression returns Expression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     CompareExpression returns Expression
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     AdditiveExpression returns Expression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     MultiplicativeExpression returns Expression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     PowerExpression returns Expression
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns Expression
	 *     UnaryOperation returns Expression
	 *     ParenthesizedExpression returns Expression
	 *
	 * Constraint:
	 *     ((op='not' | op='+' | op='-') operand=UnaryOperation)
	 */
	protected void sequence_UnaryOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns UndefDomain
	 *     TypeDomain returns UndefDomain
	 *     BasicTD returns UndefDomain
	 *     StandardDomain returns UndefDomain
	 *     UndefDomain returns UndefDomain
	 *     getDomainByID returns UndefDomain
	 *     Term returns UndefDomain
	 *     DomainTerm returns UndefDomain
	 *
	 * Constraint:
	 *     name='Undef'
	 */
	protected void sequence_UndefDomain(ISerializationContext context, UndefDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUndefDomainAccess().getNameUndefKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns UndefTerm
	 *     Expression returns UndefTerm
	 *     ImpliesIffExpression returns UndefTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns UndefTerm
	 *     XorOrExpression returns UndefTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns UndefTerm
	 *     AndExpression returns UndefTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns UndefTerm
	 *     EqualityExpression returns UndefTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns UndefTerm
	 *     CompareExpression returns UndefTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns UndefTerm
	 *     AdditiveExpression returns UndefTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns UndefTerm
	 *     MultiplicativeExpression returns UndefTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns UndefTerm
	 *     PowerExpression returns UndefTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns UndefTerm
	 *     UnaryOperation returns UndefTerm
	 *     ParenthesizedExpression returns UndefTerm
	 *     basicExpr returns UndefTerm
	 *     BasicTerm returns UndefTerm
	 *     ConstantTerm returns UndefTerm
	 *     UndefTerm returns UndefTerm
	 *
	 * Constraint:
	 *     symbol='undef'
	 */
	protected void sequence_UndefTerm(ISerializationContext context, UndefTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.CONSTANT_TERM__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUndefTermAccess().getSymbolUndefKeyword_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns UpdateRule
	 *     UpdateRule returns UpdateRule
	 *
	 * Constraint:
	 *     ((location=LocationTerm | location=VariableTerm) updatingTerm=Term)
	 */
	protected void sequence_UpdateRule(ISerializationContext context, UpdateRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns VariableTerm
	 *     Expression returns VariableTerm
	 *     ImpliesIffExpression returns VariableTerm
	 *     ImpliesIffExpression.BinaryOperation_1_0_0_0 returns VariableTerm
	 *     XorOrExpression returns VariableTerm
	 *     XorOrExpression.BinaryOperation_1_0_0_0 returns VariableTerm
	 *     AndExpression returns VariableTerm
	 *     AndExpression.BinaryOperation_1_0_0_0 returns VariableTerm
	 *     EqualityExpression returns VariableTerm
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns VariableTerm
	 *     CompareExpression returns VariableTerm
	 *     CompareExpression.BinaryOperation_1_0_0_0 returns VariableTerm
	 *     AdditiveExpression returns VariableTerm
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns VariableTerm
	 *     MultiplicativeExpression returns VariableTerm
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns VariableTerm
	 *     PowerExpression returns VariableTerm
	 *     PowerExpression.BinaryOperation_1_0_0_0 returns VariableTerm
	 *     UnaryOperation returns VariableTerm
	 *     ParenthesizedExpression returns VariableTerm
	 *     basicExpr returns VariableTerm
	 *     BasicTerm returns VariableTerm
	 *     VariableTerm returns VariableTerm
	 *
	 * Constraint:
	 *     name=ID_VARIABLE
	 */
	protected void sequence_VariableTerm(ISerializationContext context, VariableTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.VARIABLE_TERM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.VARIABLE_TERM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableTermAccess().getNameID_VARIABLEParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     getDomainByID returns Domain
	 *     Term returns Domain
	 *     DomainTerm returns Domain
	 *
	 * Constraint:
	 *     (name='Agent' | name='Reserve' | name=ID)
	 */
	protected void sequence_getDomainByID_nameofDomain(ISerializationContext context, Domain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     importData returns importData
	 *
	 * Constraint:
	 *     name=extendedName
	 */
	protected void sequence_importData(ISerializationContext context, importData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.IMPORT_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.IMPORT_DATA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportDataAccess().getNameExtendedNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     nameofDomain returns Domain
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_nameofDomain(ISerializationContext context, Domain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsmetalPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameofDomainAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
