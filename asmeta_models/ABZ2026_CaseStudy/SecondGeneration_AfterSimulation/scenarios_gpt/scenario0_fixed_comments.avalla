scenario scenario0_fixed

load ./../RoverReducedMain.asm

// --- Initial state checks (from RoverReducedMain default init s0)
check currentPosition = (0,0);
check goal = (0,0);
check batteryLevel = 95;
check recharge = false;
check atGoal = false;
check isAtCharger = false;
check moving = false;
check panelState = CLOSED;
check chargingComplete = false;
check noplan = false;
check failure = false;
check awaitingInstructions = false;
check plan2C = [];
check activePlan = [];

// Set the need for recharge, so that the charger is selected as the goal
set measuredBatteryLevel := 9;

// --- Environment + mission setup
set chargers := {(5,3)};                       // (5,3) is a charger
set planSet := {[(1,0),(2,0),(3,0),(4,0),(5,0),(5,1),(5,2),(5,3)]};  
set planningFailure := false;
set goalSet := false;                          // not used unless awaitingInstructions=true

// =====================
// Step 1: move to (1,0)
// =====================
//set measuredBatteryLevel := 20; // already set above
check plan2C = []; // added
step
check currentPosition = (0,0); // was (1,0), should be (0,0) -> currentPosition updated only when activePlan is not empty, but is empty
check moving = false; // was true, should be false -> if not(noplan) and recharge and chargingComplete then -> recharge e chargingComplete is false
check isAtCharger = false; // OK
check panelState = CLOSED; // OK
check atGoal = true; // was false, should be true -> atGoal := (currentPosition = goal) -> (0,0) = (0,0)
check chargingComplete = false;
check failure = false; // OK
check noplan = false; // OK
check awaitingInstructions = false; // OK
check batteryLevel = 8; // was 19, should be 8 -> we set measuredBatteryLevel two times, the first is kept apparently

// From here added
check recharge = false; // false se batteryLevel > (distManhattan((currentPosition, goal)) + stepsToFinishPlan(plan2C) + safetyMarginSteps) -> 9 > 0 + 0 + 1
// ma poi perché settiamo charge a true se batteryLevel < di quello che serve per arrivare al charger (plan2C)?
check goal = (0,0);
check plan2C = [(1,0),(2,0),(3,0),(4,0),(5,0),(5,1),(5,2),(5,3)];

step
check currentPosition = (0,0);
check recharge = true; // true se batteryLevel <= (distManhattan((currentPosition, goal)) + stepsToFinishPlan(plan2C) + safetyMarginSteps) -> 8 <= 0 + 8 + 1
check goal = (0,0);

step
check currentPosition = (0,0);
check recharge = true;
check goal = (5,3); // recharge è true -> goal := nearestChargerToNow(chargers)

// Il goal adesso è settato e diverso da current position, perché non si muove???
step step step step step
check currentPosition = (0,0); 


/*
// =====================
// Step 2: move to (2,0)
// =====================
set measuredBatteryLevel := 18;
step
check currentPosition = (2,0);
check moving = true;
check isAtCharger = false;
check panelState = CLOSED;
check atGoal = false;
check chargingComplete = false;
check batteryLevel = 17;

// =====================
// Step 3: move to (3,0)
// =====================
set measuredBatteryLevel := 16;
step
check currentPosition = (3,0);
check moving = true;
check isAtCharger = false;
check panelState = CLOSED;
check atGoal = false;
check chargingComplete = false;
check batteryLevel = 15;

// =====================
// Step 4: move to (4,0)
// =====================
set measuredBatteryLevel := 14;
step
check currentPosition = (4,0);
check moving = true;
check isAtCharger = false;
check panelState = CLOSED;
check atGoal = false;
check chargingComplete = false;
check batteryLevel = 13;

// =====================
// Step 5: move to (5,0)
// =====================
set measuredBatteryLevel := 12;
step
check currentPosition = (5,0);
check moving = true;
check isAtCharger = false;
check panelState = CLOSED;
check atGoal = false;
check chargingComplete = false;
check batteryLevel = 11;

// =====================
// Step 6: move to (5,1)
// =====================
set measuredBatteryLevel := 10;
step
check currentPosition = (5,1);
check moving = true;
check isAtCharger = false;
check panelState = CLOSED;
check atGoal = false;
check chargingComplete = false;
check batteryLevel = 9;

// =====================
// Step 7: move to (5,2)
// =====================
set measuredBatteryLevel := 8;
step
check currentPosition = (5,2);
check moving = true;
check isAtCharger = false;
check panelState = CLOSED;
check atGoal = false;
check chargingComplete = false;
check batteryLevel = 7;

// =====================
// Step 8: arrive at charger goal (5,3)
// =====================
set measuredBatteryLevel := 6;
step
check currentPosition = (5,3);
check atGoal = true;
check isAtCharger = true;

// Solar panel controller should open panels when at a charger
check panelState = OPEN;

check chargingComplete = false;
check batteryLevel = 5;

// ==================================================
// Step 9: battery now low -> rover must (re)charge
// (we drive battery low via measuredBatteryLevel)
// ==================================================
set measuredBatteryLevel := 2;
step
check currentPosition = (5,3);
check atGoal = true;
check isAtCharger = true;
check panelState = OPEN;

// In this reduced model, "recharge" becomes true when battery is too low
check recharge = true;

check chargingComplete = false;
check batteryLevel = 1;

// ========================================
// Step 10: charging completes -> close panel
// ========================================
set measuredBatteryLevel := 100;   // battery back up while charging
step
check currentPosition = (5,3);
check atGoal = true;
check isAtCharger = true;
check chargingComplete = true;
// Solar panel controller should close panels when charging is complete
check panelState = CLOSED;

check batteryLevel = 95;*/