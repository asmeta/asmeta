scenario rover_to_charger_2_3_recharge

load ./../RoverReducedMain.asm

// ------------------------------------------------------------
// Scenario intent (high-level):
// - Start at (0,0) with enough battery.
// - The goal should become (2,3), which is a charger.
// - While progressing, the battery (batteryLevel) decreases as a consequence of
//   decreasing measuredBatteryLevel (BatteryMonitor: batteryLevel := rtoi(measured*95/100)).
// - When at a charger, SolarPanelController opens panels (panelState := OPEN).
//
// NOTE (modeling limitation reminder):
// In Avalla we can only "set" monitored functions and "check" controlled ones.
// Also, ASM updates are applied at the end of each step.
// ------------------------------------------------------------

// =====================
// State 0 (initial)
// =====================
check currentPosition = (0,0);
check goal = (0,0);
check batteryLevel = 95;
check recharge = false;
check atGoal = false;
check moving = false;
check isAtCharger = false;
check panelState = CLOSED;
check plan2C = [];
check noplan = false;
check failure = false;
check awaitingInstructions = false;

// Provide a charger set that includes the target charger (2,3)
set chargers := {(2,3)};

// Provide a non-empty planSet so ComputePlan2Charging can select a plan2C and keep noplan=false.
// (This plan is abstract: a sequence of waypoint positions.)
set planSet := {[(1,1),(2,2),(2,3)]};

// No planner failure
set planningFailure := false;

// Start from a high measured battery (BatteryMonitor will keep batteryLevel high)
set measuredBatteryLevel := 100;

// We do not use goalSet here (kept false)
set goalSet := false;

step

// =====================
// After Step 1 (controlled state updated)
// =====================
// BatteryMonitor: batteryLevel := rtoi(100*95/100) = 95
check batteryLevel = 95;

// ComputePlan2Charging: selects a plan2C from planSet; and sets noplan=false, failure=false
check plan2C = [(1,1),(2,2),(2,3)];
check noplan = false;
check failure = false;

// HardwareInterface computes recharge based on *old* goal=(0,0) in this step (ASM semantics),
// so recharge is expected to remain false with a high battery.
check recharge = false;

// Not at goal yet (goal is still (0,0) here)
check goal = (0,0);

// Not at a charger yet (charger is (2,3), currentPosition still (0,0))
check isAtCharger = false;
check panelState = CLOSED;

// =====================
// Step 2: force low battery so that recharge becomes true,
// then (in the *next* step) GRA can set the goal to nearest charger (2,3).
// =====================
set chargers := {(2,3)};
set planSet := {[(1,1),(2,2),(2,3)]};
set planningFailure := false;

// Make battery very low: batteryLevel := rtoi(10*95/100) = 9
set measuredBatteryLevel := 10;

// keep goalSet false
set goalSet := false;

step

// After Step 2: battery drops, and HardwareInterface sets recharge=true (since battery is too low)
check batteryLevel = 9;
check recharge = true;

// In THIS same step, GRA still read the *old* recharge value (from previous state),
// so goal is still expected to be unchanged at end of Step 2.
check goal = (0,0);

// =====================
// Step 3: now that recharge=true in the current state,
// GRA sets goal to nearest charger => (2,3).
// =====================
set chargers := {(2,3)};
set planSet := {[(1,1),(2,2),(2,3)]};
set planningFailure := false;

// Keep measured low (still “needs recharge”)
set measuredBatteryLevel := 1;

set goalSet := false;

step

// After Step 3: goal is updated to the nearest charger (2,3)
check goal = (2,3);

// Still not at the charger yet (position unchanged in this reduced model)
check currentPosition = (0,0);
check isAtCharger = false;
check panelState = CLOSED;

// Battery stays low as per measuredBatteryLevel
check batteryLevel = 0;

// Recharge should still be true while battery is low
check recharge = true;