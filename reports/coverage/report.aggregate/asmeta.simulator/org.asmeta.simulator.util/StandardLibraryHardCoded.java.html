<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StandardLibraryHardCoded.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">report.aggregate</a> &gt; <a href="../index.html" class="el_bundle">asmeta.simulator</a> &gt; <a href="index.source.html" class="el_package">org.asmeta.simulator.util</a> &gt; <span class="el_source">StandardLibraryHardCoded.java</span></div><h1>StandardLibraryHardCoded.java</h1><pre class="source lang-java linenums">package org.asmeta.simulator.util;

<span class="nc" id="L3">public class StandardLibraryHardCoded {</span>
	public final static String StandardLibrary = &quot;module StandardLibrary\n&quot; + 
			&quot;\n&quot; + 
			&quot;export *\n&quot; + 
			&quot;\n&quot; + 
			&quot;signature :\n&quot; + 
			&quot;	/*----------- Domains --------------*/\n&quot; + 
			&quot;	anydomain Any\n&quot; + 
			&quot;	anydomain D\n&quot; + 
			&quot;	anydomain D1\n&quot; + 
			&quot;	anydomain D2\n&quot; + 
			&quot;	anydomain D3\n&quot; + 
			&quot;	anydomain D4\n&quot; + 
			&quot;	anydomain D5\n&quot; + 
			&quot;	anydomain D6\n&quot; + 
			&quot;	anydomain D7\n&quot; + 
			&quot;	anydomain D8\n&quot; + 
			&quot;	anydomain D9\n&quot; + 
			&quot;\n&quot; + 
			&quot;	basic domain Complex\n&quot; + 
			&quot;	basic domain Real\n&quot; + 
			&quot;	basic domain Integer\n&quot; + 
			&quot;	basic domain Natural\n&quot; + 
			&quot;	basic domain Char\n&quot; + 
			&quot;	basic domain String\n&quot; + 
			&quot;	basic domain Boolean\n&quot; + 
			&quot;	basic domain Undef\n&quot; + 
			&quot;	\n&quot; + 
			&quot;	abstract domain Agent\n&quot; + 
			&quot;	abstract domain Reserve\n&quot; + 
			&quot;\n&quot; + 
			&quot;	// ************** very nasty functions\n&quot; + 
			&quot;	// used to print something\n&quot; + 
			&quot;	static print: D -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1) -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1, D2) -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1, D2, D3) -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1, D2, D3, D4) -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1, D2, D3, D4, D5) -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1, D2, D3, D4, D5, D6) -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1, D2, D3, D4, D5, D6, D7) -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1, D2, D3, D4, D5, D6, D7, D8) -&gt; Integer\n&quot; + 
			&quot;	static print: Prod(D, D1, D2, D3, D4, D5, D6, D7, D8, D9) -&gt; Integer\n&quot; + 
			&quot;	// **************\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*-----------Reserved 0-ary function--------------------*/\n&quot; + 
			&quot;	controlled result: Any\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- ASM Functions on all Domains -------------*/\n&quot; + 
			&quot;	static eq: Prod(D,D) -&gt; Boolean\n&quot; + 
			&quot;	static neq: Prod(D,D) -&gt; Boolean\n&quot; + 
			&quot;	static isDef: D -&gt; Boolean\n&quot; + 
			&quot;	static isUndef: D -&gt; Boolean\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Relational operators with mixed arithmetic domains -----*/\n&quot; + 
			&quot;	static eq: Prod(Natural, Integer) -&gt; Boolean\n&quot; + 
			&quot;	static eq: Prod(Integer, Natural) -&gt; Boolean\n&quot; + 
			&quot;	static eq: Prod(Real, Natural) -&gt; Boolean\n&quot; + 
			&quot;	static eq: Prod(Natural, Real) -&gt; Boolean\n&quot; + 
			&quot;	static eq: Prod(Real, Integer) -&gt; Boolean\n&quot; + 
			&quot;	static eq: Prod(Integer, Real) -&gt; Boolean\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Complex--------------*/	\n&quot; + 
			&quot;	static re: Complex -&gt; Real\n&quot; + 
			&quot;	static im: Complex -&gt; Real\n&quot; + 
			&quot;	static plus: Prod(Complex, Complex) -&gt; Complex\n&quot; + 
			&quot;	static minus: Prod (Complex, Complex) -&gt; Complex\n&quot; + 
			&quot;	static mult: Prod (Complex, Complex) -&gt; Complex\n&quot; + 
			&quot;	static div: Prod (Complex, Complex) -&gt; Complex\n&quot; + 
			&quot;	static minus: Complex -&gt; Complex\n&quot; + 
			&quot;	static norm: Complex -&gt; Complex\n&quot; + 
			&quot;	static iszero: Complex -&gt; Boolean\n&quot; + 
			&quot;	static toString: Complex -&gt; String\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Real--------------*/\n&quot; + 
			&quot;	static plus: Real -&gt; Real\n&quot; + 
			&quot;	static plus: Prod(Real, Real) -&gt; Real\n&quot; + 
			&quot;	static minus: Real -&gt; Real\n&quot; + 
			&quot;	static minus: Prod(Real, Real) -&gt; Real\n&quot; + 
			&quot;	static mult: Prod (Real, Real) -&gt; Real\n&quot; + 
			&quot;	static div: Prod (Real, Real) -&gt; Real\n&quot; + 
			&quot;	static abs: Real -&gt; Real\n&quot; + 
			&quot;	static floor: Real -&gt; Integer\n&quot; + 
			&quot;	static round: Real -&gt; Integer\n&quot; + 
			&quot;	static sqrt: Real -&gt; Real\n&quot; + 
			&quot;	static pwr: Prod (Real, Real) -&gt; Real\n&quot; + 
			&quot;	static max: Prod (Real, Real) -&gt; Real\n&quot; + 
			&quot;	static min: Prod (Real, Real) -&gt; Real\n&quot; + 
			&quot;	static toString: Real -&gt; String\n&quot; + 
			&quot;	static lt: Prod (Real, Real) -&gt; Boolean\n&quot; + 
			&quot;	static gt: Prod (Real, Real) -&gt; Boolean\n&quot; + 
			&quot;	static le: Prod (Real, Real) -&gt; Boolean\n&quot; + 
			&quot;	static ge: Prod (Real, Real) -&gt; Boolean\n&quot; + 
			&quot;	//CONVERSION\n&quot; + 
			&quot;	static rtoi: Real -&gt; Integer\n&quot; + 
			&quot;	static rton: Real -&gt; Natural\n&quot; + 
			&quot;\n&quot; + 
			&quot;	// returns the range between two numbers\n&quot; + 
			&quot;	static range: Prod(Natural, Natural) -&gt; Powerset(Natural)\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Integer --------------*/\n&quot; + 
			&quot;	static plus: Integer -&gt; Integer\n&quot; + 
			&quot;	static plus: Prod(Integer, Integer) -&gt; Integer\n&quot; + 
			&quot;	static minus: Integer -&gt; Integer\n&quot; + 
			&quot;	static minus: Prod(Integer, Integer) -&gt; Integer\n&quot; + 
			&quot;	static mult: Prod(Integer, Integer) -&gt; Integer\n&quot; + 
			&quot;	static div: Prod(Integer, Integer) -&gt; Real\n&quot; + 
			&quot;	static abs: Integer -&gt; Integer\n&quot; + 
			&quot;	static idiv: Prod(Integer, Integer) -&gt; Integer\n&quot; + 
			&quot;	static mod: Prod(Integer, Integer) -&gt; Integer\n&quot; + 
			&quot;	static mod: Prod(Integer, Natural) -&gt; Integer\n&quot; + 
			&quot;	static mod: Prod(Natural, Integer) -&gt; Integer\n&quot; + 
			&quot;	static max: Prod(Integer, Integer) -&gt; Integer\n&quot; + 
			&quot;	static min: Prod(Integer, Integer) -&gt; Integer\n&quot; + 
			&quot;	static toString: Integer -&gt; String\n&quot; + 
			&quot;	static lt: Prod(Integer, Integer) -&gt; Boolean\n&quot; + 
			&quot;	static gt: Prod(Integer, Integer) -&gt; Boolean\n&quot; + 
			&quot;	static le: Prod(Integer, Integer) -&gt; Boolean\n&quot; + 
			&quot;	static ge: Prod(Integer, Integer) -&gt; Boolean\n&quot; + 
			&quot;	//CONVERSION\n&quot; + 
			&quot;	static itor: Integer -&gt; Real\n&quot; + 
			&quot;	static iton: Integer -&gt; Natural\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Natural --------------*/\n&quot; + 
			&quot;	static plus: Prod(Natural, Natural) -&gt; Natural\n&quot; + 
			&quot;	static minus: Prod(Natural, Natural) -&gt; Integer\n&quot; + 
			&quot;	static mult: Prod(Natural, Natural) -&gt; Natural\n&quot; + 
			&quot;	static div: Prod(Natural, Natural) -&gt; Real\n&quot; + 
			&quot;	static idiv: Prod(Natural, Natural) -&gt; Natural\n&quot; + 
			&quot;	static mod: Prod(Natural, Natural) -&gt; Natural\n&quot; + 
			&quot;	static max: Prod(Natural, Natural) -&gt; Natural\n&quot; + 
			&quot;	static min: Prod(Natural, Natural) -&gt; Natural\n&quot; + 
			&quot;	static toString: Natural -&gt; String\n&quot; + 
			&quot;	static lt: Prod(Natural, Natural) -&gt; Boolean\n&quot; + 
			&quot;	static gt: Prod(Natural, Natural) -&gt; Boolean\n&quot; + 
			&quot;	static le: Prod(Natural, Natural) -&gt; Boolean\n&quot; + 
			&quot;	static ge: Prod(Natural, Natural) -&gt; Boolean\n&quot; + 
			&quot;	//CONVERSION\n&quot; + 
			&quot;	static ntoi: Natural -&gt; Integer\n&quot; + 
			&quot;	static ntor: Natural -&gt; Real\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Char --------------*/\n&quot; + 
			&quot;	static toString: Char -&gt; String\n&quot; + 
			&quot;	static lt: Prod(Char, Char) -&gt; Boolean\n&quot; + 
			&quot;	static gt: Prod(Char, Char) -&gt; Boolean\n&quot; + 
			&quot;	static le: Prod(Char, Char) -&gt; Boolean\n&quot; + 
			&quot;	static ge: Prod(Char, Char) -&gt; Boolean\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on String --------------*/\n&quot; + 
			&quot;	static size: String -&gt; Integer\n&quot; + 
			&quot;	static plus: Prod(String, String) -&gt; String\n&quot; + 
			&quot;	static concat: Prod(String, String) -&gt; String\n&quot; + 
			&quot;	static toUpper: String -&gt; String\n&quot; + 
			&quot;	static toLower: String -&gt; String\n&quot; + 
			&quot;	static subString: Prod(String, Integer, Integer) -&gt; String\n&quot; + 
			&quot;	static contains: Prod(String, String) -&gt; Boolean //Does the first argument contain the second argument?\n&quot; + 
			&quot;	static toInteger: String -&gt; Integer\n&quot; + 
			&quot;	static toNatural: String -&gt; Natural\n&quot; + 
			&quot;	static toReal: String -&gt; Real\n&quot; + 
			&quot;	static toComplex: String -&gt; Complex\n&quot; + 
			&quot;	static toChar: String -&gt; Char\n&quot; + 
			&quot;	static split: Prod(String, String) -&gt; Seq(String)\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Boolean --------------*/\n&quot; + 
			&quot;	static or: Prod(Boolean, Boolean) -&gt; Boolean\n&quot; + 
			&quot;	static xor: Prod(Boolean, Boolean) -&gt; Boolean\n&quot; + 
			&quot;	static and: Prod(Boolean, Boolean) -&gt; Boolean\n&quot; + 
			&quot;	static not: Boolean -&gt; Boolean\n&quot; + 
			&quot;	static implies: Prod(Boolean, Boolean) -&gt; Boolean\n&quot; + 
			&quot;	static iff: Prod(Boolean, Boolean) -&gt; Boolean\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Agent--------------*/	\n&quot; + 
			&quot;	static id: Agent -&gt; String\n&quot; + 
			&quot;	static getAgent: String -&gt; Agent\n&quot; + 
			&quot;	static program: Agent -&gt; Rule\n&quot; + 
			&quot;	controlled self: Agent\n&quot; + 
			&quot;	static eq: Prod(Agent,Agent) -&gt; Boolean\n&quot; + 
			&quot;	static neq: Prod(Agent,Agent) -&gt; Boolean\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Sets--------------*/\n&quot; + 
			&quot;	static size: Powerset(D)-&gt; Integer\n&quot; + 
			&quot;	static contains: Prod(Powerset(D), D) -&gt; Boolean\n&quot; + 
			&quot;	static notin: Prod(Powerset(D), D)-&gt; Boolean\n&quot; + 
			&quot;	static allin: Prod(Powerset(D), Powerset(D)) -&gt; Boolean\n&quot; + 
			&quot;	static notallin: Prod(Powerset(D), Powerset(D)) -&gt; Boolean\n&quot; + 
			&quot;	static isEmpty: Powerset(D) -&gt; Boolean\n&quot; + 
			&quot;	static notEmpty: Powerset(D) -&gt; Boolean\n&quot; + 
			&quot;	static sum: Powerset(D) -&gt; D\n&quot; + 
			&quot;	static union: Prod(Powerset(D), Powerset(D)) -&gt; Powerset(D)\n&quot; + 
			&quot;	static union: Prod(Powerset(D), Bag(D)) -&gt; Bag(D)\n&quot; + 
			&quot;	// ANGELO 2018/7/31 perchï¿½ equality e non eq??? - parse rejects \&quot;a = {5}\&quot;\n&quot; + 
			&quot;	static equality: Prod(Powerset(D), Powerset(D)) -&gt; Boolean\n&quot; + 
			&quot;	static intersection: Prod(Powerset(D), Powerset(D)) -&gt; Powerset(D)\n&quot; + 
			&quot;	static intersection: Prod(Powerset(D), Bag(D)) -&gt; Powerset(D)\n&quot; + 
			&quot;	static difference: Prod(Powerset(D), Powerset(D)) -&gt; Powerset(D)\n&quot; + 
			&quot;	static including: Prod(Powerset(D), D) -&gt; Powerset(D)\n&quot; + 
			&quot;	static excluding: Prod(Powerset(D), D) -&gt; Powerset(D)\n&quot; + 
			&quot;	static symmetricDifference: Prod(Powerset(D), Powerset(D)) -&gt; Powerset(D)\n&quot; + 
			&quot;	//static count: Prod(Powerset(D),D) -&gt; Natural // PA 18/12/2010 Maybe not needed on sets. An element either belong or not belong to a set. contains should be enough. \n&quot; + 
			&quot;	static asSequence: Powerset(D) -&gt; Seq(D)\n&quot; + 
			&quot;	static asBag: Powerset(D) -&gt; Bag(D)\n&quot; + 
			&quot;\n&quot; + 
			&quot;	//Return one element of the given set, value undefined if set is empty\n&quot; + 
			&quot;	static chooseone: Powerset(D) -&gt; D\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Sequences--------------*/\n&quot; + 
			&quot;	static count: Prod(Seq(D),D) -&gt; Natural\n&quot; + 
			&quot;	static length: Seq(D) -&gt; Integer\n&quot; + 
			&quot;	static isEmpty: Seq(D) -&gt; Boolean\n&quot; + 
			&quot;	static contains: Prod(Seq(D), D)-&gt; Boolean\n&quot; + 
			&quot;	static union: Prod(Seq(D), Seq(D)) -&gt; Seq(D)\n&quot; + 
			&quot;	// ANGELO 2018/7/31 equality is missing\n&quot; + 
			&quot;	static append: Prod(Seq(D), D) -&gt; Seq(D)\n&quot; + 
			&quot;	static prepend: Prod(D, Seq(D)) -&gt; Seq(D)\n&quot; + 
			&quot;	static insertAt: Prod(Seq(D), Natural, D) -&gt; Seq(D)\n&quot; + 
			&quot;	static subSequence: Prod(Seq(D), Natural, Natural) -&gt; Seq(D)\n&quot; + 
			&quot;	static at: Prod(Seq(D),Natural) -&gt; D\n&quot; + 
			&quot;	static indexOf: Prod(Seq(D),D) -&gt; Integer\n&quot; + 
			&quot;	static first: Seq(D) -&gt; D\n&quot; + 
			&quot;	static last: Seq(D) -&gt; D\n&quot; + 
			&quot;	static asBag: Seq(D) -&gt; Bag(D)\n&quot; + 
			&quot;	static asSet: Seq(D) -&gt; Powerset(D)\n&quot; + 
			&quot;	static excluding: Prod(Seq(D),D) -&gt; Seq(D)\n&quot; + 
			&quot;	static tail: Seq(D) -&gt; Seq(D)\n&quot; + 
			&quot;	static replaceAt: Prod(Seq(D),Natural,D) -&gt; Seq(D)//Da decidere se tenerla. Suggerita da Luca Baggio.\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Bags--------------*/\n&quot; + 
			&quot;	static union: Prod(Bag(D),Bag(D))-&gt;Bag(D)\n&quot; + 
			&quot;	static union: Prod(Bag(D),Powerset(D))-&gt;Bag(D)\n&quot; + 
			&quot;	static contains: Prod(Bag(D), D)-&gt; Boolean\n&quot; + 
			&quot;	static intersection: Prod(Bag(D),Bag(D))-&gt;Bag(D)\n&quot; + 
			&quot;	static intersection: Prod(Bag(D),Powerset(D))-&gt;Bag(D)\n&quot; + 
			&quot;	static including: Prod(Bag(D),D) -&gt; Bag(D)\n&quot; + 
			&quot;	static excluding: Prod(Bag(D),D) -&gt; Bag(D)\n&quot; + 
			&quot;	static count: Prod(Bag(D),D) -&gt; Natural\n&quot; + 
			&quot;	static asSequence: Bag(D) -&gt; Seq(D)\n&quot; + 
			&quot;	static asSet: Bag(D) -&gt; Powerset(D)\n&quot; + 
			&quot;	static sum: Bag(D) -&gt; D\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Maps--------------*/\n&quot; + 
			&quot;	static merge: Prod(Map(D1,D2),Map(D1,D2)) -&gt; Map(D1,D2)\n&quot; + 
			&quot;	static assign: Prod(Map(D1,D2),D1,D2) -&gt; Map(D1,D2)\n&quot; + 
			&quot;	static at: Prod(Map(D1,D2),D1) -&gt; D2\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Basic Functions on Products--------------*/\n&quot; + 
			&quot;	static at: Prod(Prod(D1,D2),Natural) -&gt; Any\n&quot; + 
			&quot;	static at: Prod(Prod(D1,D2,D3),Natural) -&gt; Any\n&quot; + 
			&quot;	static at: Prod(Prod(D1,D2,D3,D4),Natural) -&gt; Any\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static indexOf: Prod(Prod(D1,D2),Any) -&gt; Integer\n&quot; + 
			&quot;	static indexOf: Prod(Prod(D1,D2,D3),Any) -&gt; Integer\n&quot; + 
			&quot;	static indexOf: Prod(Prod(D1,D2,D3,D4),Any) -&gt; Integer\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static first: Prod(D1,D2) -&gt; D1\n&quot; + 
			&quot;	static first: Prod(D1,D2,D3) -&gt; D1\n&quot; + 
			&quot;	static first: Prod(D1,D2,D3,D4) -&gt; D1\n&quot; + 
			&quot;	static first: Prod(D1,D2,D3,D4,D5) -&gt; D1\n&quot; + 
			&quot;	static first: Prod(D1,D2,D3,D4,D5,D6) -&gt; D1\n&quot; + 
			&quot;	static first: Prod(D1,D2,D3,D4,D5,D6,D7) -&gt; D1\n&quot; + 
			&quot;	static first: Prod(D1,D2,D3,D4,D5,D6,D7,D8) -&gt; D1\n&quot; + 
			&quot;	static first: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D1\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static second: Prod(D1,D2) -&gt; D2\n&quot; + 
			&quot;	static second: Prod(D1,D2,D3) -&gt; D2\n&quot; + 
			&quot;	static second: Prod(D1,D2,D3,D4) -&gt; D2\n&quot; + 
			&quot;	static second: Prod(D1,D2,D3,D4,D5) -&gt; D2\n&quot; + 
			&quot;	static second: Prod(D1,D2,D3,D4,D5,D6) -&gt; D2\n&quot; + 
			&quot;	static second: Prod(D1,D2,D3,D4,D5,D6,D7) -&gt; D2\n&quot; + 
			&quot;	static second: Prod(D1,D2,D3,D4,D5,D6,D7,D8) -&gt; D2\n&quot; + 
			&quot;	static second: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D2\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static third: Prod(D1,D2,D3) -&gt; D3\n&quot; + 
			&quot;	static third: Prod(D1,D2,D3,D4) -&gt; D3\n&quot; + 
			&quot;	static third: Prod(D1,D2,D3,D4,D5) -&gt; D3\n&quot; + 
			&quot;	static third: Prod(D1,D2,D3,D4,D5,D6) -&gt; D3\n&quot; + 
			&quot;	static third: Prod(D1,D2,D3,D4,D5,D6,D7) -&gt; D3\n&quot; + 
			&quot;	static third: Prod(D1,D2,D3,D4,D5,D6,D7,D8) -&gt; D3\n&quot; + 
			&quot;	static third: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D3\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static fourth: Prod(D1,D2,D3,D4) -&gt; D4\n&quot; + 
			&quot;	static fourth: Prod(D1,D2,D3,D4,D5) -&gt; D4\n&quot; + 
			&quot;	static fourth: Prod(D1,D2,D3,D4,D5,D6) -&gt; D4\n&quot; + 
			&quot;	static fourth: Prod(D1,D2,D3,D4,D5,D6,D7) -&gt; D4\n&quot; + 
			&quot;	static fourth: Prod(D1,D2,D3,D4,D5,D6,D7,D8) -&gt; D4\n&quot; + 
			&quot;	static fourth: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D4\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static fifth: Prod(D1,D2,D3,D4,D5) -&gt; D5\n&quot; + 
			&quot;	static fifth: Prod(D1,D2,D3,D4,D5,D6) -&gt; D5\n&quot; + 
			&quot;	static fifth: Prod(D1,D2,D3,D4,D5,D6,D7) -&gt; D5\n&quot; + 
			&quot;	static fifth: Prod(D1,D2,D3,D4,D5,D6,D7,D8) -&gt; D5\n&quot; + 
			&quot;	static fifth: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D5\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static sixth: Prod(D1,D2,D3,D4,D5,D6) -&gt; D6\n&quot; + 
			&quot;	static sixth: Prod(D1,D2,D3,D4,D5,D6,D7) -&gt; D6\n&quot; + 
			&quot;	static sixth: Prod(D1,D2,D3,D4,D5,D6,D7,D8) -&gt; D6\n&quot; + 
			&quot;	static sixth: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D6\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static seventh: Prod(D1,D2,D3,D4,D5,D6,D7) -&gt; D7\n&quot; + 
			&quot;	static seventh: Prod(D1,D2,D3,D4,D5,D6,D7,D8) -&gt; D7\n&quot; + 
			&quot;	static seventh: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D7\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static eighth: Prod(D1,D2,D3,D4,D5,D6,D7,D8) -&gt; D8\n&quot; + 
			&quot;	static eighth: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D8\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static ninth: Prod(D1,D2,D3,D4,D5,D6,D7,D8,D9) -&gt; D9\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static toString: D -&gt; String\n&quot; + 
			&quot;\n&quot; + 
			&quot;\n&quot; + 
			&quot;	static pre: D -&gt; D\n&quot; + 
			&quot;\n&quot; + 
			&quot;/*----------- Java time--------------*/\n&quot; + 
			&quot;	static currTimeNanosecs: Integer	\n&quot; + 
			&quot;	static currTimeMillisecs: Integer\n&quot; + 
			&quot;	static currTimeSecs: Integer\n&quot; + 
			&quot;\n&quot; + 
			&quot;definitions:\n&quot; + 
			&quot;&quot;;

	public final static String CTLlibrary = &quot;module CTLlibrary\n&quot; + 
			&quot;\n&quot; + 
			&quot;export *\n&quot; + 
			&quot;\n&quot; + 
			&quot;signature:\n&quot; + 
			&quot;	/*-----------CTL formulas------------*/\n&quot; + 
			&quot;	static eg: Boolean -&gt; Boolean	//exists globally\n&quot; + 
			&quot;	static ex: Boolean -&gt; Boolean	//exists next state\n&quot; + 
			&quot;	static ef: Boolean -&gt; Boolean	//exists finally\n&quot; + 
			&quot;	static ag: Boolean -&gt; Boolean	//forall globally\n&quot; + 
			&quot;	static ax: Boolean -&gt; Boolean	//forall next state\n&quot; + 
			&quot;	static af: Boolean -&gt; Boolean	//forall finally\n&quot; + 
			&quot;	static e: Prod(Boolean, Boolean) -&gt; Boolean	//exists until\n&quot; + 
			&quot;	static a: Prod(Boolean, Boolean) -&gt; Boolean //forall until\n&quot; + 
			&quot;\n&quot; + 
			&quot;	/*-----------Patterns------------*/\n&quot; + 
			&quot;	static ew: Prod(Boolean, Boolean) -&gt; Boolean  //exists weak until -- E[p U q] | EGp.\n&quot; + 
			&quot;	static aw: Prod(Boolean, Boolean) -&gt; Boolean //forall weak until -- !E[!q U !(p | q)].\n&quot; + 
			&quot;\n&quot; + 
			&quot;\n&quot; + 
			&quot;	//http://patterns.projects.cis.ksu.edu/documentation/patterns/ctl.shtml\n&quot; + 
			&quot;	//Absence (P is false)\n&quot; + 
			&quot;	//Globally - AG(!P)\n&quot; + 
			&quot;	static absenceG: Boolean -&gt; Boolean\n&quot; + 
			&quot;	//(*) Before R - A[(!P | AG(!R)) W R]\n&quot; + 
			&quot;	static absenceBefore: Prod(Boolean, Boolean) -&gt; Boolean // absenceBefore(P, R)\n&quot; + 
			&quot;	//After Q - AG(Q -&gt; AG(!P))\n&quot; + 
			&quot;	static absenceAfter: Prod(Boolean, Boolean) -&gt; Boolean // absenceAfter(P, Q)\n&quot; + 
			&quot;	//(*) Between Q and R - AG(Q &amp; !R -&gt; A[(!P | AG(!R)) W R])\n&quot; + 
			&quot;	static absenceBetween: Prod(Boolean, Boolean, Boolean) -&gt; Boolean // absenceBetween(P, Q, R)\n&quot; + 
			&quot;	//(*) After Q until R - AG(Q &amp; !R -&gt; A[!P W R])\n&quot; + 
			&quot;	static absenceAfterUntil: Prod(Boolean, Boolean, Boolean) -&gt; Boolean // absenceAfterUntil(P, Q, R)\n&quot; + 
			&quot;\n&quot; + 
			&quot;	//Precedence (S precedes P)\n&quot; + 
			&quot;	//(*) Globally 	\n&quot; + 
			&quot;	//A[!P W S]\n&quot; + 
			&quot;	static ap: Prod(Boolean, Boolean) -&gt; Boolean // ap(P, S)\n&quot; + 
			&quot;	//(*) Before R 	\n&quot; + 
			&quot;	//A[(!P | AG(!R)) W (S | R)]\n&quot; + 
			&quot;	static pb: Prod(Boolean, Boolean, Boolean) -&gt; Boolean // pb(P, S, R)\n&quot; + 
			&quot;	//(*) After Q 	\n&quot; + 
			&quot;	//A[!Q W (Q &amp; A[!P W S])]\n&quot; + 
			&quot;	//(*) Between Q and R 	\n&quot; + 
			&quot;	//AG(Q &amp; !R -&gt; A[(!P | AG(!R)) W (S | R)])\n&quot; + 
			&quot;	//(*) After Q until R 	\n&quot; + 
			&quot;	//AG(Q &amp; !R -&gt; A[!P W (S | R)])\n&quot; + 
			&quot;\n&quot; + 
			&quot;	//Response (S responds to P)\n&quot; + 
			&quot;	//Globally\n&quot; + 
			&quot;	//AG(P -&gt; AF(S))\n&quot; + 
			&quot;	//(*) Before R	\n&quot; + 
			&quot;	//A[((P -&gt; A[!R U (S &amp; !R)]) | AG(!R)) W R]\n&quot; + 
			&quot;	//(*) After Q	\n&quot; + 
			&quot;	//A[!Q W (Q &amp; AG(P -&gt; AF(S))] \n&quot; + 
			&quot;	//(*) Between Q and R	\n&quot; + 
			&quot;	//AG(Q &amp; !R -&gt; A[((P -&gt; A[!R U (S &amp; !R)]) | AG(!R)) W R])\n&quot; + 
			&quot;	//(*) After Q until R	\n&quot; + 
			&quot;	//AG(Q &amp; !R -&gt; A[(P -&gt; A[!R U (S &amp; !R)]) W R])\n&quot; + 
			&quot;\n&quot; + 
			&quot;	/*-----------My CTL formulas------------*/\n&quot; + 
			&quot;	static exN: Prod(Boolean, Natural) -&gt; Boolean	//exists after N states\n&quot; + 
			&quot;	static axN: Prod(Boolean, Natural) -&gt; Boolean	//forall paths, after N states\n&quot; + 
			&quot;definitions:\n&quot; + 
			&quot;&quot;;

	public final static String LTLlibrary = &quot;module LTLlibrary\n&quot; + 
			&quot;\n&quot; + 
			&quot;export *\n&quot; + 
			&quot;\n&quot; + 
			&quot;signature:\n&quot; + 
			&quot;	/*-----------LTL formulas------------*/ \n&quot; + 
			&quot;	//Future\n&quot; + 
			&quot;	static x: Boolean -&gt; Boolean			//next state\n&quot; + 
			&quot;	static g: Boolean -&gt; Boolean			//globally\n&quot; + 
			&quot;	static f: Boolean -&gt; Boolean			//finally\n&quot; + 
			&quot;	static u: Prod(Boolean, Boolean) -&gt; Boolean	//until\n&quot; + 
			&quot;	static v: Prod(Boolean, Boolean) -&gt; Boolean	//releases\n&quot; + 
			&quot;	//Past\n&quot; + 
			&quot;	static y: Boolean -&gt; Boolean			//previous state\n&quot; + 
			&quot;	static z: Boolean -&gt; Boolean			//not previous state not\n&quot; + 
			&quot;	static h: Boolean -&gt; Boolean			//historically\n&quot; + 
			&quot;	static o: Boolean -&gt; Boolean			//once\n&quot; + 
			&quot;	static s: Prod(Boolean, Boolean) -&gt; Boolean	//since\n&quot; + 
			&quot;	static t: Prod(Boolean, Boolean) -&gt; Boolean	//triggered\n&quot; + 
			&quot;\n&quot; + 
			&quot;definitions:\n&quot; + 
			&quot;&quot;;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>